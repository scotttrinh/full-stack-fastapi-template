#
# Automatically generated from Gel schema.
#
# Do not edit directly as re-generating this file will overwrite any changes.
#

from __future__ import annotations

from .. import std

from gel.models import pydantic, pydantic as ___pydantic__
from gel.models.pydantic import (
    AnyEnum,
    ComputedMultiLink,
    ComputedProperty,
    DEFAULT_VALUE,
    DefaultValue,
    Direction,
    EmptyDirection,
    ExprCompatible,
    GelLinkModel,
    GelModelMeta,
    GelPointerReflection,
    LazyClassProperty,
    MultiLink,
    MultiLinkWithProps,
    MultiProperty,
    OptionalComputedProperty,
    OptionalLink,
    OptionalProperty,
    PathAlias,
    PointerKind,
    ProxyModel,
    PyConstType,
    SchemaPath,
    Unspecified,
    UnspecifiedType
)

import builtins as ___builtins_2__
import builtins as ___builtins_3__
import builtins as ___builtins__
import builtins as ___builtins_1__
from builtins import list, object, tuple, type
from collections.abc import Callable, Iterable
from typing import Any, Literal, TYPE_CHECKING, TypeVar
from typing_extensions import Self, TypeAliasType
from uuid import UUID

if TYPE_CHECKING:

    from .. import std as ___std__
    from ... import schema, sys as ___sys__
    from ...std import __types__ as std___types__

    from gel.models import pydantic as ___pydantic_1__

    from builtins import dict, str


class AccessKind(AnyEnum):
    Select = 'Select'
    UpdateRead = 'UpdateRead'
    UpdateWrite = 'UpdateWrite'
    Delete = 'Delete'
    Insert = 'Insert'


class AccessPolicyAction(AnyEnum):
    Allow = 'Allow'
    Deny = 'Deny'


class Cardinality(AnyEnum):
    One = 'One'
    Many = 'Many'


class IndexDeferrability(AnyEnum):
    Prohibited = 'Prohibited'
    Permitted = 'Permitted'
    Required = 'Required'


class MigrationGeneratedBy(AnyEnum):
    DevMode = 'DevMode'
    DDLStatement = 'DDLStatement'


class OperatorKind(AnyEnum):
    Infix = 'Infix'
    Postfix = 'Postfix'
    Prefix = 'Prefix'
    Ternary = 'Ternary'


class ParameterKind(AnyEnum):
    VariadicParam = 'VariadicParam'
    NamedOnlyParam = 'NamedOnlyParam'
    PositionalParam = 'PositionalParam'


class RewriteKind(AnyEnum):
    Update = 'Update'
    Insert = 'Insert'


class SourceDeleteAction(AnyEnum):
    DeleteTarget = 'DeleteTarget'
    Allow = 'Allow'
    DeleteTargetIfOrphan = 'DeleteTargetIfOrphan'


class TargetDeleteAction(AnyEnum):
    Restrict = 'Restrict'
    DeleteSource = 'DeleteSource'
    Allow = 'Allow'
    DeferredRestrict = 'DeferredRestrict'


class TriggerKind(AnyEnum):
    Update = 'Update'
    Delete = 'Delete'
    Insert = 'Insert'


class TriggerScope(AnyEnum):
    All = 'All'
    Each = 'Each'


class TriggerTiming(AnyEnum):
    After = 'After'
    AfterCommitOf = 'AfterCommitOf'


class TypeModifier(AnyEnum):
    SetOfType = 'SetOfType'
    OptionalType = 'OptionalType'
    SingletonType = 'SingletonType'


class Volatility(AnyEnum):
    Immutable = 'Immutable'
    Stable = 'Stable'
    Volatile = 'Volatile'
    Modifying = 'Modifying'




#
# type schema::Object
#
class __Object_typeof_base__(std.__BaseObject_typeof_base__):
    class __gel_reflection__(
        std.__BaseObject_typeof_base__.__gel_reflection__,
    ):
        id = UUID(int=67762926258550356151524041794332124377)
        name = SchemaPath('schema', 'Object')
        @LazyClassProperty["dict[str, GelPointerReflection]"]
        @classmethod
        def pointers(cls) -> dict[str, GelPointerReflection]:
            my_ptrs: dict[str, GelPointerReflection] = {
                'name': GelPointerReflection(
                    name='name',
                    type=SchemaPath('std', 'str'),
                    typexpr='std::str',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('One'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
                'internal': GelPointerReflection(
                    name='internal',
                    type=SchemaPath('std', 'bool'),
                    typexpr='std::bool',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('One'),
                    computed=False,
                    readonly=False,
                    has_default=True,
                    properties={},
                ),
                'builtin': GelPointerReflection(
                    name='builtin',
                    type=SchemaPath('std', 'bool'),
                    typexpr='std::bool',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('One'),
                    computed=False,
                    readonly=False,
                    has_default=True,
                    properties={},
                ),
                'computed_fields': GelPointerReflection(
                    name='computed_fields',
                    type=SchemaPath('array<std::str>'),
                    typexpr='array<std::str>',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
            }
            return (
                my_ptrs
                | std.__BaseObject_typeof_base__.__gel_reflection__.pointers
            )

        @LazyClassProperty["schema.ObjectType"]
        @classmethod
        def object(cls) -> schema.ObjectType:
            from ... import schema as ___schema__
            return ___schema__.ObjectType(
                id=UUID(int=67762926258550356151524041794332124377),
                name='schema::Object',
                builtin=True,
                internal=False,
                abstract=True,
                final=False,
                compound_type=False,
            )

class __Object_typeof__(std.__BaseObject_typeof__, __Object_typeof_base__):
    class __typeof__(std.__BaseObject_typeof__.__typeof__):
        name = TypeAliasType('name', 'std.str')
        internal = TypeAliasType('internal', 'std.bool')
        builtin = TypeAliasType('builtin', 'std.bool')
        computed_fields = TypeAliasType('computed_fields', 'OptionalProperty[___pydantic__.Array[std.str], list[builtins.str]]')


class __Object_typeof_partial__(
    std.__BaseObject_typeof_partial__,
    __Object_typeof_base__,
):
    class __typeof__(std.__BaseObject_typeof_partial__.__typeof__):
        name = TypeAliasType('name', 'OptionalProperty[std.str, builtins.str]')
        internal = TypeAliasType('internal', 'OptionalProperty[std.bool, bool]')
        builtin = TypeAliasType('builtin', 'OptionalProperty[std.bool, bool]')
        computed_fields = TypeAliasType('computed_fields', 'OptionalProperty[___pydantic__.Array[std.str], list[builtins.str]]')


class Object(
    __Object_typeof__,
    std.BaseObject,
    __gel_type_id__=UUID(int=67762926258550356151524041794332124377),
):
    if TYPE_CHECKING:
        def __init__(
            self,
            /,
            *,
            id: UUID | DefaultValue = DEFAULT_VALUE,
            name: builtins.str,
            internal: bool | DefaultValue = DEFAULT_VALUE,
            builtin: bool | DefaultValue = DEFAULT_VALUE,
            computed_fields: list[builtins.str] | None = None,
        ) -> None:
            """Create a new schema::Object instance from keyword arguments.

            Call db.save() on the returned object to persist it in the database.
            """
            ...

    if TYPE_CHECKING:
        @classmethod
        def update(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Update schema::Object instances in the database.
            """
            ...

        @classmethod
        def select(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: PathAlias | Literal["*"],
            id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
        ) -> type[Self]:
            """Fetch schema::Object instances from the database.
            """
            ...

        @classmethod
        def filter(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], type[___std__.bool]],
            id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Fetch schema::Object instances from the database.
            """
            ...

        @classmethod
        def order_by(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
            id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Specify the sort order for the selection"""
            ...


    class __variants__(std.BaseObject.__variants__):
        class Base(
            __Object_typeof__,
            std.BaseObject.__variants__.Base,
            __gel_variant__="Base",
        ):
            if TYPE_CHECKING:
                def __init__(
                    self,
                    /,
                    *,
                    id: UUID | DefaultValue = DEFAULT_VALUE,
                    name: builtins.str,
                    internal: bool | DefaultValue = DEFAULT_VALUE,
                    builtin: bool | DefaultValue = DEFAULT_VALUE,
                    computed_fields: list[builtins.str] | None = None,
                ) -> None:
                    """Create a new schema::Object instance from keyword arguments.

                    Call db.save() on the returned object to persist it in the database.
                    """
                    ...

            if TYPE_CHECKING:
                @classmethod
                def update(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Update schema::Object instances in the database.
                    """
                    ...

                @classmethod
                def select(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: PathAlias | Literal["*"],
                    id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
                ) -> type[Self]:
                    """Fetch schema::Object instances from the database.
                    """
                    ...

                @classmethod
                def filter(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], type[___std__.bool]],
                    id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Fetch schema::Object instances from the database.
                    """
                    ...

                @classmethod
                def order_by(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
                    id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Specify the sort order for the selection"""
                    ...

        class Required(
            Base,
            std.BaseObject.__variants__.Required,
            __gel_variant__="Required",
        ):
            name: std.str
            internal: std.bool
            builtin: std.bool

        class PartialBase(  # type: ignore [misc, unused-ignore]
            __Object_typeof_partial__,
            Base,
            std.BaseObject.__variants__.PartialBase,
            __gel_variant__="PartialBase",
        ):
            pass

        class Partial(  # type: ignore [misc, unused-ignore]
            PartialBase,
            std.BaseObject.__variants__.Partial,
            __gel_variant__="Partial",
        ):
            name: OptionalProperty[std.str, builtins.str]
            internal: OptionalProperty[std.bool, bool]
            builtin: OptionalProperty[std.bool, bool]
            computed_fields: OptionalProperty[___pydantic__.Array[std.str], list[builtins.str]]


        Any = TypeVar("Any", bound="Object | Base | Required | Partial")
    class __links__(std.BaseObject.__links__):
        pass
    class __links_partial__(std.BaseObject.__links_partial__):
        pass

if not TYPE_CHECKING:
    Object.__variants__.Base = Object



#
# type schema::TupleElement
#
class __TupleElement_typeof_base__(std.__BaseObject_typeof_base__):
    class __gel_reflection__(
        std.__BaseObject_typeof_base__.__gel_reflection__,
    ):
        id = UUID(int=208358010397048077362121740569112613627)
        name = SchemaPath('schema', 'TupleElement')
        @LazyClassProperty["dict[str, GelPointerReflection]"]
        @classmethod
        def pointers(cls) -> dict[str, GelPointerReflection]:
            my_ptrs: dict[str, GelPointerReflection] = {
                'name': GelPointerReflection(
                    name='name',
                    type=SchemaPath('std', 'str'),
                    typexpr='std::str',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
                'type': GelPointerReflection(
                    name='type',
                    type=SchemaPath('schema', 'Type'),
                    typexpr='schema::Type',
                    kind=PointerKind('Link'),
                    cardinality=pydantic.Cardinality('One'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
            }
            return (
                my_ptrs
                | std.__BaseObject_typeof_base__.__gel_reflection__.pointers
            )

        @LazyClassProperty["schema.ObjectType"]
        @classmethod
        def object(cls) -> schema.ObjectType:
            from ... import schema as ___schema__
            return ___schema__.ObjectType(
                id=UUID(int=208358010397048077362121740569112613627),
                name='schema::TupleElement',
                builtin=True,
                internal=False,
                abstract=False,
                final=False,
                compound_type=False,
            )

class __TupleElement_typeof__(
    std.__BaseObject_typeof__,
    __TupleElement_typeof_base__,
):
    class __typeof__(std.__BaseObject_typeof__.__typeof__):
        name = TypeAliasType('name', 'OptionalProperty[std.str, builtins.str]')
        type = TypeAliasType('type', 'Type')


class __TupleElement_typeof_partial__(
    std.__BaseObject_typeof_partial__,
    __TupleElement_typeof_base__,
):
    class __typeof__(std.__BaseObject_typeof_partial__.__typeof__):
        name = TypeAliasType('name', 'OptionalProperty[std.str, builtins.str]')
        type = TypeAliasType('type', 'Type | Type.__variants__.Partial')


class TupleElement(
    __TupleElement_typeof__,
    std.BaseObject,
    __gel_type_id__=UUID(int=208358010397048077362121740569112613627),
):
    if TYPE_CHECKING:
        def __init__(
            self,
            /,
            *,
            id: UUID | DefaultValue = DEFAULT_VALUE,
            name: builtins.str | None = None,
            type: Type | None = None,
        ) -> None:
            """Create a new schema::TupleElement instance from keyword arguments.

            Call db.save() on the returned object to persist it in the database.
            """
            ...

    if TYPE_CHECKING:
        @classmethod
        def update(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            type: type[schema.Type] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Update schema::TupleElement instances in the database.
            """
            ...

        @classmethod
        def select(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: PathAlias | Literal["*"],
            id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            type: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Type] | UnspecifiedType = Unspecified,
            **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
        ) -> type[Self]:
            """Fetch schema::TupleElement instances from the database.
            """
            ...

        @classmethod
        def filter(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], type[___std__.bool]],
            id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            type: type[schema.Type] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Fetch schema::TupleElement instances from the database.
            """
            ...

        @classmethod
        def order_by(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
            id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Specify the sort order for the selection"""
            ...


    class __variants__(std.BaseObject.__variants__):
        class Base(
            __TupleElement_typeof__,
            std.BaseObject.__variants__.Base,
            __gel_variant__="Base",
        ):
            if TYPE_CHECKING:
                def __init__(
                    self,
                    /,
                    *,
                    id: UUID | DefaultValue = DEFAULT_VALUE,
                    name: builtins.str | None = None,
                    type: Type | None = None,
                ) -> None:
                    """Create a new schema::TupleElement instance from keyword arguments.

                    Call db.save() on the returned object to persist it in the database.
                    """
                    ...

            if TYPE_CHECKING:
                @classmethod
                def update(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    type: type[schema.Type] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Update schema::TupleElement instances in the database.
                    """
                    ...

                @classmethod
                def select(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: PathAlias | Literal["*"],
                    id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    type: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Type] | UnspecifiedType = Unspecified,
                    **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
                ) -> type[Self]:
                    """Fetch schema::TupleElement instances from the database.
                    """
                    ...

                @classmethod
                def filter(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], type[___std__.bool]],
                    id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    type: type[schema.Type] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Fetch schema::TupleElement instances from the database.
                    """
                    ...

                @classmethod
                def order_by(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
                    id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Specify the sort order for the selection"""
                    ...

        class Required(
            Base,
            std.BaseObject.__variants__.Required,
            __gel_variant__="Required",
        ):
            type: ___schema__.Type

        class PartialBase(  # type: ignore [misc, unused-ignore]
            __TupleElement_typeof_partial__,
            Base,
            std.BaseObject.__variants__.PartialBase,
            __gel_variant__="PartialBase",
        ):
            pass

        class Partial(  # type: ignore [misc, unused-ignore]
            PartialBase,
            std.BaseObject.__variants__.Partial,
            __gel_variant__="Partial",
        ):
            name: OptionalProperty[std.str, builtins.str]
            type: ___schema__.Type | ___schema__.Type.__variants__.Partial


        Any = TypeVar("Any", bound="TupleElement | Base | Required | Partial")
    class __links__(std.BaseObject.__links__):
        pass
    class __links_partial__(std.BaseObject.__links_partial__):
        pass

if not TYPE_CHECKING:
    TupleElement.__variants__.Base = TupleElement



#
# type schema::AnnotationSubject
#
class __AnnotationSubject_typeof_base__(__Object_typeof_base__):
    class __gel_reflection__(__Object_typeof_base__.__gel_reflection__):
        id = UUID(int=200771465757710694205600005641852404014)
        name = SchemaPath('schema', 'AnnotationSubject')
        @LazyClassProperty["dict[str, GelPointerReflection]"]
        @classmethod
        def pointers(cls) -> dict[str, GelPointerReflection]:
            my_ptrs: dict[str, GelPointerReflection] = {
                'annotations': GelPointerReflection(
                    name='annotations',
                    type=SchemaPath('schema', 'Annotation'),
                    typexpr='schema::Annotation',
                    kind=PointerKind('Link'),
                    cardinality=pydantic.Cardinality('Many'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={
                    'owned': GelPointerReflection(
                    name='owned',
                    type=SchemaPath('std', 'bool'),
                    typexpr='std::bool',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties=None,
                ),
                    'is_owned': GelPointerReflection(
                    name='is_owned',
                    type=SchemaPath('std', 'bool'),
                    typexpr='std::bool',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties=None,
                ),
                    'value': GelPointerReflection(
                    name='value',
                    type=SchemaPath('std', 'str'),
                    typexpr='std::str',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties=None,
                ),
                },
                ),
            }
            return (
                my_ptrs
                | __Object_typeof_base__.__gel_reflection__.pointers
            )

        @LazyClassProperty["schema.ObjectType"]
        @classmethod
        def object(cls) -> schema.ObjectType:
            from ... import schema as ___schema_1__
            return ___schema_1__.ObjectType(
                id=UUID(int=200771465757710694205600005641852404014),
                name='schema::AnnotationSubject',
                builtin=True,
                internal=False,
                abstract=True,
                final=False,
                compound_type=False,
            )

class __AnnotationSubject_typeof__(
    __Object_typeof__,
    __AnnotationSubject_typeof_base__,
):
    class __typeof__(__Object_typeof__.__typeof__):
        annotations = TypeAliasType('annotations', 'MultiLinkWithProps[AnnotationSubject.__links__.annotations, Annotation]')


class __AnnotationSubject_typeof_partial__(
    __Object_typeof_partial__,
    __AnnotationSubject_typeof_base__,
):
    class __typeof__(__Object_typeof_partial__.__typeof__):
        annotations = TypeAliasType('annotations', 'MultiLinkWithProps[AnnotationSubject.__links__.annotations | AnnotationSubject.__links_partial__.annotations, Annotation]')


class AnnotationSubject(
    __AnnotationSubject_typeof__,
    Object,
    __gel_type_id__=UUID(int=200771465757710694205600005641852404014),
):
    if TYPE_CHECKING:
        def __init__(
            self,
            /,
            *,
            id: UUID | DefaultValue = DEFAULT_VALUE,
            name: builtins.str,
            internal: bool | DefaultValue = DEFAULT_VALUE,
            builtin: bool | DefaultValue = DEFAULT_VALUE,
            computed_fields: list[builtins.str] | None = None,
            annotations: Iterable[Annotation] = [],
        ) -> None:
            """Create a new schema::AnnotationSubject instance from keyword arguments.

            Call db.save() on the returned object to persist it in the database.
            """
            ...

    if TYPE_CHECKING:
        @classmethod
        def update(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Update schema::AnnotationSubject instances in the database.
            """
            ...

        @classmethod
        def select(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: PathAlias | Literal["*"],
            id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Annotation] | UnspecifiedType = Unspecified,
            **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
        ) -> type[Self]:
            """Fetch schema::AnnotationSubject instances from the database.
            """
            ...

        @classmethod
        def filter(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], type[___std__.bool]],
            id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Fetch schema::AnnotationSubject instances from the database.
            """
            ...

        @classmethod
        def order_by(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
            id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Specify the sort order for the selection"""
            ...


    class __variants__(Object.__variants__):
        class Base(
            __AnnotationSubject_typeof__,
            Object.__variants__.Base,
            __gel_variant__="Base",
        ):
            if TYPE_CHECKING:
                def __init__(
                    self,
                    /,
                    *,
                    id: UUID | DefaultValue = DEFAULT_VALUE,
                    name: builtins.str,
                    internal: bool | DefaultValue = DEFAULT_VALUE,
                    builtin: bool | DefaultValue = DEFAULT_VALUE,
                    computed_fields: list[builtins.str] | None = None,
                    annotations: Iterable[Annotation] = [],
                ) -> None:
                    """Create a new schema::AnnotationSubject instance from keyword arguments.

                    Call db.save() on the returned object to persist it in the database.
                    """
                    ...

            if TYPE_CHECKING:
                @classmethod
                def update(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Update schema::AnnotationSubject instances in the database.
                    """
                    ...

                @classmethod
                def select(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: PathAlias | Literal["*"],
                    id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Annotation] | UnspecifiedType = Unspecified,
                    **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
                ) -> type[Self]:
                    """Fetch schema::AnnotationSubject instances from the database.
                    """
                    ...

                @classmethod
                def filter(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], type[___std__.bool]],
                    id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Fetch schema::AnnotationSubject instances from the database.
                    """
                    ...

                @classmethod
                def order_by(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
                    id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Specify the sort order for the selection"""
                    ...

        class Required(
            Base,
            Object.__variants__.Required,
            __gel_variant__="Required",
        ):
            pass

        class PartialBase(  # type: ignore [misc, unused-ignore]
            __AnnotationSubject_typeof_partial__,
            Base,
            Object.__variants__.PartialBase,
            __gel_variant__="PartialBase",
        ):
            pass

        class Partial(  # type: ignore [misc, unused-ignore]
            PartialBase,
            Object.__variants__.Partial,
            __gel_variant__="Partial",
        ):
            annotations: MultiLinkWithProps[AnnotationSubject.__links__.annotations | AnnotationSubject.__links_partial__.annotations, ___schema__.Annotation]


        Any = TypeVar("Any", bound="AnnotationSubject | Base | Required | Partial")
    class __links__(Object.__links__):
        if TYPE_CHECKING:
            class annotations(
                schema.Annotation,
                ProxyModel[schema.Annotation],
            ):
                """link schema::AnnotationSubject.annotations: schema::Annotation"""
                class __lprops__(GelLinkModel):
                    class __gel_reflection__(GelLinkModel.__gel_reflection__):
                        id = UUID(int=171234699206056583856051977312110321700)
                        name = SchemaPath('annotations')
                        @LazyClassProperty["dict[str, GelPointerReflection]"]
                        @classmethod
                        def pointers(cls) -> dict[str, GelPointerReflection]:
                            my_ptrs: dict[str, GelPointerReflection] = {
                                'owned': GelPointerReflection(
                                    name='owned',
                                    type=SchemaPath('std', 'bool'),
                                    typexpr='std::bool',
                                    kind=PointerKind('Property'),
                                    cardinality=pydantic.Cardinality('AtMostOne'),
                                    computed=False,
                                    readonly=False,
                                    has_default=False,
                                    properties=None,
                                ),
                                'is_owned': GelPointerReflection(
                                    name='is_owned',
                                    type=SchemaPath('std', 'bool'),
                                    typexpr='std::bool',
                                    kind=PointerKind('Property'),
                                    cardinality=pydantic.Cardinality('AtMostOne'),
                                    computed=False,
                                    readonly=False,
                                    has_default=False,
                                    properties=None,
                                ),
                                'value': GelPointerReflection(
                                    name='value',
                                    type=SchemaPath('std', 'str'),
                                    typexpr='std::str',
                                    kind=PointerKind('Property'),
                                    cardinality=pydantic.Cardinality('AtMostOne'),
                                    computed=False,
                                    readonly=False,
                                    has_default=False,
                                    properties=None,
                                ),
                            }
                            return my_ptrs


                    owned: OptionalProperty[___std__.bool, ___builtins_2__.bool]
                    is_owned: OptionalProperty[___std__.bool, ___builtins_2__.bool]
                    value: OptionalProperty[___std__.str, ___builtins_1__.str]
                __linkprops__: __lprops__

                def __init__(
                    self,
                    obj: schema.Annotation,
                    /,
                    *,
                    owned: ___builtins_2__.bool | None = None,
                    is_owned: ___builtins_2__.bool | None = None,
                    value: ___builtins_1__.str | None = None,
                ) -> None:
                    ...

                @classmethod
                def link(
                    cls,
                    obj: schema.Annotation,
                    /,
                    *,
                    owned: ___builtins_2__.bool | None = None,
                    is_owned: ___builtins_2__.bool | None = None,
                    value: ___builtins_1__.str | None = None,
                ) -> Self:
                    ...

        if not TYPE_CHECKING:
            @LazyClassProperty[type]
            @classmethod
            def annotations(cls) -> type:
                class AnnotationSubject__annotations(
                    ___schema__.Annotation,
                    ProxyModel[___schema__.Annotation],
                ):
                    """link schema::AnnotationSubject.annotations: schema::Annotation"""
                    class __lprops__(GelLinkModel):
                        class __gel_reflection__(
                            GelLinkModel.__gel_reflection__,
                        ):
                            id = UUID(int=171234699206056583856051977312110321700)
                            name = SchemaPath('annotations')
                            @LazyClassProperty["dict[str, GelPointerReflection]"]
                            @classmethod
                            def pointers(
                                cls,
                            ) -> dict[str, GelPointerReflection]:
                                my_ptrs: dict[str, GelPointerReflection] = {
                                    'owned': GelPointerReflection(
                                        name='owned',
                                        type=SchemaPath('std', 'bool'),
                                        typexpr='std::bool',
                                        kind=PointerKind('Property'),
                                        cardinality=pydantic.Cardinality('AtMostOne'),
                                        computed=False,
                                        readonly=False,
                                        has_default=False,
                                        properties=None,
                                    ),
                                    'is_owned': GelPointerReflection(
                                        name='is_owned',
                                        type=SchemaPath('std', 'bool'),
                                        typexpr='std::bool',
                                        kind=PointerKind('Property'),
                                        cardinality=pydantic.Cardinality('AtMostOne'),
                                        computed=False,
                                        readonly=False,
                                        has_default=False,
                                        properties=None,
                                    ),
                                    'value': GelPointerReflection(
                                        name='value',
                                        type=SchemaPath('std', 'str'),
                                        typexpr='std::str',
                                        kind=PointerKind('Property'),
                                        cardinality=pydantic.Cardinality('AtMostOne'),
                                        computed=False,
                                        readonly=False,
                                        has_default=False,
                                        properties=None,
                                    ),
                                }
                                return my_ptrs


                        owned: OptionalProperty[std.bool, ___builtins_2__.bool]
                        is_owned: OptionalProperty[std.bool, ___builtins_2__.bool]
                        value: OptionalProperty[std.str, ___builtins_1__.str]
                    __linkprops__: __lprops__

                    def __init__(self, obj, /, **link_props) -> None:
                        ProxyModel.__init__(self, obj)
                        lprops = self.__class__.__lprops__(**link_props)
                        object.__setattr__(self, "__linkprops__", lprops)

                    @classmethod
                    def link(cls, obj, /, **link_props) -> Self:
                        return cls(obj, **link_props)

                AnnotationSubject__annotations.__name__ = 'annotations'
                AnnotationSubject__annotations.__qualname__ = 'AnnotationSubject.annotations'
                return AnnotationSubject__annotations
    class __links_partial__(Object.__links_partial__):
        if TYPE_CHECKING:
            class annotations(  # type: ignore [misc]
                schema.Annotation.__variants__.Partial,
                ProxyModel[schema.Annotation.__variants__.Partial],
            ):
                """link schema::AnnotationSubject.annotations: schema::Annotation"""
                class __lprops__(GelLinkModel):
                    class __gel_reflection__(GelLinkModel.__gel_reflection__):
                        id = UUID(int=171234699206056583856051977312110321700)
                        name = SchemaPath('annotations')
                        @LazyClassProperty["dict[str, GelPointerReflection]"]
                        @classmethod
                        def pointers(cls) -> dict[str, GelPointerReflection]:
                            my_ptrs: dict[str, GelPointerReflection] = {
                                'owned': GelPointerReflection(
                                    name='owned',
                                    type=SchemaPath('std', 'bool'),
                                    typexpr='std::bool',
                                    kind=PointerKind('Property'),
                                    cardinality=pydantic.Cardinality('AtMostOne'),
                                    computed=False,
                                    readonly=False,
                                    has_default=False,
                                    properties=None,
                                ),
                                'is_owned': GelPointerReflection(
                                    name='is_owned',
                                    type=SchemaPath('std', 'bool'),
                                    typexpr='std::bool',
                                    kind=PointerKind('Property'),
                                    cardinality=pydantic.Cardinality('AtMostOne'),
                                    computed=False,
                                    readonly=False,
                                    has_default=False,
                                    properties=None,
                                ),
                                'value': GelPointerReflection(
                                    name='value',
                                    type=SchemaPath('std', 'str'),
                                    typexpr='std::str',
                                    kind=PointerKind('Property'),
                                    cardinality=pydantic.Cardinality('AtMostOne'),
                                    computed=False,
                                    readonly=False,
                                    has_default=False,
                                    properties=None,
                                ),
                            }
                            return my_ptrs


                    owned: OptionalProperty[___std__.bool, ___builtins_2__.bool]
                    is_owned: OptionalProperty[___std__.bool, ___builtins_2__.bool]
                    value: OptionalProperty[___std__.str, ___builtins_1__.str]
                __linkprops__: __lprops__

                def __init__(
                    self,
                    obj: schema.Annotation.__variants__.Partial,
                    /,
                    *,
                    owned: ___builtins_2__.bool | None = None,
                    is_owned: ___builtins_2__.bool | None = None,
                    value: ___builtins_1__.str | None = None,
                ) -> None:
                    ...

                @classmethod
                def link(
                    cls,
                    obj: schema.Annotation.__variants__.Partial,
                    /,
                    *,
                    owned: ___builtins_2__.bool | None = None,
                    is_owned: ___builtins_2__.bool | None = None,
                    value: ___builtins_1__.str | None = None,
                ) -> Self:
                    ...

        if not TYPE_CHECKING:
            @LazyClassProperty[type]
            @classmethod
            def annotations(cls) -> type:
                class AnnotationSubject__annotations(  # type: ignore [misc]
                    ___schema__.Annotation.__variants__.Partial,
                    ProxyModel[___schema__.Annotation.__variants__.Partial],
                ):
                    """link schema::AnnotationSubject.annotations: schema::Annotation"""
                    class __lprops__(GelLinkModel):
                        class __gel_reflection__(
                            GelLinkModel.__gel_reflection__,
                        ):
                            id = UUID(int=171234699206056583856051977312110321700)
                            name = SchemaPath('annotations')
                            @LazyClassProperty["dict[str, GelPointerReflection]"]
                            @classmethod
                            def pointers(
                                cls,
                            ) -> dict[str, GelPointerReflection]:
                                my_ptrs: dict[str, GelPointerReflection] = {
                                    'owned': GelPointerReflection(
                                        name='owned',
                                        type=SchemaPath('std', 'bool'),
                                        typexpr='std::bool',
                                        kind=PointerKind('Property'),
                                        cardinality=pydantic.Cardinality('AtMostOne'),
                                        computed=False,
                                        readonly=False,
                                        has_default=False,
                                        properties=None,
                                    ),
                                    'is_owned': GelPointerReflection(
                                        name='is_owned',
                                        type=SchemaPath('std', 'bool'),
                                        typexpr='std::bool',
                                        kind=PointerKind('Property'),
                                        cardinality=pydantic.Cardinality('AtMostOne'),
                                        computed=False,
                                        readonly=False,
                                        has_default=False,
                                        properties=None,
                                    ),
                                    'value': GelPointerReflection(
                                        name='value',
                                        type=SchemaPath('std', 'str'),
                                        typexpr='std::str',
                                        kind=PointerKind('Property'),
                                        cardinality=pydantic.Cardinality('AtMostOne'),
                                        computed=False,
                                        readonly=False,
                                        has_default=False,
                                        properties=None,
                                    ),
                                }
                                return my_ptrs


                        owned: OptionalProperty[std.bool, ___builtins_2__.bool]
                        is_owned: OptionalProperty[std.bool, ___builtins_2__.bool]
                        value: OptionalProperty[std.str, ___builtins_1__.str]
                    __linkprops__: __lprops__

                    def __init__(self, obj, /, **link_props) -> None:
                        ProxyModel.__init__(self, obj)
                        lprops = self.__class__.__lprops__(**link_props)
                        object.__setattr__(self, "__linkprops__", lprops)

                    @classmethod
                    def link(cls, obj, /, **link_props) -> Self:
                        return cls(obj, **link_props)

                AnnotationSubject__annotations.__name__ = 'annotations'
                AnnotationSubject__annotations.__qualname__ = 'AnnotationSubject.annotations'
                return AnnotationSubject__annotations

if not TYPE_CHECKING:
    AnnotationSubject.__variants__.Base = AnnotationSubject



#
# type schema::Delta
#
class __Delta_typeof_base__(__Object_typeof_base__):
    class __gel_reflection__(__Object_typeof_base__.__gel_reflection__):
        id = UUID(int=267780996458575171504439478392129386302)
        name = SchemaPath('schema', 'Delta')
        @LazyClassProperty["dict[str, GelPointerReflection]"]
        @classmethod
        def pointers(cls) -> dict[str, GelPointerReflection]:
            my_ptrs: dict[str, GelPointerReflection] = {
                'parents': GelPointerReflection(
                    name='parents',
                    type=SchemaPath('schema', 'Delta'),
                    typexpr='schema::Delta',
                    kind=PointerKind('Link'),
                    cardinality=pydantic.Cardinality('Many'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
            }
            return (
                my_ptrs
                | __Object_typeof_base__.__gel_reflection__.pointers
            )

        @LazyClassProperty["schema.ObjectType"]
        @classmethod
        def object(cls) -> schema.ObjectType:
            from ... import schema as ___schema_1__
            return ___schema_1__.ObjectType(
                id=UUID(int=267780996458575171504439478392129386302),
                name='schema::Delta',
                builtin=True,
                internal=False,
                abstract=False,
                final=False,
                compound_type=False,
            )

class __Delta_typeof__(__Object_typeof__, __Delta_typeof_base__):
    class __typeof__(__Object_typeof__.__typeof__):
        parents = TypeAliasType('parents', 'MultiLink[Delta]')


class __Delta_typeof_partial__(
    __Object_typeof_partial__,
    __Delta_typeof_base__,
):
    class __typeof__(__Object_typeof_partial__.__typeof__):
        parents = TypeAliasType('parents', 'MultiLink[Delta | Delta.__variants__.Partial]')


class Delta(
    __Delta_typeof__,
    Object,
    __gel_type_id__=UUID(int=267780996458575171504439478392129386302),
):
    if TYPE_CHECKING:
        def __init__(
            self,
            /,
            *,
            id: UUID | DefaultValue = DEFAULT_VALUE,
            name: builtins.str,
            internal: bool | DefaultValue = DEFAULT_VALUE,
            builtin: bool | DefaultValue = DEFAULT_VALUE,
            computed_fields: list[builtins.str] | None = None,
            parents: Iterable[Delta] = [],
        ) -> None:
            """Create a new schema::Delta instance from keyword arguments.

            Call db.save() on the returned object to persist it in the database.
            """
            ...

    if TYPE_CHECKING:
        @classmethod
        def update(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            parents: type[schema.Delta] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Update schema::Delta instances in the database.
            """
            ...

        @classmethod
        def select(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: PathAlias | Literal["*"],
            id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            parents: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Delta] | UnspecifiedType = Unspecified,
            **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
        ) -> type[Self]:
            """Fetch schema::Delta instances from the database.
            """
            ...

        @classmethod
        def filter(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], type[___std__.bool]],
            id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            parents: type[schema.Delta] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Fetch schema::Delta instances from the database.
            """
            ...

        @classmethod
        def order_by(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
            id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Specify the sort order for the selection"""
            ...


    class __variants__(Object.__variants__):
        class Base(
            __Delta_typeof__,
            Object.__variants__.Base,
            __gel_variant__="Base",
        ):
            if TYPE_CHECKING:
                def __init__(
                    self,
                    /,
                    *,
                    id: UUID | DefaultValue = DEFAULT_VALUE,
                    name: builtins.str,
                    internal: bool | DefaultValue = DEFAULT_VALUE,
                    builtin: bool | DefaultValue = DEFAULT_VALUE,
                    computed_fields: list[builtins.str] | None = None,
                    parents: Iterable[Delta] = [],
                ) -> None:
                    """Create a new schema::Delta instance from keyword arguments.

                    Call db.save() on the returned object to persist it in the database.
                    """
                    ...

            if TYPE_CHECKING:
                @classmethod
                def update(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    parents: type[schema.Delta] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Update schema::Delta instances in the database.
                    """
                    ...

                @classmethod
                def select(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: PathAlias | Literal["*"],
                    id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    parents: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Delta] | UnspecifiedType = Unspecified,
                    **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
                ) -> type[Self]:
                    """Fetch schema::Delta instances from the database.
                    """
                    ...

                @classmethod
                def filter(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], type[___std__.bool]],
                    id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    parents: type[schema.Delta] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Fetch schema::Delta instances from the database.
                    """
                    ...

                @classmethod
                def order_by(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
                    id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Specify the sort order for the selection"""
                    ...

        class Required(
            Base,
            Object.__variants__.Required,
            __gel_variant__="Required",
        ):
            pass

        class PartialBase(  # type: ignore [misc, unused-ignore]
            __Delta_typeof_partial__,
            Base,
            Object.__variants__.PartialBase,
            __gel_variant__="PartialBase",
        ):
            pass

        class Partial(  # type: ignore [misc, unused-ignore]
            PartialBase,
            Object.__variants__.Partial,
            __gel_variant__="Partial",
        ):
            parents: MultiLink[___schema__.Delta | ___schema__.Delta.__variants__.Partial]


        Any = TypeVar("Any", bound="Delta | Base | Required | Partial")
    class __links__(Object.__links__):
        pass
    class __links_partial__(Object.__links_partial__):
        pass

if not TYPE_CHECKING:
    Delta.__variants__.Base = Delta



#
# type schema::FutureBehavior
#
class __FutureBehavior_typeof_base__(__Object_typeof_base__):
    class __gel_reflection__(__Object_typeof_base__.__gel_reflection__):
        id = UUID(int=331958463269391668024806361398877540)
        name = SchemaPath('schema', 'FutureBehavior')
        @LazyClassProperty["dict[str, ___pydantic_1__.GelPointerReflection]"]
        @classmethod
        def pointers(cls) -> dict[str, ___pydantic_1__.GelPointerReflection]:
            my_ptrs: dict[str, ___pydantic_1__.GelPointerReflection] = {}
            return (
                my_ptrs
                | __Object_typeof_base__.__gel_reflection__.pointers
            )

        @LazyClassProperty["schema.ObjectType"]
        @classmethod
        def object(cls) -> schema.ObjectType:
            from ... import schema as ___schema_1__
            return ___schema_1__.ObjectType(
                id=UUID(int=331958463269391668024806361398877540),
                name='schema::FutureBehavior',
                builtin=True,
                internal=False,
                abstract=False,
                final=False,
                compound_type=False,
            )

class __FutureBehavior_typeof__(
    __Object_typeof__,
    __FutureBehavior_typeof_base__,
):
    class __typeof__(__Object_typeof__.__typeof__):
        pass


class __FutureBehavior_typeof_partial__(
    __Object_typeof_partial__,
    __FutureBehavior_typeof_base__,
):
    class __typeof__(__Object_typeof_partial__.__typeof__):
        pass


class FutureBehavior(
    __FutureBehavior_typeof__,
    Object,
    __gel_type_id__=UUID(int=331958463269391668024806361398877540),
):
    if TYPE_CHECKING:
        def __init__(
            self,
            /,
            *,
            id: UUID | DefaultValue = DEFAULT_VALUE,
            name: builtins.str,
            internal: bool | DefaultValue = DEFAULT_VALUE,
            builtin: bool | DefaultValue = DEFAULT_VALUE,
            computed_fields: list[builtins.str] | None = None,
        ) -> None:
            """Create a new schema::FutureBehavior instance from keyword arguments.

            Call db.save() on the returned object to persist it in the database.
            """
            ...

    if TYPE_CHECKING:
        @classmethod
        def update(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Update schema::FutureBehavior instances in the database.
            """
            ...

        @classmethod
        def select(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: PathAlias | Literal["*"],
            id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
        ) -> type[Self]:
            """Fetch schema::FutureBehavior instances from the database.
            """
            ...

        @classmethod
        def filter(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], type[___std__.bool]],
            id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Fetch schema::FutureBehavior instances from the database.
            """
            ...

        @classmethod
        def order_by(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
            id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Specify the sort order for the selection"""
            ...


    class __variants__(Object.__variants__):
        class Base(
            __FutureBehavior_typeof__,
            Object.__variants__.Base,
            __gel_variant__="Base",
        ):
            if TYPE_CHECKING:
                def __init__(
                    self,
                    /,
                    *,
                    id: UUID | DefaultValue = DEFAULT_VALUE,
                    name: builtins.str,
                    internal: bool | DefaultValue = DEFAULT_VALUE,
                    builtin: bool | DefaultValue = DEFAULT_VALUE,
                    computed_fields: list[builtins.str] | None = None,
                ) -> None:
                    """Create a new schema::FutureBehavior instance from keyword arguments.

                    Call db.save() on the returned object to persist it in the database.
                    """
                    ...

            if TYPE_CHECKING:
                @classmethod
                def update(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Update schema::FutureBehavior instances in the database.
                    """
                    ...

                @classmethod
                def select(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: PathAlias | Literal["*"],
                    id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
                ) -> type[Self]:
                    """Fetch schema::FutureBehavior instances from the database.
                    """
                    ...

                @classmethod
                def filter(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], type[___std__.bool]],
                    id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Fetch schema::FutureBehavior instances from the database.
                    """
                    ...

                @classmethod
                def order_by(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
                    id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Specify the sort order for the selection"""
                    ...

        class Required(
            Base,
            Object.__variants__.Required,
            __gel_variant__="Required",
        ):
            pass

        class PartialBase(  # type: ignore [misc, unused-ignore]
            __FutureBehavior_typeof_partial__,
            Base,
            Object.__variants__.PartialBase,
            __gel_variant__="PartialBase",
        ):
            pass

        class Partial(  # type: ignore [misc, unused-ignore]
            PartialBase,
            Object.__variants__.Partial,
            __gel_variant__="Partial",
        ):
            pass


        Any = TypeVar("Any", bound="FutureBehavior | Base | Required | Partial")
    class __links__(Object.__links__):
        pass
    class __links_partial__(Object.__links_partial__):
        pass

if not TYPE_CHECKING:
    FutureBehavior.__variants__.Base = FutureBehavior



#
# type schema::Parameter
#
class __Parameter_typeof_base__(__Object_typeof_base__):
    class __gel_reflection__(__Object_typeof_base__.__gel_reflection__):
        id = UUID(int=180732607306417598723908042903228099108)
        name = SchemaPath('schema', 'Parameter')
        @LazyClassProperty["dict[str, GelPointerReflection]"]
        @classmethod
        def pointers(cls) -> dict[str, GelPointerReflection]:
            my_ptrs: dict[str, GelPointerReflection] = {
                'typemod': GelPointerReflection(
                    name='typemod',
                    type=SchemaPath('schema', 'TypeModifier'),
                    typexpr='schema::TypeModifier',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('One'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
                'kind': GelPointerReflection(
                    name='kind',
                    type=SchemaPath('schema', 'ParameterKind'),
                    typexpr='schema::ParameterKind',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('One'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
                'num': GelPointerReflection(
                    name='num',
                    type=SchemaPath('std', 'int64'),
                    typexpr='std::int64',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('One'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
                'default': GelPointerReflection(
                    name='default',
                    type=SchemaPath('std', 'str'),
                    typexpr='std::str',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
                'type': GelPointerReflection(
                    name='type',
                    type=SchemaPath('schema', 'Type'),
                    typexpr='schema::Type',
                    kind=PointerKind('Link'),
                    cardinality=pydantic.Cardinality('One'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
            }
            return (
                my_ptrs
                | __Object_typeof_base__.__gel_reflection__.pointers
            )

        @LazyClassProperty["schema.ObjectType"]
        @classmethod
        def object(cls) -> schema.ObjectType:
            from ... import schema as ___schema_1__
            return ___schema_1__.ObjectType(
                id=UUID(int=180732607306417598723908042903228099108),
                name='schema::Parameter',
                builtin=True,
                internal=False,
                abstract=False,
                final=False,
                compound_type=False,
            )

class __Parameter_typeof__(__Object_typeof__, __Parameter_typeof_base__):
    class __typeof__(__Object_typeof__.__typeof__):
        typemod = TypeAliasType('typemod', 'TypeModifier')
        kind = TypeAliasType('kind', 'ParameterKind')
        num = TypeAliasType('num', 'std.int64')
        default = TypeAliasType('default', 'OptionalProperty[std.str, builtins.str]')
        type = TypeAliasType('type', 'Type')


class __Parameter_typeof_partial__(
    __Object_typeof_partial__,
    __Parameter_typeof_base__,
):
    class __typeof__(__Object_typeof_partial__.__typeof__):
        typemod = TypeAliasType('typemod', 'OptionalProperty[TypeModifier, ___builtins_1__.str]')
        kind = TypeAliasType('kind', 'OptionalProperty[ParameterKind, ___builtins_1__.str]')
        num = TypeAliasType('num', 'OptionalProperty[std.int64, int]')
        default = TypeAliasType('default', 'OptionalProperty[std.str, builtins.str]')
        type = TypeAliasType('type', 'Type | Type.__variants__.Partial')


class Parameter(
    __Parameter_typeof__,
    Object,
    __gel_type_id__=UUID(int=180732607306417598723908042903228099108),
):
    if TYPE_CHECKING:
        def __init__(
            self,
            /,
            *,
            id: UUID | DefaultValue = DEFAULT_VALUE,
            name: builtins.str,
            internal: bool | DefaultValue = DEFAULT_VALUE,
            builtin: bool | DefaultValue = DEFAULT_VALUE,
            computed_fields: list[builtins.str] | None = None,
            typemod: ___builtins_1__.str,
            kind: ___builtins_1__.str,
            num: int,
            default: builtins.str | None = None,
            type: Type | None = None,
        ) -> None:
            """Create a new schema::Parameter instance from keyword arguments.

            Call db.save() on the returned object to persist it in the database.
            """
            ...

    if TYPE_CHECKING:
        @classmethod
        def update(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            typemod: type[TypeModifier] | UnspecifiedType = Unspecified,
            kind: type[ParameterKind] | UnspecifiedType = Unspecified,
            num: ___builtins_3__.int | type[___std__.int64] | UnspecifiedType = Unspecified,
            default: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            type: type[schema.Type] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Update schema::Parameter instances in the database.
            """
            ...

        @classmethod
        def select(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: PathAlias | Literal["*"],
            id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            typemod: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[TypeModifier] | UnspecifiedType = Unspecified,
            kind: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[ParameterKind] | UnspecifiedType = Unspecified,
            num: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.int64] | UnspecifiedType = Unspecified,
            default: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            type: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Type] | UnspecifiedType = Unspecified,
            **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
        ) -> type[Self]:
            """Fetch schema::Parameter instances from the database.
            """
            ...

        @classmethod
        def filter(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], type[___std__.bool]],
            id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            typemod: type[TypeModifier] | UnspecifiedType = Unspecified,
            kind: type[ParameterKind] | UnspecifiedType = Unspecified,
            num: ___builtins_3__.int | type[___std__.int64] | UnspecifiedType = Unspecified,
            default: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            type: type[schema.Type] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Fetch schema::Parameter instances from the database.
            """
            ...

        @classmethod
        def order_by(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
            id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            num: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            default: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Specify the sort order for the selection"""
            ...


    class __variants__(Object.__variants__):
        class Base(
            __Parameter_typeof__,
            Object.__variants__.Base,
            __gel_variant__="Base",
        ):
            if TYPE_CHECKING:
                def __init__(
                    self,
                    /,
                    *,
                    id: UUID | DefaultValue = DEFAULT_VALUE,
                    name: builtins.str,
                    internal: bool | DefaultValue = DEFAULT_VALUE,
                    builtin: bool | DefaultValue = DEFAULT_VALUE,
                    computed_fields: list[builtins.str] | None = None,
                    typemod: ___builtins_1__.str,
                    kind: ___builtins_1__.str,
                    num: int,
                    default: builtins.str | None = None,
                    type: Type | None = None,
                ) -> None:
                    """Create a new schema::Parameter instance from keyword arguments.

                    Call db.save() on the returned object to persist it in the database.
                    """
                    ...

            if TYPE_CHECKING:
                @classmethod
                def update(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    typemod: type[TypeModifier] | UnspecifiedType = Unspecified,
                    kind: type[ParameterKind] | UnspecifiedType = Unspecified,
                    num: ___builtins_3__.int | type[___std__.int64] | UnspecifiedType = Unspecified,
                    default: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    type: type[schema.Type] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Update schema::Parameter instances in the database.
                    """
                    ...

                @classmethod
                def select(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: PathAlias | Literal["*"],
                    id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    typemod: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[TypeModifier] | UnspecifiedType = Unspecified,
                    kind: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[ParameterKind] | UnspecifiedType = Unspecified,
                    num: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.int64] | UnspecifiedType = Unspecified,
                    default: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    type: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Type] | UnspecifiedType = Unspecified,
                    **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
                ) -> type[Self]:
                    """Fetch schema::Parameter instances from the database.
                    """
                    ...

                @classmethod
                def filter(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], type[___std__.bool]],
                    id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    typemod: type[TypeModifier] | UnspecifiedType = Unspecified,
                    kind: type[ParameterKind] | UnspecifiedType = Unspecified,
                    num: ___builtins_3__.int | type[___std__.int64] | UnspecifiedType = Unspecified,
                    default: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    type: type[schema.Type] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Fetch schema::Parameter instances from the database.
                    """
                    ...

                @classmethod
                def order_by(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
                    id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    num: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    default: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Specify the sort order for the selection"""
                    ...

        class Required(
            Base,
            Object.__variants__.Required,
            __gel_variant__="Required",
        ):
            typemod: TypeModifier
            kind: ParameterKind
            num: std.int64
            type: ___schema__.Type

        class PartialBase(  # type: ignore [misc, unused-ignore]
            __Parameter_typeof_partial__,
            Base,
            Object.__variants__.PartialBase,
            __gel_variant__="PartialBase",
        ):
            pass

        class Partial(  # type: ignore [misc, unused-ignore]
            PartialBase,
            Object.__variants__.Partial,
            __gel_variant__="Partial",
        ):
            typemod: OptionalProperty[TypeModifier, ___builtins_1__.str]
            kind: OptionalProperty[ParameterKind, ___builtins_1__.str]
            num: OptionalProperty[std.int64, int]
            default: OptionalProperty[std.str, builtins.str]
            type: ___schema__.Type | ___schema__.Type.__variants__.Partial


        Any = TypeVar("Any", bound="Parameter | Base | Required | Partial")
    class __links__(Object.__links__):
        pass
    class __links_partial__(Object.__links_partial__):
        pass

if not TYPE_CHECKING:
    Parameter.__variants__.Base = Parameter



#
# type schema::Source
#
class __Source_typeof_base__(__Object_typeof_base__):
    class __gel_reflection__(__Object_typeof_base__.__gel_reflection__):
        id = UUID(int=4531483172543608627442440371551189032)
        name = SchemaPath('schema', 'Source')
        @LazyClassProperty["dict[str, GelPointerReflection]"]
        @classmethod
        def pointers(cls) -> dict[str, GelPointerReflection]:
            my_ptrs: dict[str, GelPointerReflection] = {
                'pointers': GelPointerReflection(
                    name='pointers',
                    type=SchemaPath('schema', 'Pointer'),
                    typexpr='schema::Pointer',
                    kind=PointerKind('Link'),
                    cardinality=pydantic.Cardinality('Many'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={
                    'owned': GelPointerReflection(
                    name='owned',
                    type=SchemaPath('std', 'bool'),
                    typexpr='std::bool',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties=None,
                ),
                    'is_owned': GelPointerReflection(
                    name='is_owned',
                    type=SchemaPath('std', 'bool'),
                    typexpr='std::bool',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties=None,
                ),
                },
                ),
                'indexes': GelPointerReflection(
                    name='indexes',
                    type=SchemaPath('schema', 'Index'),
                    typexpr='schema::Index',
                    kind=PointerKind('Link'),
                    cardinality=pydantic.Cardinality('Many'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={
                    'owned': GelPointerReflection(
                    name='owned',
                    type=SchemaPath('std', 'bool'),
                    typexpr='std::bool',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties=None,
                ),
                    'is_owned': GelPointerReflection(
                    name='is_owned',
                    type=SchemaPath('std', 'bool'),
                    typexpr='std::bool',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties=None,
                ),
                },
                ),
            }
            return (
                my_ptrs
                | __Object_typeof_base__.__gel_reflection__.pointers
            )

        @LazyClassProperty["schema.ObjectType"]
        @classmethod
        def object(cls) -> schema.ObjectType:
            from ... import schema as ___schema_1__
            return ___schema_1__.ObjectType(
                id=UUID(int=4531483172543608627442440371551189032),
                name='schema::Source',
                builtin=True,
                internal=False,
                abstract=True,
                final=False,
                compound_type=False,
            )

class __Source_typeof__(__Object_typeof__, __Source_typeof_base__):
    class __typeof__(__Object_typeof__.__typeof__):
        pointers = TypeAliasType('pointers', 'MultiLinkWithProps[Source.__links__.pointers, Pointer]')
        indexes = TypeAliasType('indexes', 'MultiLinkWithProps[Source.__links__.indexes, Index]')


class __Source_typeof_partial__(
    __Object_typeof_partial__,
    __Source_typeof_base__,
):
    class __typeof__(__Object_typeof_partial__.__typeof__):
        pointers = TypeAliasType('pointers', 'MultiLinkWithProps[Source.__links__.pointers | Source.__links_partial__.pointers, Pointer]')
        indexes = TypeAliasType('indexes', 'MultiLinkWithProps[Source.__links__.indexes | Source.__links_partial__.indexes, Index]')


class Source(
    __Source_typeof__,
    Object,
    __gel_type_id__=UUID(int=4531483172543608627442440371551189032),
):
    if TYPE_CHECKING:
        def __init__(
            self,
            /,
            *,
            id: UUID | DefaultValue = DEFAULT_VALUE,
            name: builtins.str,
            internal: bool | DefaultValue = DEFAULT_VALUE,
            builtin: bool | DefaultValue = DEFAULT_VALUE,
            computed_fields: list[builtins.str] | None = None,
            abstract: bool | None | DefaultValue = DEFAULT_VALUE,
            final: bool,
            inherited_fields: list[builtins.str] | None = None,
            bases: Iterable[InheritingObject] = [],
            ancestors: Iterable[InheritingObject] = [],
            pointers: Iterable[Pointer] = [],
            indexes: Iterable[Index] = [],
        ) -> None:
            """Create a new schema::Source instance from keyword arguments.

            Call db.save() on the returned object to persist it in the database.
            """
            ...

    if TYPE_CHECKING:
        @classmethod
        def update(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            inherited_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            bases: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            ancestors: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            pointers: type[schema.Pointer] | UnspecifiedType = Unspecified,
            indexes: type[schema.Index] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Update schema::Source instances in the database.
            """
            ...

        @classmethod
        def select(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: PathAlias | Literal["*"],
            id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            abstract: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            final: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            inherited_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            bases: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            ancestors: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            pointers: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Pointer] | UnspecifiedType = Unspecified,
            indexes: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Index] | UnspecifiedType = Unspecified,
            **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
        ) -> type[Self]:
            """Fetch schema::Source instances from the database.
            """
            ...

        @classmethod
        def filter(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], type[___std__.bool]],
            id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            final: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            inherited_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            bases: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            ancestors: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            pointers: type[schema.Pointer] | UnspecifiedType = Unspecified,
            indexes: type[schema.Index] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Fetch schema::Source instances from the database.
            """
            ...

        @classmethod
        def order_by(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
            id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            abstract: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            final: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Specify the sort order for the selection"""
            ...


    class __variants__(Object.__variants__):
        class Base(
            __Source_typeof__,
            Object.__variants__.Base,
            __gel_variant__="Base",
        ):
            if TYPE_CHECKING:
                def __init__(
                    self,
                    /,
                    *,
                    id: UUID | DefaultValue = DEFAULT_VALUE,
                    name: builtins.str,
                    internal: bool | DefaultValue = DEFAULT_VALUE,
                    builtin: bool | DefaultValue = DEFAULT_VALUE,
                    computed_fields: list[builtins.str] | None = None,
                    abstract: bool | None | DefaultValue = DEFAULT_VALUE,
                    final: bool,
                    inherited_fields: list[builtins.str] | None = None,
                    bases: Iterable[InheritingObject] = [],
                    ancestors: Iterable[InheritingObject] = [],
                    pointers: Iterable[Pointer] = [],
                    indexes: Iterable[Index] = [],
                ) -> None:
                    """Create a new schema::Source instance from keyword arguments.

                    Call db.save() on the returned object to persist it in the database.
                    """
                    ...

            if TYPE_CHECKING:
                @classmethod
                def update(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    inherited_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    bases: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    ancestors: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    pointers: type[schema.Pointer] | UnspecifiedType = Unspecified,
                    indexes: type[schema.Index] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Update schema::Source instances in the database.
                    """
                    ...

                @classmethod
                def select(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: PathAlias | Literal["*"],
                    id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    abstract: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    final: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    inherited_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    bases: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    ancestors: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    pointers: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Pointer] | UnspecifiedType = Unspecified,
                    indexes: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Index] | UnspecifiedType = Unspecified,
                    **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
                ) -> type[Self]:
                    """Fetch schema::Source instances from the database.
                    """
                    ...

                @classmethod
                def filter(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], type[___std__.bool]],
                    id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    final: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    inherited_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    bases: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    ancestors: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    pointers: type[schema.Pointer] | UnspecifiedType = Unspecified,
                    indexes: type[schema.Index] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Fetch schema::Source instances from the database.
                    """
                    ...

                @classmethod
                def order_by(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
                    id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    abstract: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    final: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Specify the sort order for the selection"""
                    ...

        class Required(
            Base,
            Object.__variants__.Required,
            __gel_variant__="Required",
        ):
            pass

        class PartialBase(  # type: ignore [misc, unused-ignore]
            __Source_typeof_partial__,
            Base,
            Object.__variants__.PartialBase,
            __gel_variant__="PartialBase",
        ):
            pass

        class Partial(  # type: ignore [misc, unused-ignore]
            PartialBase,
            Object.__variants__.Partial,
            __gel_variant__="Partial",
        ):
            pointers: MultiLinkWithProps[Source.__links__.pointers | Source.__links_partial__.pointers, ___schema__.Pointer]
            indexes: MultiLinkWithProps[Source.__links__.indexes | Source.__links_partial__.indexes, ___schema__.Index]


        Any = TypeVar("Any", bound="Source | Base | Required | Partial")
    class __links__(Object.__links__):
        if TYPE_CHECKING:
            class pointers(schema.Pointer, ProxyModel[schema.Pointer]):
                """link schema::Source.pointers: schema::Pointer"""
                class __lprops__(GelLinkModel):
                    class __gel_reflection__(GelLinkModel.__gel_reflection__):
                        id = UUID(int=192282780854714557984334949677843420682)
                        name = SchemaPath('pointers')
                        @LazyClassProperty["dict[str, GelPointerReflection]"]
                        @classmethod
                        def pointers(cls) -> dict[str, GelPointerReflection]:
                            my_ptrs: dict[str, GelPointerReflection] = {
                                'owned': GelPointerReflection(
                                    name='owned',
                                    type=SchemaPath('std', 'bool'),
                                    typexpr='std::bool',
                                    kind=PointerKind('Property'),
                                    cardinality=pydantic.Cardinality('AtMostOne'),
                                    computed=False,
                                    readonly=False,
                                    has_default=False,
                                    properties=None,
                                ),
                                'is_owned': GelPointerReflection(
                                    name='is_owned',
                                    type=SchemaPath('std', 'bool'),
                                    typexpr='std::bool',
                                    kind=PointerKind('Property'),
                                    cardinality=pydantic.Cardinality('AtMostOne'),
                                    computed=False,
                                    readonly=False,
                                    has_default=False,
                                    properties=None,
                                ),
                            }
                            return my_ptrs


                    owned: OptionalProperty[___std__.bool, ___builtins_2__.bool]
                    is_owned: OptionalProperty[___std__.bool, ___builtins_2__.bool]
                __linkprops__: __lprops__

                def __init__(
                    self,
                    obj: schema.Pointer,
                    /,
                    *,
                    owned: ___builtins_2__.bool | None = None,
                    is_owned: ___builtins_2__.bool | None = None,
                ) -> None:
                    ...

                @classmethod
                def link(
                    cls,
                    obj: schema.Pointer,
                    /,
                    *,
                    owned: ___builtins_2__.bool | None = None,
                    is_owned: ___builtins_2__.bool | None = None,
                ) -> Self:
                    ...

            class indexes(schema.Index, ProxyModel[schema.Index]):
                """link schema::Source.indexes: schema::Index"""
                class __lprops__(GelLinkModel):
                    class __gel_reflection__(GelLinkModel.__gel_reflection__):
                        id = UUID(int=18964432069257073187136962485083888641)
                        name = SchemaPath('indexes')
                        @LazyClassProperty["dict[str, GelPointerReflection]"]
                        @classmethod
                        def pointers(cls) -> dict[str, GelPointerReflection]:
                            my_ptrs: dict[str, GelPointerReflection] = {
                                'owned': GelPointerReflection(
                                    name='owned',
                                    type=SchemaPath('std', 'bool'),
                                    typexpr='std::bool',
                                    kind=PointerKind('Property'),
                                    cardinality=pydantic.Cardinality('AtMostOne'),
                                    computed=False,
                                    readonly=False,
                                    has_default=False,
                                    properties=None,
                                ),
                                'is_owned': GelPointerReflection(
                                    name='is_owned',
                                    type=SchemaPath('std', 'bool'),
                                    typexpr='std::bool',
                                    kind=PointerKind('Property'),
                                    cardinality=pydantic.Cardinality('AtMostOne'),
                                    computed=False,
                                    readonly=False,
                                    has_default=False,
                                    properties=None,
                                ),
                            }
                            return my_ptrs


                    owned: OptionalProperty[___std__.bool, ___builtins_2__.bool]
                    is_owned: OptionalProperty[___std__.bool, ___builtins_2__.bool]
                __linkprops__: __lprops__

                def __init__(
                    self,
                    obj: schema.Index,
                    /,
                    *,
                    owned: ___builtins_2__.bool | None = None,
                    is_owned: ___builtins_2__.bool | None = None,
                ) -> None:
                    ...

                @classmethod
                def link(
                    cls,
                    obj: schema.Index,
                    /,
                    *,
                    owned: ___builtins_2__.bool | None = None,
                    is_owned: ___builtins_2__.bool | None = None,
                ) -> Self:
                    ...

        if not TYPE_CHECKING:
            @LazyClassProperty[type]
            @classmethod
            def pointers(cls) -> type:
                class Source__pointers(
                    ___schema__.Pointer,
                    ProxyModel[___schema__.Pointer],
                ):
                    """link schema::Source.pointers: schema::Pointer"""
                    class __lprops__(GelLinkModel):
                        class __gel_reflection__(
                            GelLinkModel.__gel_reflection__,
                        ):
                            id = UUID(int=192282780854714557984334949677843420682)
                            name = SchemaPath('pointers')
                            @LazyClassProperty["dict[str, GelPointerReflection]"]
                            @classmethod
                            def pointers(
                                cls,
                            ) -> dict[str, GelPointerReflection]:
                                my_ptrs: dict[str, GelPointerReflection] = {
                                    'owned': GelPointerReflection(
                                        name='owned',
                                        type=SchemaPath('std', 'bool'),
                                        typexpr='std::bool',
                                        kind=PointerKind('Property'),
                                        cardinality=pydantic.Cardinality('AtMostOne'),
                                        computed=False,
                                        readonly=False,
                                        has_default=False,
                                        properties=None,
                                    ),
                                    'is_owned': GelPointerReflection(
                                        name='is_owned',
                                        type=SchemaPath('std', 'bool'),
                                        typexpr='std::bool',
                                        kind=PointerKind('Property'),
                                        cardinality=pydantic.Cardinality('AtMostOne'),
                                        computed=False,
                                        readonly=False,
                                        has_default=False,
                                        properties=None,
                                    ),
                                }
                                return my_ptrs


                        owned: OptionalProperty[std.bool, ___builtins_2__.bool]
                        is_owned: OptionalProperty[std.bool, ___builtins_2__.bool]
                    __linkprops__: __lprops__

                    def __init__(self, obj, /, **link_props) -> None:
                        ProxyModel.__init__(self, obj)
                        lprops = self.__class__.__lprops__(**link_props)
                        object.__setattr__(self, "__linkprops__", lprops)

                    @classmethod
                    def link(cls, obj, /, **link_props) -> Self:
                        return cls(obj, **link_props)

                Source__pointers.__name__ = 'pointers'
                Source__pointers.__qualname__ = 'Source.pointers'
                return Source__pointers
            @LazyClassProperty[type]
            @classmethod
            def indexes(cls) -> type:
                class Source__indexes(
                    ___schema__.Index,
                    ProxyModel[___schema__.Index],
                ):
                    """link schema::Source.indexes: schema::Index"""
                    class __lprops__(GelLinkModel):
                        class __gel_reflection__(
                            GelLinkModel.__gel_reflection__,
                        ):
                            id = UUID(int=18964432069257073187136962485083888641)
                            name = SchemaPath('indexes')
                            @LazyClassProperty["dict[str, GelPointerReflection]"]
                            @classmethod
                            def pointers(
                                cls,
                            ) -> dict[str, GelPointerReflection]:
                                my_ptrs: dict[str, GelPointerReflection] = {
                                    'owned': GelPointerReflection(
                                        name='owned',
                                        type=SchemaPath('std', 'bool'),
                                        typexpr='std::bool',
                                        kind=PointerKind('Property'),
                                        cardinality=pydantic.Cardinality('AtMostOne'),
                                        computed=False,
                                        readonly=False,
                                        has_default=False,
                                        properties=None,
                                    ),
                                    'is_owned': GelPointerReflection(
                                        name='is_owned',
                                        type=SchemaPath('std', 'bool'),
                                        typexpr='std::bool',
                                        kind=PointerKind('Property'),
                                        cardinality=pydantic.Cardinality('AtMostOne'),
                                        computed=False,
                                        readonly=False,
                                        has_default=False,
                                        properties=None,
                                    ),
                                }
                                return my_ptrs


                        owned: OptionalProperty[std.bool, ___builtins_2__.bool]
                        is_owned: OptionalProperty[std.bool, ___builtins_2__.bool]
                    __linkprops__: __lprops__

                    def __init__(self, obj, /, **link_props) -> None:
                        ProxyModel.__init__(self, obj)
                        lprops = self.__class__.__lprops__(**link_props)
                        object.__setattr__(self, "__linkprops__", lprops)

                    @classmethod
                    def link(cls, obj, /, **link_props) -> Self:
                        return cls(obj, **link_props)

                Source__indexes.__name__ = 'indexes'
                Source__indexes.__qualname__ = 'Source.indexes'
                return Source__indexes
    class __links_partial__(Object.__links_partial__):
        if TYPE_CHECKING:
            class pointers(  # type: ignore [misc]
                schema.Pointer.__variants__.Partial,
                ProxyModel[schema.Pointer.__variants__.Partial],
            ):
                """link schema::Source.pointers: schema::Pointer"""
                class __lprops__(GelLinkModel):
                    class __gel_reflection__(GelLinkModel.__gel_reflection__):
                        id = UUID(int=192282780854714557984334949677843420682)
                        name = SchemaPath('pointers')
                        @LazyClassProperty["dict[str, GelPointerReflection]"]
                        @classmethod
                        def pointers(cls) -> dict[str, GelPointerReflection]:
                            my_ptrs: dict[str, GelPointerReflection] = {
                                'owned': GelPointerReflection(
                                    name='owned',
                                    type=SchemaPath('std', 'bool'),
                                    typexpr='std::bool',
                                    kind=PointerKind('Property'),
                                    cardinality=pydantic.Cardinality('AtMostOne'),
                                    computed=False,
                                    readonly=False,
                                    has_default=False,
                                    properties=None,
                                ),
                                'is_owned': GelPointerReflection(
                                    name='is_owned',
                                    type=SchemaPath('std', 'bool'),
                                    typexpr='std::bool',
                                    kind=PointerKind('Property'),
                                    cardinality=pydantic.Cardinality('AtMostOne'),
                                    computed=False,
                                    readonly=False,
                                    has_default=False,
                                    properties=None,
                                ),
                            }
                            return my_ptrs


                    owned: OptionalProperty[___std__.bool, ___builtins_2__.bool]
                    is_owned: OptionalProperty[___std__.bool, ___builtins_2__.bool]
                __linkprops__: __lprops__

                def __init__(
                    self,
                    obj: schema.Pointer.__variants__.Partial,
                    /,
                    *,
                    owned: ___builtins_2__.bool | None = None,
                    is_owned: ___builtins_2__.bool | None = None,
                ) -> None:
                    ...

                @classmethod
                def link(
                    cls,
                    obj: schema.Pointer.__variants__.Partial,
                    /,
                    *,
                    owned: ___builtins_2__.bool | None = None,
                    is_owned: ___builtins_2__.bool | None = None,
                ) -> Self:
                    ...

            class indexes(  # type: ignore [misc]
                schema.Index.__variants__.Partial,
                ProxyModel[schema.Index.__variants__.Partial],
            ):
                """link schema::Source.indexes: schema::Index"""
                class __lprops__(GelLinkModel):
                    class __gel_reflection__(GelLinkModel.__gel_reflection__):
                        id = UUID(int=18964432069257073187136962485083888641)
                        name = SchemaPath('indexes')
                        @LazyClassProperty["dict[str, GelPointerReflection]"]
                        @classmethod
                        def pointers(cls) -> dict[str, GelPointerReflection]:
                            my_ptrs: dict[str, GelPointerReflection] = {
                                'owned': GelPointerReflection(
                                    name='owned',
                                    type=SchemaPath('std', 'bool'),
                                    typexpr='std::bool',
                                    kind=PointerKind('Property'),
                                    cardinality=pydantic.Cardinality('AtMostOne'),
                                    computed=False,
                                    readonly=False,
                                    has_default=False,
                                    properties=None,
                                ),
                                'is_owned': GelPointerReflection(
                                    name='is_owned',
                                    type=SchemaPath('std', 'bool'),
                                    typexpr='std::bool',
                                    kind=PointerKind('Property'),
                                    cardinality=pydantic.Cardinality('AtMostOne'),
                                    computed=False,
                                    readonly=False,
                                    has_default=False,
                                    properties=None,
                                ),
                            }
                            return my_ptrs


                    owned: OptionalProperty[___std__.bool, ___builtins_2__.bool]
                    is_owned: OptionalProperty[___std__.bool, ___builtins_2__.bool]
                __linkprops__: __lprops__

                def __init__(
                    self,
                    obj: schema.Index.__variants__.Partial,
                    /,
                    *,
                    owned: ___builtins_2__.bool | None = None,
                    is_owned: ___builtins_2__.bool | None = None,
                ) -> None:
                    ...

                @classmethod
                def link(
                    cls,
                    obj: schema.Index.__variants__.Partial,
                    /,
                    *,
                    owned: ___builtins_2__.bool | None = None,
                    is_owned: ___builtins_2__.bool | None = None,
                ) -> Self:
                    ...

        if not TYPE_CHECKING:
            @LazyClassProperty[type]
            @classmethod
            def pointers(cls) -> type:
                class Source__pointers(  # type: ignore [misc]
                    ___schema__.Pointer.__variants__.Partial,
                    ProxyModel[___schema__.Pointer.__variants__.Partial],
                ):
                    """link schema::Source.pointers: schema::Pointer"""
                    class __lprops__(GelLinkModel):
                        class __gel_reflection__(
                            GelLinkModel.__gel_reflection__,
                        ):
                            id = UUID(int=192282780854714557984334949677843420682)
                            name = SchemaPath('pointers')
                            @LazyClassProperty["dict[str, GelPointerReflection]"]
                            @classmethod
                            def pointers(
                                cls,
                            ) -> dict[str, GelPointerReflection]:
                                my_ptrs: dict[str, GelPointerReflection] = {
                                    'owned': GelPointerReflection(
                                        name='owned',
                                        type=SchemaPath('std', 'bool'),
                                        typexpr='std::bool',
                                        kind=PointerKind('Property'),
                                        cardinality=pydantic.Cardinality('AtMostOne'),
                                        computed=False,
                                        readonly=False,
                                        has_default=False,
                                        properties=None,
                                    ),
                                    'is_owned': GelPointerReflection(
                                        name='is_owned',
                                        type=SchemaPath('std', 'bool'),
                                        typexpr='std::bool',
                                        kind=PointerKind('Property'),
                                        cardinality=pydantic.Cardinality('AtMostOne'),
                                        computed=False,
                                        readonly=False,
                                        has_default=False,
                                        properties=None,
                                    ),
                                }
                                return my_ptrs


                        owned: OptionalProperty[std.bool, ___builtins_2__.bool]
                        is_owned: OptionalProperty[std.bool, ___builtins_2__.bool]
                    __linkprops__: __lprops__

                    def __init__(self, obj, /, **link_props) -> None:
                        ProxyModel.__init__(self, obj)
                        lprops = self.__class__.__lprops__(**link_props)
                        object.__setattr__(self, "__linkprops__", lprops)

                    @classmethod
                    def link(cls, obj, /, **link_props) -> Self:
                        return cls(obj, **link_props)

                Source__pointers.__name__ = 'pointers'
                Source__pointers.__qualname__ = 'Source.pointers'
                return Source__pointers
            @LazyClassProperty[type]
            @classmethod
            def indexes(cls) -> type:
                class Source__indexes(  # type: ignore [misc]
                    ___schema__.Index.__variants__.Partial,
                    ProxyModel[___schema__.Index.__variants__.Partial],
                ):
                    """link schema::Source.indexes: schema::Index"""
                    class __lprops__(GelLinkModel):
                        class __gel_reflection__(
                            GelLinkModel.__gel_reflection__,
                        ):
                            id = UUID(int=18964432069257073187136962485083888641)
                            name = SchemaPath('indexes')
                            @LazyClassProperty["dict[str, GelPointerReflection]"]
                            @classmethod
                            def pointers(
                                cls,
                            ) -> dict[str, GelPointerReflection]:
                                my_ptrs: dict[str, GelPointerReflection] = {
                                    'owned': GelPointerReflection(
                                        name='owned',
                                        type=SchemaPath('std', 'bool'),
                                        typexpr='std::bool',
                                        kind=PointerKind('Property'),
                                        cardinality=pydantic.Cardinality('AtMostOne'),
                                        computed=False,
                                        readonly=False,
                                        has_default=False,
                                        properties=None,
                                    ),
                                    'is_owned': GelPointerReflection(
                                        name='is_owned',
                                        type=SchemaPath('std', 'bool'),
                                        typexpr='std::bool',
                                        kind=PointerKind('Property'),
                                        cardinality=pydantic.Cardinality('AtMostOne'),
                                        computed=False,
                                        readonly=False,
                                        has_default=False,
                                        properties=None,
                                    ),
                                }
                                return my_ptrs


                        owned: OptionalProperty[std.bool, ___builtins_2__.bool]
                        is_owned: OptionalProperty[std.bool, ___builtins_2__.bool]
                    __linkprops__: __lprops__

                    def __init__(self, obj, /, **link_props) -> None:
                        ProxyModel.__init__(self, obj)
                        lprops = self.__class__.__lprops__(**link_props)
                        object.__setattr__(self, "__linkprops__", lprops)

                    @classmethod
                    def link(cls, obj, /, **link_props) -> Self:
                        return cls(obj, **link_props)

                Source__indexes.__name__ = 'indexes'
                Source__indexes.__qualname__ = 'Source.indexes'
                return Source__indexes

if not TYPE_CHECKING:
    Source.__variants__.Base = Source



#
# type schema::SubclassableObject
#
class __SubclassableObject_typeof_base__(__Object_typeof_base__):
    class __gel_reflection__(__Object_typeof_base__.__gel_reflection__):
        id = UUID(int=27059562504987325367836323013285651930)
        name = SchemaPath('schema', 'SubclassableObject')
        @LazyClassProperty["dict[str, GelPointerReflection]"]
        @classmethod
        def pointers(cls) -> dict[str, GelPointerReflection]:
            my_ptrs: dict[str, GelPointerReflection] = {
                'abstract': GelPointerReflection(
                    name='abstract',
                    type=SchemaPath('std', 'bool'),
                    typexpr='std::bool',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=True,
                    properties={},
                ),
                'is_abstract': GelPointerReflection(
                    name='is_abstract',
                    type=SchemaPath('std', 'bool'),
                    typexpr='std::bool',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=True,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
                'final': GelPointerReflection(
                    name='final',
                    type=SchemaPath('std', 'bool'),
                    typexpr='std::bool',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('One'),
                    computed=True,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
                'is_final': GelPointerReflection(
                    name='is_final',
                    type=SchemaPath('std', 'bool'),
                    typexpr='std::bool',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('One'),
                    computed=True,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
            }
            return (
                my_ptrs
                | __Object_typeof_base__.__gel_reflection__.pointers
            )

        @LazyClassProperty["schema.ObjectType"]
        @classmethod
        def object(cls) -> schema.ObjectType:
            from ... import schema as ___schema_1__
            return ___schema_1__.ObjectType(
                id=UUID(int=27059562504987325367836323013285651930),
                name='schema::SubclassableObject',
                builtin=True,
                internal=False,
                abstract=True,
                final=False,
                compound_type=False,
            )

class __SubclassableObject_typeof__(
    __Object_typeof__,
    __SubclassableObject_typeof_base__,
):
    class __typeof__(__Object_typeof__.__typeof__):
        abstract = TypeAliasType('abstract', 'OptionalProperty[std.bool, bool]')
        is_abstract = TypeAliasType('is_abstract', 'OptionalComputedProperty[std.bool, bool]')
        final = TypeAliasType('final', 'ComputedProperty[std.bool, bool]')
        is_final = TypeAliasType('is_final', 'ComputedProperty[std.bool, bool]')


class __SubclassableObject_typeof_partial__(
    __Object_typeof_partial__,
    __SubclassableObject_typeof_base__,
):
    class __typeof__(__Object_typeof_partial__.__typeof__):
        abstract = TypeAliasType('abstract', 'OptionalProperty[std.bool, bool]')
        is_abstract = TypeAliasType('is_abstract', 'OptionalComputedProperty[std.bool, bool]')
        final = TypeAliasType('final', 'OptionalComputedProperty[std.bool, bool]')
        is_final = TypeAliasType('is_final', 'OptionalComputedProperty[std.bool, bool]')


class SubclassableObject(
    __SubclassableObject_typeof__,
    Object,
    __gel_type_id__=UUID(int=27059562504987325367836323013285651930),
):
    if TYPE_CHECKING:
        def __init__(
            self,
            /,
            *,
            id: UUID | DefaultValue = DEFAULT_VALUE,
            name: builtins.str,
            internal: bool | DefaultValue = DEFAULT_VALUE,
            builtin: bool | DefaultValue = DEFAULT_VALUE,
            computed_fields: list[builtins.str] | None = None,
            abstract: bool | None | DefaultValue = DEFAULT_VALUE,
            final: bool,
        ) -> None:
            """Create a new schema::SubclassableObject instance from keyword arguments.

            Call db.save() on the returned object to persist it in the database.
            """
            ...

    if TYPE_CHECKING:
        @classmethod
        def update(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Update schema::SubclassableObject instances in the database.
            """
            ...

        @classmethod
        def select(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: PathAlias | Literal["*"],
            id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            abstract: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            final: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
        ) -> type[Self]:
            """Fetch schema::SubclassableObject instances from the database.
            """
            ...

        @classmethod
        def filter(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], type[___std__.bool]],
            id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            final: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Fetch schema::SubclassableObject instances from the database.
            """
            ...

        @classmethod
        def order_by(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
            id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            abstract: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            final: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Specify the sort order for the selection"""
            ...


    class __variants__(Object.__variants__):
        class Base(
            __SubclassableObject_typeof__,
            Object.__variants__.Base,
            __gel_variant__="Base",
        ):
            if TYPE_CHECKING:
                def __init__(
                    self,
                    /,
                    *,
                    id: UUID | DefaultValue = DEFAULT_VALUE,
                    name: builtins.str,
                    internal: bool | DefaultValue = DEFAULT_VALUE,
                    builtin: bool | DefaultValue = DEFAULT_VALUE,
                    computed_fields: list[builtins.str] | None = None,
                    abstract: bool | None | DefaultValue = DEFAULT_VALUE,
                    final: bool,
                ) -> None:
                    """Create a new schema::SubclassableObject instance from keyword arguments.

                    Call db.save() on the returned object to persist it in the database.
                    """
                    ...

            if TYPE_CHECKING:
                @classmethod
                def update(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Update schema::SubclassableObject instances in the database.
                    """
                    ...

                @classmethod
                def select(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: PathAlias | Literal["*"],
                    id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    abstract: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    final: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
                ) -> type[Self]:
                    """Fetch schema::SubclassableObject instances from the database.
                    """
                    ...

                @classmethod
                def filter(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], type[___std__.bool]],
                    id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    final: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Fetch schema::SubclassableObject instances from the database.
                    """
                    ...

                @classmethod
                def order_by(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
                    id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    abstract: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    final: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Specify the sort order for the selection"""
                    ...

        class Required(
            Base,
            Object.__variants__.Required,
            __gel_variant__="Required",
        ):
            final: ComputedProperty[std.bool, bool]

        class PartialBase(  # type: ignore [misc, unused-ignore]
            __SubclassableObject_typeof_partial__,
            Base,
            Object.__variants__.PartialBase,
            __gel_variant__="PartialBase",
        ):
            pass

        class Partial(  # type: ignore [misc, unused-ignore]
            PartialBase,
            Object.__variants__.Partial,
            __gel_variant__="Partial",
        ):
            abstract: OptionalProperty[std.bool, bool]
            final: OptionalComputedProperty[std.bool, bool]


        Any = TypeVar("Any", bound="SubclassableObject | Base | Required | Partial")
    class __links__(Object.__links__):
        pass
    class __links_partial__(Object.__links_partial__):
        pass

if not TYPE_CHECKING:
    SubclassableObject.__variants__.Base = SubclassableObject



#
# type schema::VolatilitySubject
#
class __VolatilitySubject_typeof_base__(__Object_typeof_base__):
    class __gel_reflection__(__Object_typeof_base__.__gel_reflection__):
        id = UUID(int=315765006271294895031481864239516637073)
        name = SchemaPath('schema', 'VolatilitySubject')
        @LazyClassProperty["dict[str, GelPointerReflection]"]
        @classmethod
        def pointers(cls) -> dict[str, GelPointerReflection]:
            my_ptrs: dict[str, GelPointerReflection] = {
                'volatility': GelPointerReflection(
                    name='volatility',
                    type=SchemaPath('schema', 'Volatility'),
                    typexpr='schema::Volatility',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=True,
                    properties={},
                ),
            }
            return (
                my_ptrs
                | __Object_typeof_base__.__gel_reflection__.pointers
            )

        @LazyClassProperty["schema.ObjectType"]
        @classmethod
        def object(cls) -> schema.ObjectType:
            from ... import schema as ___schema_1__
            return ___schema_1__.ObjectType(
                id=UUID(int=315765006271294895031481864239516637073),
                name='schema::VolatilitySubject',
                builtin=True,
                internal=False,
                abstract=True,
                final=False,
                compound_type=False,
            )

class __VolatilitySubject_typeof__(
    __Object_typeof__,
    __VolatilitySubject_typeof_base__,
):
    class __typeof__(__Object_typeof__.__typeof__):
        volatility = TypeAliasType('volatility', 'OptionalProperty[Volatility, ___builtins_1__.str]')


class __VolatilitySubject_typeof_partial__(
    __Object_typeof_partial__,
    __VolatilitySubject_typeof_base__,
):
    class __typeof__(__Object_typeof_partial__.__typeof__):
        volatility = TypeAliasType('volatility', 'OptionalProperty[Volatility, ___builtins_1__.str]')


class VolatilitySubject(
    __VolatilitySubject_typeof__,
    Object,
    __gel_type_id__=UUID(int=315765006271294895031481864239516637073),
):
    if TYPE_CHECKING:
        def __init__(
            self,
            /,
            *,
            id: UUID | DefaultValue = DEFAULT_VALUE,
            name: builtins.str,
            internal: bool | DefaultValue = DEFAULT_VALUE,
            builtin: bool | DefaultValue = DEFAULT_VALUE,
            computed_fields: list[builtins.str] | None = None,
            volatility: ___builtins_1__.str | None | DefaultValue = DEFAULT_VALUE,
        ) -> None:
            """Create a new schema::VolatilitySubject instance from keyword arguments.

            Call db.save() on the returned object to persist it in the database.
            """
            ...

    if TYPE_CHECKING:
        @classmethod
        def update(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            volatility: type[Volatility] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Update schema::VolatilitySubject instances in the database.
            """
            ...

        @classmethod
        def select(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: PathAlias | Literal["*"],
            id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            volatility: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[Volatility] | UnspecifiedType = Unspecified,
            **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
        ) -> type[Self]:
            """Fetch schema::VolatilitySubject instances from the database.
            """
            ...

        @classmethod
        def filter(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], type[___std__.bool]],
            id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            volatility: type[Volatility] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Fetch schema::VolatilitySubject instances from the database.
            """
            ...

        @classmethod
        def order_by(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
            id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Specify the sort order for the selection"""
            ...


    class __variants__(Object.__variants__):
        class Base(
            __VolatilitySubject_typeof__,
            Object.__variants__.Base,
            __gel_variant__="Base",
        ):
            if TYPE_CHECKING:
                def __init__(
                    self,
                    /,
                    *,
                    id: UUID | DefaultValue = DEFAULT_VALUE,
                    name: builtins.str,
                    internal: bool | DefaultValue = DEFAULT_VALUE,
                    builtin: bool | DefaultValue = DEFAULT_VALUE,
                    computed_fields: list[builtins.str] | None = None,
                    volatility: ___builtins_1__.str | None | DefaultValue = DEFAULT_VALUE,
                ) -> None:
                    """Create a new schema::VolatilitySubject instance from keyword arguments.

                    Call db.save() on the returned object to persist it in the database.
                    """
                    ...

            if TYPE_CHECKING:
                @classmethod
                def update(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    volatility: type[Volatility] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Update schema::VolatilitySubject instances in the database.
                    """
                    ...

                @classmethod
                def select(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: PathAlias | Literal["*"],
                    id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    volatility: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[Volatility] | UnspecifiedType = Unspecified,
                    **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
                ) -> type[Self]:
                    """Fetch schema::VolatilitySubject instances from the database.
                    """
                    ...

                @classmethod
                def filter(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], type[___std__.bool]],
                    id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    volatility: type[Volatility] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Fetch schema::VolatilitySubject instances from the database.
                    """
                    ...

                @classmethod
                def order_by(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
                    id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Specify the sort order for the selection"""
                    ...

        class Required(
            Base,
            Object.__variants__.Required,
            __gel_variant__="Required",
        ):
            pass

        class PartialBase(  # type: ignore [misc, unused-ignore]
            __VolatilitySubject_typeof_partial__,
            Base,
            Object.__variants__.PartialBase,
            __gel_variant__="PartialBase",
        ):
            pass

        class Partial(  # type: ignore [misc, unused-ignore]
            PartialBase,
            Object.__variants__.Partial,
            __gel_variant__="Partial",
        ):
            volatility: OptionalProperty[Volatility, ___builtins_1__.str]


        Any = TypeVar("Any", bound="VolatilitySubject | Base | Required | Partial")
    class __links__(Object.__links__):
        pass
    class __links_partial__(Object.__links_partial__):
        pass

if not TYPE_CHECKING:
    VolatilitySubject.__variants__.Base = VolatilitySubject



#
# type schema::Alias
#
class __Alias_typeof_base__(__AnnotationSubject_typeof_base__):
    class __gel_reflection__(
        __AnnotationSubject_typeof_base__.__gel_reflection__,
    ):
        id = UUID(int=89765727105434638847323116050456262054)
        name = SchemaPath('schema', 'Alias')
        @LazyClassProperty["dict[str, GelPointerReflection]"]
        @classmethod
        def pointers(cls) -> dict[str, GelPointerReflection]:
            my_ptrs: dict[str, GelPointerReflection] = {
                'expr': GelPointerReflection(
                    name='expr',
                    type=SchemaPath('std', 'str'),
                    typexpr='std::str',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('One'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
                'type': GelPointerReflection(
                    name='type',
                    type=SchemaPath('schema', 'Type'),
                    typexpr='schema::Type',
                    kind=PointerKind('Link'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
            }
            return (
                my_ptrs
                | __AnnotationSubject_typeof_base__.__gel_reflection__.pointers
            )

        @LazyClassProperty["schema.ObjectType"]
        @classmethod
        def object(cls) -> schema.ObjectType:
            from ... import schema as ___schema_1__
            return ___schema_1__.ObjectType(
                id=UUID(int=89765727105434638847323116050456262054),
                name='schema::Alias',
                builtin=True,
                internal=False,
                abstract=False,
                final=False,
                compound_type=False,
            )

class __Alias_typeof__(__AnnotationSubject_typeof__, __Alias_typeof_base__):
    class __typeof__(__AnnotationSubject_typeof__.__typeof__):
        expr = TypeAliasType('expr', 'std.str')
        type = TypeAliasType('type', 'OptionalLink[Type]')


class __Alias_typeof_partial__(
    __AnnotationSubject_typeof_partial__,
    __Alias_typeof_base__,
):
    class __typeof__(__AnnotationSubject_typeof_partial__.__typeof__):
        expr = TypeAliasType('expr', 'OptionalProperty[std.str, builtins.str]')
        type = TypeAliasType('type', 'OptionalLink[Type | Type.__variants__.Partial]')


class Alias(
    __Alias_typeof__,
    AnnotationSubject,
    __gel_type_id__=UUID(int=89765727105434638847323116050456262054),
):
    if TYPE_CHECKING:
        def __init__(
            self,
            /,
            *,
            id: UUID | DefaultValue = DEFAULT_VALUE,
            name: builtins.str,
            internal: bool | DefaultValue = DEFAULT_VALUE,
            builtin: bool | DefaultValue = DEFAULT_VALUE,
            computed_fields: list[builtins.str] | None = None,
            annotations: Iterable[Annotation] = [],
            expr: builtins.str,
            type: Type | None = None,
        ) -> None:
            """Create a new schema::Alias instance from keyword arguments.

            Call db.save() on the returned object to persist it in the database.
            """
            ...

    if TYPE_CHECKING:
        @classmethod
        def update(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
            expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            type: type[schema.Type] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Update schema::Alias instances in the database.
            """
            ...

        @classmethod
        def select(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: PathAlias | Literal["*"],
            id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Annotation] | UnspecifiedType = Unspecified,
            expr: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            type: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Type] | UnspecifiedType = Unspecified,
            **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
        ) -> type[Self]:
            """Fetch schema::Alias instances from the database.
            """
            ...

        @classmethod
        def filter(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], type[___std__.bool]],
            id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
            expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            type: type[schema.Type] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Fetch schema::Alias instances from the database.
            """
            ...

        @classmethod
        def order_by(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
            id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            expr: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Specify the sort order for the selection"""
            ...


    class __variants__(AnnotationSubject.__variants__):
        class Base(
            __Alias_typeof__,
            AnnotationSubject.__variants__.Base,
            __gel_variant__="Base",
        ):
            if TYPE_CHECKING:
                def __init__(
                    self,
                    /,
                    *,
                    id: UUID | DefaultValue = DEFAULT_VALUE,
                    name: builtins.str,
                    internal: bool | DefaultValue = DEFAULT_VALUE,
                    builtin: bool | DefaultValue = DEFAULT_VALUE,
                    computed_fields: list[builtins.str] | None = None,
                    annotations: Iterable[Annotation] = [],
                    expr: builtins.str,
                    type: Type | None = None,
                ) -> None:
                    """Create a new schema::Alias instance from keyword arguments.

                    Call db.save() on the returned object to persist it in the database.
                    """
                    ...

            if TYPE_CHECKING:
                @classmethod
                def update(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
                    expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    type: type[schema.Type] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Update schema::Alias instances in the database.
                    """
                    ...

                @classmethod
                def select(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: PathAlias | Literal["*"],
                    id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Annotation] | UnspecifiedType = Unspecified,
                    expr: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    type: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Type] | UnspecifiedType = Unspecified,
                    **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
                ) -> type[Self]:
                    """Fetch schema::Alias instances from the database.
                    """
                    ...

                @classmethod
                def filter(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], type[___std__.bool]],
                    id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
                    expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    type: type[schema.Type] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Fetch schema::Alias instances from the database.
                    """
                    ...

                @classmethod
                def order_by(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
                    id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    expr: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Specify the sort order for the selection"""
                    ...

        class Required(
            Base,
            AnnotationSubject.__variants__.Required,
            __gel_variant__="Required",
        ):
            expr: std.str

        class PartialBase(  # type: ignore [misc, unused-ignore]
            __Alias_typeof_partial__,
            Base,
            AnnotationSubject.__variants__.PartialBase,
            __gel_variant__="PartialBase",
        ):
            pass

        class Partial(  # type: ignore [misc, unused-ignore]
            PartialBase,
            AnnotationSubject.__variants__.Partial,
            __gel_variant__="Partial",
        ):
            expr: OptionalProperty[std.str, builtins.str]
            type: OptionalLink[___schema__.Type | ___schema__.Type.__variants__.Partial]


        Any = TypeVar("Any", bound="Alias | Base | Required | Partial")
    class __links__(AnnotationSubject.__links__):
        pass
    class __links_partial__(AnnotationSubject.__links_partial__):
        pass

if not TYPE_CHECKING:
    Alias.__variants__.Base = Alias



#
# type schema::CallableObject
#
class __CallableObject_typeof_base__(__AnnotationSubject_typeof_base__):
    class __gel_reflection__(
        __AnnotationSubject_typeof_base__.__gel_reflection__,
    ):
        id = UUID(int=170220000418150476267999719922415966877)
        name = SchemaPath('schema', 'CallableObject')
        @LazyClassProperty["dict[str, GelPointerReflection]"]
        @classmethod
        def pointers(cls) -> dict[str, GelPointerReflection]:
            my_ptrs: dict[str, GelPointerReflection] = {
                'return_typemod': GelPointerReflection(
                    name='return_typemod',
                    type=SchemaPath('schema', 'TypeModifier'),
                    typexpr='schema::TypeModifier',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
                'params': GelPointerReflection(
                    name='params',
                    type=SchemaPath('schema', 'Parameter'),
                    typexpr='schema::Parameter',
                    kind=PointerKind('Link'),
                    cardinality=pydantic.Cardinality('Many'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={
                    'index': GelPointerReflection(
                    name='index',
                    type=SchemaPath('std', 'int64'),
                    typexpr='std::int64',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties=None,
                ),
                },
                ),
                'return_type': GelPointerReflection(
                    name='return_type',
                    type=SchemaPath('schema', 'Type'),
                    typexpr='schema::Type',
                    kind=PointerKind('Link'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
            }
            return (
                my_ptrs
                | __AnnotationSubject_typeof_base__.__gel_reflection__.pointers
            )

        @LazyClassProperty["schema.ObjectType"]
        @classmethod
        def object(cls) -> schema.ObjectType:
            from ... import schema as ___schema_1__
            return ___schema_1__.ObjectType(
                id=UUID(int=170220000418150476267999719922415966877),
                name='schema::CallableObject',
                builtin=True,
                internal=False,
                abstract=True,
                final=False,
                compound_type=False,
            )

class __CallableObject_typeof__(
    __AnnotationSubject_typeof__,
    __CallableObject_typeof_base__,
):
    class __typeof__(__AnnotationSubject_typeof__.__typeof__):
        return_typemod = TypeAliasType('return_typemod', 'OptionalProperty[TypeModifier, ___builtins_1__.str]')
        params = TypeAliasType('params', 'MultiLinkWithProps[CallableObject.__links__.params, Parameter]')
        return_type = TypeAliasType('return_type', 'OptionalLink[Type]')


class __CallableObject_typeof_partial__(
    __AnnotationSubject_typeof_partial__,
    __CallableObject_typeof_base__,
):
    class __typeof__(__AnnotationSubject_typeof_partial__.__typeof__):
        return_typemod = TypeAliasType('return_typemod', 'OptionalProperty[TypeModifier, ___builtins_1__.str]')
        params = TypeAliasType('params', 'MultiLinkWithProps[CallableObject.__links__.params | CallableObject.__links_partial__.params, Parameter]')
        return_type = TypeAliasType('return_type', 'OptionalLink[Type | Type.__variants__.Partial]')


class CallableObject(
    __CallableObject_typeof__,
    AnnotationSubject,
    __gel_type_id__=UUID(int=170220000418150476267999719922415966877),
):
    if TYPE_CHECKING:
        def __init__(
            self,
            /,
            *,
            id: UUID | DefaultValue = DEFAULT_VALUE,
            name: builtins.str,
            internal: bool | DefaultValue = DEFAULT_VALUE,
            builtin: bool | DefaultValue = DEFAULT_VALUE,
            computed_fields: list[builtins.str] | None = None,
            annotations: Iterable[Annotation] = [],
            return_typemod: ___builtins_1__.str | None = None,
            params: Iterable[Parameter] = [],
            return_type: Type | None = None,
        ) -> None:
            """Create a new schema::CallableObject instance from keyword arguments.

            Call db.save() on the returned object to persist it in the database.
            """
            ...

    if TYPE_CHECKING:
        @classmethod
        def update(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
            return_typemod: type[TypeModifier] | UnspecifiedType = Unspecified,
            params: type[schema.Parameter] | UnspecifiedType = Unspecified,
            return_type: type[schema.Type] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Update schema::CallableObject instances in the database.
            """
            ...

        @classmethod
        def select(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: PathAlias | Literal["*"],
            id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Annotation] | UnspecifiedType = Unspecified,
            return_typemod: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[TypeModifier] | UnspecifiedType = Unspecified,
            params: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Parameter] | UnspecifiedType = Unspecified,
            return_type: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Type] | UnspecifiedType = Unspecified,
            **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
        ) -> type[Self]:
            """Fetch schema::CallableObject instances from the database.
            """
            ...

        @classmethod
        def filter(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], type[___std__.bool]],
            id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
            return_typemod: type[TypeModifier] | UnspecifiedType = Unspecified,
            params: type[schema.Parameter] | UnspecifiedType = Unspecified,
            return_type: type[schema.Type] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Fetch schema::CallableObject instances from the database.
            """
            ...

        @classmethod
        def order_by(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
            id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Specify the sort order for the selection"""
            ...


    class __variants__(AnnotationSubject.__variants__):
        class Base(
            __CallableObject_typeof__,
            AnnotationSubject.__variants__.Base,
            __gel_variant__="Base",
        ):
            if TYPE_CHECKING:
                def __init__(
                    self,
                    /,
                    *,
                    id: UUID | DefaultValue = DEFAULT_VALUE,
                    name: builtins.str,
                    internal: bool | DefaultValue = DEFAULT_VALUE,
                    builtin: bool | DefaultValue = DEFAULT_VALUE,
                    computed_fields: list[builtins.str] | None = None,
                    annotations: Iterable[Annotation] = [],
                    return_typemod: ___builtins_1__.str | None = None,
                    params: Iterable[Parameter] = [],
                    return_type: Type | None = None,
                ) -> None:
                    """Create a new schema::CallableObject instance from keyword arguments.

                    Call db.save() on the returned object to persist it in the database.
                    """
                    ...

            if TYPE_CHECKING:
                @classmethod
                def update(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
                    return_typemod: type[TypeModifier] | UnspecifiedType = Unspecified,
                    params: type[schema.Parameter] | UnspecifiedType = Unspecified,
                    return_type: type[schema.Type] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Update schema::CallableObject instances in the database.
                    """
                    ...

                @classmethod
                def select(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: PathAlias | Literal["*"],
                    id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Annotation] | UnspecifiedType = Unspecified,
                    return_typemod: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[TypeModifier] | UnspecifiedType = Unspecified,
                    params: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Parameter] | UnspecifiedType = Unspecified,
                    return_type: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Type] | UnspecifiedType = Unspecified,
                    **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
                ) -> type[Self]:
                    """Fetch schema::CallableObject instances from the database.
                    """
                    ...

                @classmethod
                def filter(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], type[___std__.bool]],
                    id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
                    return_typemod: type[TypeModifier] | UnspecifiedType = Unspecified,
                    params: type[schema.Parameter] | UnspecifiedType = Unspecified,
                    return_type: type[schema.Type] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Fetch schema::CallableObject instances from the database.
                    """
                    ...

                @classmethod
                def order_by(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
                    id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Specify the sort order for the selection"""
                    ...

        class Required(
            Base,
            AnnotationSubject.__variants__.Required,
            __gel_variant__="Required",
        ):
            pass

        class PartialBase(  # type: ignore [misc, unused-ignore]
            __CallableObject_typeof_partial__,
            Base,
            AnnotationSubject.__variants__.PartialBase,
            __gel_variant__="PartialBase",
        ):
            pass

        class Partial(  # type: ignore [misc, unused-ignore]
            PartialBase,
            AnnotationSubject.__variants__.Partial,
            __gel_variant__="Partial",
        ):
            return_typemod: OptionalProperty[TypeModifier, ___builtins_1__.str]
            params: MultiLinkWithProps[CallableObject.__links__.params | CallableObject.__links_partial__.params, ___schema__.Parameter]
            return_type: OptionalLink[___schema__.Type | ___schema__.Type.__variants__.Partial]


        Any = TypeVar("Any", bound="CallableObject | Base | Required | Partial")
    class __links__(AnnotationSubject.__links__):
        if TYPE_CHECKING:
            class params(schema.Parameter, ProxyModel[schema.Parameter]):
                """link schema::CallableObject.params: schema::Parameter"""
                class __lprops__(GelLinkModel):
                    class __gel_reflection__(GelLinkModel.__gel_reflection__):
                        id = UUID(int=100358030936293940852372856355613162134)
                        name = SchemaPath('params')
                        @LazyClassProperty["dict[str, GelPointerReflection]"]
                        @classmethod
                        def pointers(cls) -> dict[str, GelPointerReflection]:
                            my_ptrs: dict[str, GelPointerReflection] = {
                                'index': GelPointerReflection(
                                    name='index',
                                    type=SchemaPath('std', 'int64'),
                                    typexpr='std::int64',
                                    kind=PointerKind('Property'),
                                    cardinality=pydantic.Cardinality('AtMostOne'),
                                    computed=False,
                                    readonly=False,
                                    has_default=False,
                                    properties=None,
                                ),
                            }
                            return my_ptrs


                    index: OptionalProperty[___std__.int64, ___builtins_3__.int]
                __linkprops__: __lprops__

                def __init__(
                    self,
                    obj: schema.Parameter,
                    /,
                    *,
                    index: ___builtins_3__.int | None = None,
                ) -> None:
                    ...

                @classmethod
                def link(
                    cls,
                    obj: schema.Parameter,
                    /,
                    *,
                    index: ___builtins_3__.int | None = None,
                ) -> Self:
                    ...

        if not TYPE_CHECKING:
            @LazyClassProperty[type]
            @classmethod
            def params(cls) -> type:
                class CallableObject__params(
                    ___schema__.Parameter,
                    ProxyModel[___schema__.Parameter],
                ):
                    """link schema::CallableObject.params: schema::Parameter"""
                    class __lprops__(GelLinkModel):
                        class __gel_reflection__(
                            GelLinkModel.__gel_reflection__,
                        ):
                            id = UUID(int=100358030936293940852372856355613162134)
                            name = SchemaPath('params')
                            @LazyClassProperty["dict[str, GelPointerReflection]"]
                            @classmethod
                            def pointers(
                                cls,
                            ) -> dict[str, GelPointerReflection]:
                                my_ptrs: dict[str, GelPointerReflection] = {
                                    'index': GelPointerReflection(
                                        name='index',
                                        type=SchemaPath('std', 'int64'),
                                        typexpr='std::int64',
                                        kind=PointerKind('Property'),
                                        cardinality=pydantic.Cardinality('AtMostOne'),
                                        computed=False,
                                        readonly=False,
                                        has_default=False,
                                        properties=None,
                                    ),
                                }
                                return my_ptrs


                        index: OptionalProperty[std.int64, ___builtins_3__.int]
                    __linkprops__: __lprops__

                    def __init__(self, obj, /, **link_props) -> None:
                        ProxyModel.__init__(self, obj)
                        lprops = self.__class__.__lprops__(**link_props)
                        object.__setattr__(self, "__linkprops__", lprops)

                    @classmethod
                    def link(cls, obj, /, **link_props) -> Self:
                        return cls(obj, **link_props)

                CallableObject__params.__name__ = 'params'
                CallableObject__params.__qualname__ = 'CallableObject.params'
                return CallableObject__params
    class __links_partial__(AnnotationSubject.__links_partial__):
        if TYPE_CHECKING:
            class params(  # type: ignore [misc]
                schema.Parameter.__variants__.Partial,
                ProxyModel[schema.Parameter.__variants__.Partial],
            ):
                """link schema::CallableObject.params: schema::Parameter"""
                class __lprops__(GelLinkModel):
                    class __gel_reflection__(GelLinkModel.__gel_reflection__):
                        id = UUID(int=100358030936293940852372856355613162134)
                        name = SchemaPath('params')
                        @LazyClassProperty["dict[str, GelPointerReflection]"]
                        @classmethod
                        def pointers(cls) -> dict[str, GelPointerReflection]:
                            my_ptrs: dict[str, GelPointerReflection] = {
                                'index': GelPointerReflection(
                                    name='index',
                                    type=SchemaPath('std', 'int64'),
                                    typexpr='std::int64',
                                    kind=PointerKind('Property'),
                                    cardinality=pydantic.Cardinality('AtMostOne'),
                                    computed=False,
                                    readonly=False,
                                    has_default=False,
                                    properties=None,
                                ),
                            }
                            return my_ptrs


                    index: OptionalProperty[___std__.int64, ___builtins_3__.int]
                __linkprops__: __lprops__

                def __init__(
                    self,
                    obj: schema.Parameter.__variants__.Partial,
                    /,
                    *,
                    index: ___builtins_3__.int | None = None,
                ) -> None:
                    ...

                @classmethod
                def link(
                    cls,
                    obj: schema.Parameter.__variants__.Partial,
                    /,
                    *,
                    index: ___builtins_3__.int | None = None,
                ) -> Self:
                    ...

        if not TYPE_CHECKING:
            @LazyClassProperty[type]
            @classmethod
            def params(cls) -> type:
                class CallableObject__params(  # type: ignore [misc]
                    ___schema__.Parameter.__variants__.Partial,
                    ProxyModel[___schema__.Parameter.__variants__.Partial],
                ):
                    """link schema::CallableObject.params: schema::Parameter"""
                    class __lprops__(GelLinkModel):
                        class __gel_reflection__(
                            GelLinkModel.__gel_reflection__,
                        ):
                            id = UUID(int=100358030936293940852372856355613162134)
                            name = SchemaPath('params')
                            @LazyClassProperty["dict[str, GelPointerReflection]"]
                            @classmethod
                            def pointers(
                                cls,
                            ) -> dict[str, GelPointerReflection]:
                                my_ptrs: dict[str, GelPointerReflection] = {
                                    'index': GelPointerReflection(
                                        name='index',
                                        type=SchemaPath('std', 'int64'),
                                        typexpr='std::int64',
                                        kind=PointerKind('Property'),
                                        cardinality=pydantic.Cardinality('AtMostOne'),
                                        computed=False,
                                        readonly=False,
                                        has_default=False,
                                        properties=None,
                                    ),
                                }
                                return my_ptrs


                        index: OptionalProperty[std.int64, ___builtins_3__.int]
                    __linkprops__: __lprops__

                    def __init__(self, obj, /, **link_props) -> None:
                        ProxyModel.__init__(self, obj)
                        lprops = self.__class__.__lprops__(**link_props)
                        object.__setattr__(self, "__linkprops__", lprops)

                    @classmethod
                    def link(cls, obj, /, **link_props) -> Self:
                        return cls(obj, **link_props)

                CallableObject__params.__name__ = 'params'
                CallableObject__params.__qualname__ = 'CallableObject.params'
                return CallableObject__params

if not TYPE_CHECKING:
    CallableObject.__variants__.Base = CallableObject



#
# type schema::Extension
#
class __Extension_typeof_base__(
    __AnnotationSubject_typeof_base__,
    __Object_typeof_base__,
):
    class __gel_reflection__(
        __AnnotationSubject_typeof_base__.__gel_reflection__,
        __Object_typeof_base__.__gel_reflection__,
    ):
        id = UUID(int=246931183695036285442200903660376250349)
        name = SchemaPath('schema', 'Extension')
        @LazyClassProperty["dict[str, GelPointerReflection]"]
        @classmethod
        def pointers(cls) -> dict[str, GelPointerReflection]:
            my_ptrs: dict[str, GelPointerReflection] = {
                'package': GelPointerReflection(
                    name='package',
                    type=SchemaPath('sys', 'ExtensionPackage'),
                    typexpr='sys::ExtensionPackage',
                    kind=PointerKind('Link'),
                    cardinality=pydantic.Cardinality('One'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
            }
            return (
                my_ptrs
                | __AnnotationSubject_typeof_base__.__gel_reflection__.pointers
                | __Object_typeof_base__.__gel_reflection__.pointers
            )

        @LazyClassProperty["schema.ObjectType"]
        @classmethod
        def object(cls) -> schema.ObjectType:
            from ... import schema as ___schema_1__
            return ___schema_1__.ObjectType(
                id=UUID(int=246931183695036285442200903660376250349),
                name='schema::Extension',
                builtin=True,
                internal=False,
                abstract=False,
                final=False,
                compound_type=False,
            )

class __Extension_typeof__(
    __AnnotationSubject_typeof__,
    __Object_typeof__,
    __Extension_typeof_base__,
):
    class __typeof__(
        __AnnotationSubject_typeof__.__typeof__,
        __Object_typeof__.__typeof__,
    ):
        package = TypeAliasType('package', 'sys.ExtensionPackage')


class __Extension_typeof_partial__(
    __AnnotationSubject_typeof_partial__,
    __Object_typeof_partial__,
    __Extension_typeof_base__,
):
    class __typeof__(
        __AnnotationSubject_typeof_partial__.__typeof__,
        __Object_typeof_partial__.__typeof__,
    ):
        package = TypeAliasType('package', 'sys.ExtensionPackage | sys.ExtensionPackage.__variants__.Partial')


class Extension(
    __Extension_typeof__,
    AnnotationSubject,
    Object,
    __gel_type_id__=UUID(int=246931183695036285442200903660376250349),
):
    if TYPE_CHECKING:
        def __init__(
            self,
            /,
            *,
            id: UUID | DefaultValue = DEFAULT_VALUE,
            name: builtins.str,
            internal: bool | DefaultValue = DEFAULT_VALUE,
            builtin: bool | DefaultValue = DEFAULT_VALUE,
            computed_fields: list[builtins.str] | None = None,
            annotations: Iterable[Annotation] = [],
            package: sys.ExtensionPackage | None = None,
        ) -> None:
            """Create a new schema::Extension instance from keyword arguments.

            Call db.save() on the returned object to persist it in the database.
            """
            ...

    if TYPE_CHECKING:
        @classmethod
        def update(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
            package: type[___sys__.ExtensionPackage] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Update schema::Extension instances in the database.
            """
            ...

        @classmethod
        def select(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: PathAlias | Literal["*"],
            id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Annotation] | UnspecifiedType = Unspecified,
            package: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___sys__.ExtensionPackage] | UnspecifiedType = Unspecified,
            **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
        ) -> type[Self]:
            """Fetch schema::Extension instances from the database.
            """
            ...

        @classmethod
        def filter(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], type[___std__.bool]],
            id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
            package: type[___sys__.ExtensionPackage] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Fetch schema::Extension instances from the database.
            """
            ...

        @classmethod
        def order_by(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
            id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Specify the sort order for the selection"""
            ...


    class __variants__(AnnotationSubject.__variants__, Object.__variants__):
        class Base(
            __Extension_typeof__,
            AnnotationSubject.__variants__.Base,
            Object.__variants__.Base,
            __gel_variant__="Base",
        ):
            if TYPE_CHECKING:
                def __init__(
                    self,
                    /,
                    *,
                    id: UUID | DefaultValue = DEFAULT_VALUE,
                    name: builtins.str,
                    internal: bool | DefaultValue = DEFAULT_VALUE,
                    builtin: bool | DefaultValue = DEFAULT_VALUE,
                    computed_fields: list[builtins.str] | None = None,
                    annotations: Iterable[Annotation] = [],
                    package: sys.ExtensionPackage | None = None,
                ) -> None:
                    """Create a new schema::Extension instance from keyword arguments.

                    Call db.save() on the returned object to persist it in the database.
                    """
                    ...

            if TYPE_CHECKING:
                @classmethod
                def update(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
                    package: type[___sys__.ExtensionPackage] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Update schema::Extension instances in the database.
                    """
                    ...

                @classmethod
                def select(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: PathAlias | Literal["*"],
                    id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Annotation] | UnspecifiedType = Unspecified,
                    package: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___sys__.ExtensionPackage] | UnspecifiedType = Unspecified,
                    **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
                ) -> type[Self]:
                    """Fetch schema::Extension instances from the database.
                    """
                    ...

                @classmethod
                def filter(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], type[___std__.bool]],
                    id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
                    package: type[___sys__.ExtensionPackage] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Fetch schema::Extension instances from the database.
                    """
                    ...

                @classmethod
                def order_by(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
                    id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Specify the sort order for the selection"""
                    ...

        class Required(
            Base,
            AnnotationSubject.__variants__.Required,
            Object.__variants__.Required,
            __gel_variant__="Required",
        ):
            package: ___sys_1__.ExtensionPackage

        class PartialBase(  # type: ignore [misc, unused-ignore]
            __Extension_typeof_partial__,
            Base,
            AnnotationSubject.__variants__.PartialBase,
            Object.__variants__.PartialBase,
            __gel_variant__="PartialBase",
        ):
            pass

        class Partial(  # type: ignore [misc, unused-ignore]
            PartialBase,
            AnnotationSubject.__variants__.Partial,
            Object.__variants__.Partial,
            __gel_variant__="Partial",
        ):
            package: ___sys_1__.ExtensionPackage | ___sys_1__.ExtensionPackage.__variants__.Partial


        Any = TypeVar("Any", bound="Extension | Base | Required | Partial")
    class __links__(AnnotationSubject.__links__, Object.__links__):
        pass
    class __links_partial__(
        AnnotationSubject.__links_partial__,
        Object.__links_partial__,
    ):
        pass

if not TYPE_CHECKING:
    Extension.__variants__.Base = Extension



#
# type schema::Global
#
class __Global_typeof_base__(__AnnotationSubject_typeof_base__):
    class __gel_reflection__(
        __AnnotationSubject_typeof_base__.__gel_reflection__,
    ):
        id = UUID(int=299290551709576802008662613040485138993)
        name = SchemaPath('schema', 'Global')
        @LazyClassProperty["dict[str, GelPointerReflection]"]
        @classmethod
        def pointers(cls) -> dict[str, GelPointerReflection]:
            my_ptrs: dict[str, GelPointerReflection] = {
                'default': GelPointerReflection(
                    name='default',
                    type=SchemaPath('std', 'str'),
                    typexpr='std::str',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
                'required': GelPointerReflection(
                    name='required',
                    type=SchemaPath('std', 'bool'),
                    typexpr='std::bool',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
                'cardinality': GelPointerReflection(
                    name='cardinality',
                    type=SchemaPath('schema', 'Cardinality'),
                    typexpr='schema::Cardinality',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
                'expr': GelPointerReflection(
                    name='expr',
                    type=SchemaPath('std', 'str'),
                    typexpr='std::str',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
                'target': GelPointerReflection(
                    name='target',
                    type=SchemaPath('schema', 'Type'),
                    typexpr='schema::Type',
                    kind=PointerKind('Link'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
            }
            return (
                my_ptrs
                | __AnnotationSubject_typeof_base__.__gel_reflection__.pointers
            )

        @LazyClassProperty["schema.ObjectType"]
        @classmethod
        def object(cls) -> schema.ObjectType:
            from ... import schema as ___schema_1__
            return ___schema_1__.ObjectType(
                id=UUID(int=299290551709576802008662613040485138993),
                name='schema::Global',
                builtin=True,
                internal=False,
                abstract=False,
                final=False,
                compound_type=False,
            )

class __Global_typeof__(__AnnotationSubject_typeof__, __Global_typeof_base__):
    class __typeof__(__AnnotationSubject_typeof__.__typeof__):
        default = TypeAliasType('default', 'OptionalProperty[std.str, builtins.str]')
        required = TypeAliasType('required', 'OptionalProperty[std.bool, bool]')
        cardinality = TypeAliasType('cardinality', 'OptionalProperty[Cardinality, ___builtins_1__.str]')
        expr = TypeAliasType('expr', 'OptionalProperty[std.str, builtins.str]')
        target = TypeAliasType('target', 'OptionalLink[Type]')


class __Global_typeof_partial__(
    __AnnotationSubject_typeof_partial__,
    __Global_typeof_base__,
):
    class __typeof__(__AnnotationSubject_typeof_partial__.__typeof__):
        default = TypeAliasType('default', 'OptionalProperty[std.str, builtins.str]')
        required = TypeAliasType('required', 'OptionalProperty[std.bool, bool]')
        cardinality = TypeAliasType('cardinality', 'OptionalProperty[Cardinality, ___builtins_1__.str]')
        expr = TypeAliasType('expr', 'OptionalProperty[std.str, builtins.str]')
        target = TypeAliasType('target', 'OptionalLink[Type | Type.__variants__.Partial]')


class Global(
    __Global_typeof__,
    AnnotationSubject,
    __gel_type_id__=UUID(int=299290551709576802008662613040485138993),
):
    if TYPE_CHECKING:
        def __init__(
            self,
            /,
            *,
            id: UUID | DefaultValue = DEFAULT_VALUE,
            name: builtins.str,
            internal: bool | DefaultValue = DEFAULT_VALUE,
            builtin: bool | DefaultValue = DEFAULT_VALUE,
            computed_fields: list[builtins.str] | None = None,
            annotations: Iterable[Annotation] = [],
            default: builtins.str | None = None,
            required: bool | None = None,
            cardinality: ___builtins_1__.str | None = None,
            expr: builtins.str | None = None,
            target: Type | None = None,
        ) -> None:
            """Create a new schema::Global instance from keyword arguments.

            Call db.save() on the returned object to persist it in the database.
            """
            ...

    if TYPE_CHECKING:
        @classmethod
        def update(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
            default: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            required: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            cardinality: type[Cardinality] | UnspecifiedType = Unspecified,
            expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            target: type[schema.Type] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Update schema::Global instances in the database.
            """
            ...

        @classmethod
        def select(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: PathAlias | Literal["*"],
            id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Annotation] | UnspecifiedType = Unspecified,
            default: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            required: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            cardinality: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[Cardinality] | UnspecifiedType = Unspecified,
            expr: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            target: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Type] | UnspecifiedType = Unspecified,
            **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
        ) -> type[Self]:
            """Fetch schema::Global instances from the database.
            """
            ...

        @classmethod
        def filter(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], type[___std__.bool]],
            id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
            default: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            required: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            cardinality: type[Cardinality] | UnspecifiedType = Unspecified,
            expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            target: type[schema.Type] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Fetch schema::Global instances from the database.
            """
            ...

        @classmethod
        def order_by(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
            id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            default: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            required: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            expr: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Specify the sort order for the selection"""
            ...


    class __variants__(AnnotationSubject.__variants__):
        class Base(
            __Global_typeof__,
            AnnotationSubject.__variants__.Base,
            __gel_variant__="Base",
        ):
            if TYPE_CHECKING:
                def __init__(
                    self,
                    /,
                    *,
                    id: UUID | DefaultValue = DEFAULT_VALUE,
                    name: builtins.str,
                    internal: bool | DefaultValue = DEFAULT_VALUE,
                    builtin: bool | DefaultValue = DEFAULT_VALUE,
                    computed_fields: list[builtins.str] | None = None,
                    annotations: Iterable[Annotation] = [],
                    default: builtins.str | None = None,
                    required: bool | None = None,
                    cardinality: ___builtins_1__.str | None = None,
                    expr: builtins.str | None = None,
                    target: Type | None = None,
                ) -> None:
                    """Create a new schema::Global instance from keyword arguments.

                    Call db.save() on the returned object to persist it in the database.
                    """
                    ...

            if TYPE_CHECKING:
                @classmethod
                def update(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
                    default: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    required: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    cardinality: type[Cardinality] | UnspecifiedType = Unspecified,
                    expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    target: type[schema.Type] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Update schema::Global instances in the database.
                    """
                    ...

                @classmethod
                def select(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: PathAlias | Literal["*"],
                    id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Annotation] | UnspecifiedType = Unspecified,
                    default: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    required: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    cardinality: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[Cardinality] | UnspecifiedType = Unspecified,
                    expr: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    target: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Type] | UnspecifiedType = Unspecified,
                    **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
                ) -> type[Self]:
                    """Fetch schema::Global instances from the database.
                    """
                    ...

                @classmethod
                def filter(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], type[___std__.bool]],
                    id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
                    default: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    required: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    cardinality: type[Cardinality] | UnspecifiedType = Unspecified,
                    expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    target: type[schema.Type] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Fetch schema::Global instances from the database.
                    """
                    ...

                @classmethod
                def order_by(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
                    id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    default: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    required: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    expr: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Specify the sort order for the selection"""
                    ...

        class Required(
            Base,
            AnnotationSubject.__variants__.Required,
            __gel_variant__="Required",
        ):
            pass

        class PartialBase(  # type: ignore [misc, unused-ignore]
            __Global_typeof_partial__,
            Base,
            AnnotationSubject.__variants__.PartialBase,
            __gel_variant__="PartialBase",
        ):
            pass

        class Partial(  # type: ignore [misc, unused-ignore]
            PartialBase,
            AnnotationSubject.__variants__.Partial,
            __gel_variant__="Partial",
        ):
            default: OptionalProperty[std.str, builtins.str]
            required: OptionalProperty[std.bool, bool]
            cardinality: OptionalProperty[Cardinality, ___builtins_1__.str]
            expr: OptionalProperty[std.str, builtins.str]
            target: OptionalLink[___schema__.Type | ___schema__.Type.__variants__.Partial]


        Any = TypeVar("Any", bound="Global | Base | Required | Partial")
    class __links__(AnnotationSubject.__links__):
        pass
    class __links_partial__(AnnotationSubject.__links_partial__):
        pass

if not TYPE_CHECKING:
    Global.__variants__.Base = Global



#
# type schema::Migration
#
class __Migration_typeof_base__(
    __AnnotationSubject_typeof_base__,
    __Object_typeof_base__,
):
    class __gel_reflection__(
        __AnnotationSubject_typeof_base__.__gel_reflection__,
        __Object_typeof_base__.__gel_reflection__,
    ):
        id = UUID(int=66416194960845351792630777443783118454)
        name = SchemaPath('schema', 'Migration')
        @LazyClassProperty["dict[str, GelPointerReflection]"]
        @classmethod
        def pointers(cls) -> dict[str, GelPointerReflection]:
            my_ptrs: dict[str, GelPointerReflection] = {
                'script': GelPointerReflection(
                    name='script',
                    type=SchemaPath('std', 'str'),
                    typexpr='std::str',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('One'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
                'sdl': GelPointerReflection(
                    name='sdl',
                    type=SchemaPath('std', 'str'),
                    typexpr='std::str',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
                'message': GelPointerReflection(
                    name='message',
                    type=SchemaPath('std', 'str'),
                    typexpr='std::str',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
                'generated_by': GelPointerReflection(
                    name='generated_by',
                    type=SchemaPath('schema', 'MigrationGeneratedBy'),
                    typexpr='schema::MigrationGeneratedBy',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
                'parents': GelPointerReflection(
                    name='parents',
                    type=SchemaPath('schema', 'Migration'),
                    typexpr='schema::Migration',
                    kind=PointerKind('Link'),
                    cardinality=pydantic.Cardinality('Many'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
            }
            return (
                my_ptrs
                | __AnnotationSubject_typeof_base__.__gel_reflection__.pointers
                | __Object_typeof_base__.__gel_reflection__.pointers
            )

        @LazyClassProperty["schema.ObjectType"]
        @classmethod
        def object(cls) -> schema.ObjectType:
            from ... import schema as ___schema_1__
            return ___schema_1__.ObjectType(
                id=UUID(int=66416194960845351792630777443783118454),
                name='schema::Migration',
                builtin=True,
                internal=False,
                abstract=False,
                final=False,
                compound_type=False,
            )

class __Migration_typeof__(
    __AnnotationSubject_typeof__,
    __Object_typeof__,
    __Migration_typeof_base__,
):
    class __typeof__(
        __AnnotationSubject_typeof__.__typeof__,
        __Object_typeof__.__typeof__,
    ):
        script = TypeAliasType('script', 'std.str')
        sdl = TypeAliasType('sdl', 'OptionalProperty[std.str, builtins.str]')
        message = TypeAliasType('message', 'OptionalProperty[std.str, builtins.str]')
        generated_by = TypeAliasType('generated_by', 'OptionalProperty[MigrationGeneratedBy, ___builtins_1__.str]')
        parents = TypeAliasType('parents', 'MultiLink[Migration]')


class __Migration_typeof_partial__(
    __AnnotationSubject_typeof_partial__,
    __Object_typeof_partial__,
    __Migration_typeof_base__,
):
    class __typeof__(
        __AnnotationSubject_typeof_partial__.__typeof__,
        __Object_typeof_partial__.__typeof__,
    ):
        script = TypeAliasType('script', 'OptionalProperty[std.str, builtins.str]')
        sdl = TypeAliasType('sdl', 'OptionalProperty[std.str, builtins.str]')
        message = TypeAliasType('message', 'OptionalProperty[std.str, builtins.str]')
        generated_by = TypeAliasType('generated_by', 'OptionalProperty[MigrationGeneratedBy, ___builtins_1__.str]')
        parents = TypeAliasType('parents', 'MultiLink[Migration | Migration.__variants__.Partial]')


class Migration(
    __Migration_typeof__,
    AnnotationSubject,
    Object,
    __gel_type_id__=UUID(int=66416194960845351792630777443783118454),
):
    if TYPE_CHECKING:
        def __init__(
            self,
            /,
            *,
            id: UUID | DefaultValue = DEFAULT_VALUE,
            name: builtins.str,
            internal: bool | DefaultValue = DEFAULT_VALUE,
            builtin: bool | DefaultValue = DEFAULT_VALUE,
            computed_fields: list[builtins.str] | None = None,
            annotations: Iterable[Annotation] = [],
            script: builtins.str,
            sdl: builtins.str | None = None,
            message: builtins.str | None = None,
            generated_by: ___builtins_1__.str | None = None,
            parents: Iterable[Migration] = [],
        ) -> None:
            """Create a new schema::Migration instance from keyword arguments.

            Call db.save() on the returned object to persist it in the database.
            """
            ...

    if TYPE_CHECKING:
        @classmethod
        def update(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
            script: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            sdl: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            message: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            generated_by: type[MigrationGeneratedBy] | UnspecifiedType = Unspecified,
            parents: type[schema.Migration] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Update schema::Migration instances in the database.
            """
            ...

        @classmethod
        def select(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: PathAlias | Literal["*"],
            id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Annotation] | UnspecifiedType = Unspecified,
            script: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            sdl: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            message: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            generated_by: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[MigrationGeneratedBy] | UnspecifiedType = Unspecified,
            parents: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Migration] | UnspecifiedType = Unspecified,
            **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
        ) -> type[Self]:
            """Fetch schema::Migration instances from the database.
            """
            ...

        @classmethod
        def filter(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], type[___std__.bool]],
            id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
            script: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            sdl: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            message: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            generated_by: type[MigrationGeneratedBy] | UnspecifiedType = Unspecified,
            parents: type[schema.Migration] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Fetch schema::Migration instances from the database.
            """
            ...

        @classmethod
        def order_by(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
            id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            script: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            sdl: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            message: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Specify the sort order for the selection"""
            ...


    class __variants__(AnnotationSubject.__variants__, Object.__variants__):
        class Base(
            __Migration_typeof__,
            AnnotationSubject.__variants__.Base,
            Object.__variants__.Base,
            __gel_variant__="Base",
        ):
            if TYPE_CHECKING:
                def __init__(
                    self,
                    /,
                    *,
                    id: UUID | DefaultValue = DEFAULT_VALUE,
                    name: builtins.str,
                    internal: bool | DefaultValue = DEFAULT_VALUE,
                    builtin: bool | DefaultValue = DEFAULT_VALUE,
                    computed_fields: list[builtins.str] | None = None,
                    annotations: Iterable[Annotation] = [],
                    script: builtins.str,
                    sdl: builtins.str | None = None,
                    message: builtins.str | None = None,
                    generated_by: ___builtins_1__.str | None = None,
                    parents: Iterable[Migration] = [],
                ) -> None:
                    """Create a new schema::Migration instance from keyword arguments.

                    Call db.save() on the returned object to persist it in the database.
                    """
                    ...

            if TYPE_CHECKING:
                @classmethod
                def update(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
                    script: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    sdl: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    message: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    generated_by: type[MigrationGeneratedBy] | UnspecifiedType = Unspecified,
                    parents: type[schema.Migration] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Update schema::Migration instances in the database.
                    """
                    ...

                @classmethod
                def select(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: PathAlias | Literal["*"],
                    id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Annotation] | UnspecifiedType = Unspecified,
                    script: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    sdl: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    message: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    generated_by: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[MigrationGeneratedBy] | UnspecifiedType = Unspecified,
                    parents: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Migration] | UnspecifiedType = Unspecified,
                    **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
                ) -> type[Self]:
                    """Fetch schema::Migration instances from the database.
                    """
                    ...

                @classmethod
                def filter(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], type[___std__.bool]],
                    id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
                    script: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    sdl: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    message: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    generated_by: type[MigrationGeneratedBy] | UnspecifiedType = Unspecified,
                    parents: type[schema.Migration] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Fetch schema::Migration instances from the database.
                    """
                    ...

                @classmethod
                def order_by(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
                    id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    script: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    sdl: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    message: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Specify the sort order for the selection"""
                    ...

        class Required(
            Base,
            AnnotationSubject.__variants__.Required,
            Object.__variants__.Required,
            __gel_variant__="Required",
        ):
            script: std.str

        class PartialBase(  # type: ignore [misc, unused-ignore]
            __Migration_typeof_partial__,
            Base,
            AnnotationSubject.__variants__.PartialBase,
            Object.__variants__.PartialBase,
            __gel_variant__="PartialBase",
        ):
            pass

        class Partial(  # type: ignore [misc, unused-ignore]
            PartialBase,
            AnnotationSubject.__variants__.Partial,
            Object.__variants__.Partial,
            __gel_variant__="Partial",
        ):
            script: OptionalProperty[std.str, builtins.str]
            sdl: OptionalProperty[std.str, builtins.str]
            message: OptionalProperty[std.str, builtins.str]
            generated_by: OptionalProperty[MigrationGeneratedBy, ___builtins_1__.str]
            parents: MultiLink[___schema__.Migration | ___schema__.Migration.__variants__.Partial]


        Any = TypeVar("Any", bound="Migration | Base | Required | Partial")
    class __links__(AnnotationSubject.__links__, Object.__links__):
        pass
    class __links_partial__(
        AnnotationSubject.__links_partial__,
        Object.__links_partial__,
    ):
        pass

if not TYPE_CHECKING:
    Migration.__variants__.Base = Migration



#
# type schema::Module
#
class __Module_typeof_base__(
    __AnnotationSubject_typeof_base__,
    __Object_typeof_base__,
):
    class __gel_reflection__(
        __AnnotationSubject_typeof_base__.__gel_reflection__,
        __Object_typeof_base__.__gel_reflection__,
    ):
        id = UUID(int=150233990426722901639198192952859157996)
        name = SchemaPath('schema', 'Module')
        @LazyClassProperty["dict[str, ___pydantic_1__.GelPointerReflection]"]
        @classmethod
        def pointers(cls) -> dict[str, ___pydantic_1__.GelPointerReflection]:
            my_ptrs: dict[str, ___pydantic_1__.GelPointerReflection] = {}
            return (
                my_ptrs
                | __AnnotationSubject_typeof_base__.__gel_reflection__.pointers
                | __Object_typeof_base__.__gel_reflection__.pointers
            )

        @LazyClassProperty["schema.ObjectType"]
        @classmethod
        def object(cls) -> schema.ObjectType:
            from ... import schema as ___schema_1__
            return ___schema_1__.ObjectType(
                id=UUID(int=150233990426722901639198192952859157996),
                name='schema::Module',
                builtin=True,
                internal=False,
                abstract=False,
                final=False,
                compound_type=False,
            )

class __Module_typeof__(
    __AnnotationSubject_typeof__,
    __Object_typeof__,
    __Module_typeof_base__,
):
    class __typeof__(
        __AnnotationSubject_typeof__.__typeof__,
        __Object_typeof__.__typeof__,
    ):
        pass


class __Module_typeof_partial__(
    __AnnotationSubject_typeof_partial__,
    __Object_typeof_partial__,
    __Module_typeof_base__,
):
    class __typeof__(
        __AnnotationSubject_typeof_partial__.__typeof__,
        __Object_typeof_partial__.__typeof__,
    ):
        pass


class Module(
    __Module_typeof__,
    AnnotationSubject,
    Object,
    __gel_type_id__=UUID(int=150233990426722901639198192952859157996),
):
    if TYPE_CHECKING:
        def __init__(
            self,
            /,
            *,
            id: UUID | DefaultValue = DEFAULT_VALUE,
            name: builtins.str,
            internal: bool | DefaultValue = DEFAULT_VALUE,
            builtin: bool | DefaultValue = DEFAULT_VALUE,
            computed_fields: list[builtins.str] | None = None,
            annotations: Iterable[Annotation] = [],
        ) -> None:
            """Create a new schema::Module instance from keyword arguments.

            Call db.save() on the returned object to persist it in the database.
            """
            ...

    if TYPE_CHECKING:
        @classmethod
        def update(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Update schema::Module instances in the database.
            """
            ...

        @classmethod
        def select(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: PathAlias | Literal["*"],
            id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Annotation] | UnspecifiedType = Unspecified,
            **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
        ) -> type[Self]:
            """Fetch schema::Module instances from the database.
            """
            ...

        @classmethod
        def filter(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], type[___std__.bool]],
            id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Fetch schema::Module instances from the database.
            """
            ...

        @classmethod
        def order_by(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
            id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Specify the sort order for the selection"""
            ...


    class __variants__(AnnotationSubject.__variants__, Object.__variants__):
        class Base(
            __Module_typeof__,
            AnnotationSubject.__variants__.Base,
            Object.__variants__.Base,
            __gel_variant__="Base",
        ):
            if TYPE_CHECKING:
                def __init__(
                    self,
                    /,
                    *,
                    id: UUID | DefaultValue = DEFAULT_VALUE,
                    name: builtins.str,
                    internal: bool | DefaultValue = DEFAULT_VALUE,
                    builtin: bool | DefaultValue = DEFAULT_VALUE,
                    computed_fields: list[builtins.str] | None = None,
                    annotations: Iterable[Annotation] = [],
                ) -> None:
                    """Create a new schema::Module instance from keyword arguments.

                    Call db.save() on the returned object to persist it in the database.
                    """
                    ...

            if TYPE_CHECKING:
                @classmethod
                def update(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Update schema::Module instances in the database.
                    """
                    ...

                @classmethod
                def select(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: PathAlias | Literal["*"],
                    id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Annotation] | UnspecifiedType = Unspecified,
                    **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
                ) -> type[Self]:
                    """Fetch schema::Module instances from the database.
                    """
                    ...

                @classmethod
                def filter(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], type[___std__.bool]],
                    id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Fetch schema::Module instances from the database.
                    """
                    ...

                @classmethod
                def order_by(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
                    id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Specify the sort order for the selection"""
                    ...

        class Required(
            Base,
            AnnotationSubject.__variants__.Required,
            Object.__variants__.Required,
            __gel_variant__="Required",
        ):
            pass

        class PartialBase(  # type: ignore [misc, unused-ignore]
            __Module_typeof_partial__,
            Base,
            AnnotationSubject.__variants__.PartialBase,
            Object.__variants__.PartialBase,
            __gel_variant__="PartialBase",
        ):
            pass

        class Partial(  # type: ignore [misc, unused-ignore]
            PartialBase,
            AnnotationSubject.__variants__.Partial,
            Object.__variants__.Partial,
            __gel_variant__="Partial",
        ):
            pass


        Any = TypeVar("Any", bound="Module | Base | Required | Partial")
    class __links__(AnnotationSubject.__links__, Object.__links__):
        pass
    class __links_partial__(
        AnnotationSubject.__links_partial__,
        Object.__links_partial__,
    ):
        pass

if not TYPE_CHECKING:
    Module.__variants__.Base = Module



#
# type schema::InheritingObject
#
class __InheritingObject_typeof_base__(__SubclassableObject_typeof_base__):
    class __gel_reflection__(
        __SubclassableObject_typeof_base__.__gel_reflection__,
    ):
        id = UUID(int=173267341075642542569379505558814888434)
        name = SchemaPath('schema', 'InheritingObject')
        @LazyClassProperty["dict[str, GelPointerReflection]"]
        @classmethod
        def pointers(cls) -> dict[str, GelPointerReflection]:
            my_ptrs: dict[str, GelPointerReflection] = {
                'inherited_fields': GelPointerReflection(
                    name='inherited_fields',
                    type=SchemaPath('array<std::str>'),
                    typexpr='array<std::str>',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
                'bases': GelPointerReflection(
                    name='bases',
                    type=SchemaPath('schema', 'InheritingObject'),
                    typexpr='schema::InheritingObject',
                    kind=PointerKind('Link'),
                    cardinality=pydantic.Cardinality('Many'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={
                    'index': GelPointerReflection(
                    name='index',
                    type=SchemaPath('std', 'int64'),
                    typexpr='std::int64',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties=None,
                ),
                },
                ),
                'ancestors': GelPointerReflection(
                    name='ancestors',
                    type=SchemaPath('schema', 'InheritingObject'),
                    typexpr='schema::InheritingObject',
                    kind=PointerKind('Link'),
                    cardinality=pydantic.Cardinality('Many'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={
                    'index': GelPointerReflection(
                    name='index',
                    type=SchemaPath('std', 'int64'),
                    typexpr='std::int64',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties=None,
                ),
                },
                ),
            }
            return (
                my_ptrs
                | __SubclassableObject_typeof_base__.__gel_reflection__.pointers
            )

        @LazyClassProperty["schema.ObjectType"]
        @classmethod
        def object(cls) -> schema.ObjectType:
            from ... import schema as ___schema_1__
            return ___schema_1__.ObjectType(
                id=UUID(int=173267341075642542569379505558814888434),
                name='schema::InheritingObject',
                builtin=True,
                internal=False,
                abstract=True,
                final=False,
                compound_type=False,
            )

class __InheritingObject_typeof__(
    __SubclassableObject_typeof__,
    __InheritingObject_typeof_base__,
):
    class __typeof__(__SubclassableObject_typeof__.__typeof__):
        inherited_fields = TypeAliasType('inherited_fields', 'OptionalProperty[___pydantic__.Array[std.str], list[builtins.str]]')
        bases = TypeAliasType('bases', 'MultiLinkWithProps[InheritingObject.__links__.bases, InheritingObject]')
        ancestors = TypeAliasType('ancestors', 'MultiLinkWithProps[InheritingObject.__links__.ancestors, InheritingObject]')


class __InheritingObject_typeof_partial__(
    __SubclassableObject_typeof_partial__,
    __InheritingObject_typeof_base__,
):
    class __typeof__(__SubclassableObject_typeof_partial__.__typeof__):
        inherited_fields = TypeAliasType('inherited_fields', 'OptionalProperty[___pydantic__.Array[std.str], list[builtins.str]]')
        bases = TypeAliasType('bases', 'MultiLinkWithProps[InheritingObject.__links__.bases | InheritingObject.__links_partial__.bases, InheritingObject]')
        ancestors = TypeAliasType('ancestors', 'MultiLinkWithProps[InheritingObject.__links__.ancestors | InheritingObject.__links_partial__.ancestors, InheritingObject]')


class InheritingObject(
    __InheritingObject_typeof__,
    SubclassableObject,
    __gel_type_id__=UUID(int=173267341075642542569379505558814888434),
):
    if TYPE_CHECKING:
        def __init__(
            self,
            /,
            *,
            id: UUID | DefaultValue = DEFAULT_VALUE,
            name: builtins.str,
            internal: bool | DefaultValue = DEFAULT_VALUE,
            builtin: bool | DefaultValue = DEFAULT_VALUE,
            computed_fields: list[builtins.str] | None = None,
            abstract: bool | None | DefaultValue = DEFAULT_VALUE,
            final: bool,
            inherited_fields: list[builtins.str] | None = None,
            bases: Iterable[InheritingObject] = [],
            ancestors: Iterable[InheritingObject] = [],
        ) -> None:
            """Create a new schema::InheritingObject instance from keyword arguments.

            Call db.save() on the returned object to persist it in the database.
            """
            ...

    if TYPE_CHECKING:
        @classmethod
        def update(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            inherited_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            bases: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            ancestors: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Update schema::InheritingObject instances in the database.
            """
            ...

        @classmethod
        def select(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: PathAlias | Literal["*"],
            id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            abstract: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            final: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            inherited_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            bases: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            ancestors: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
        ) -> type[Self]:
            """Fetch schema::InheritingObject instances from the database.
            """
            ...

        @classmethod
        def filter(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], type[___std__.bool]],
            id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            final: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            inherited_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            bases: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            ancestors: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Fetch schema::InheritingObject instances from the database.
            """
            ...

        @classmethod
        def order_by(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
            id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            abstract: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            final: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Specify the sort order for the selection"""
            ...


    class __variants__(SubclassableObject.__variants__):
        class Base(
            __InheritingObject_typeof__,
            SubclassableObject.__variants__.Base,
            __gel_variant__="Base",
        ):
            if TYPE_CHECKING:
                def __init__(
                    self,
                    /,
                    *,
                    id: UUID | DefaultValue = DEFAULT_VALUE,
                    name: builtins.str,
                    internal: bool | DefaultValue = DEFAULT_VALUE,
                    builtin: bool | DefaultValue = DEFAULT_VALUE,
                    computed_fields: list[builtins.str] | None = None,
                    abstract: bool | None | DefaultValue = DEFAULT_VALUE,
                    final: bool,
                    inherited_fields: list[builtins.str] | None = None,
                    bases: Iterable[InheritingObject] = [],
                    ancestors: Iterable[InheritingObject] = [],
                ) -> None:
                    """Create a new schema::InheritingObject instance from keyword arguments.

                    Call db.save() on the returned object to persist it in the database.
                    """
                    ...

            if TYPE_CHECKING:
                @classmethod
                def update(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    inherited_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    bases: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    ancestors: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Update schema::InheritingObject instances in the database.
                    """
                    ...

                @classmethod
                def select(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: PathAlias | Literal["*"],
                    id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    abstract: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    final: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    inherited_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    bases: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    ancestors: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
                ) -> type[Self]:
                    """Fetch schema::InheritingObject instances from the database.
                    """
                    ...

                @classmethod
                def filter(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], type[___std__.bool]],
                    id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    final: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    inherited_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    bases: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    ancestors: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Fetch schema::InheritingObject instances from the database.
                    """
                    ...

                @classmethod
                def order_by(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
                    id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    abstract: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    final: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Specify the sort order for the selection"""
                    ...

        class Required(
            Base,
            SubclassableObject.__variants__.Required,
            __gel_variant__="Required",
        ):
            pass

        class PartialBase(  # type: ignore [misc, unused-ignore]
            __InheritingObject_typeof_partial__,
            Base,
            SubclassableObject.__variants__.PartialBase,
            __gel_variant__="PartialBase",
        ):
            pass

        class Partial(  # type: ignore [misc, unused-ignore]
            PartialBase,
            SubclassableObject.__variants__.Partial,
            __gel_variant__="Partial",
        ):
            inherited_fields: OptionalProperty[___pydantic__.Array[std.str], list[builtins.str]]
            bases: MultiLinkWithProps[InheritingObject.__links__.bases | InheritingObject.__links_partial__.bases, ___schema__.InheritingObject]
            ancestors: MultiLinkWithProps[InheritingObject.__links__.ancestors | InheritingObject.__links_partial__.ancestors, ___schema__.InheritingObject]


        Any = TypeVar("Any", bound="InheritingObject | Base | Required | Partial")
    class __links__(SubclassableObject.__links__):
        if TYPE_CHECKING:
            class bases(
                schema.InheritingObject,
                ProxyModel[schema.InheritingObject],
            ):
                """link schema::InheritingObject.bases: schema::InheritingObject"""
                class __lprops__(GelLinkModel):
                    class __gel_reflection__(GelLinkModel.__gel_reflection__):
                        id = UUID(int=103009263448688509382637288792612543583)
                        name = SchemaPath('bases')
                        @LazyClassProperty["dict[str, GelPointerReflection]"]
                        @classmethod
                        def pointers(cls) -> dict[str, GelPointerReflection]:
                            my_ptrs: dict[str, GelPointerReflection] = {
                                'index': GelPointerReflection(
                                    name='index',
                                    type=SchemaPath('std', 'int64'),
                                    typexpr='std::int64',
                                    kind=PointerKind('Property'),
                                    cardinality=pydantic.Cardinality('AtMostOne'),
                                    computed=False,
                                    readonly=False,
                                    has_default=False,
                                    properties=None,
                                ),
                            }
                            return my_ptrs


                    index: OptionalProperty[___std__.int64, ___builtins_3__.int]
                __linkprops__: __lprops__

                def __init__(
                    self,
                    obj: schema.InheritingObject,
                    /,
                    *,
                    index: ___builtins_3__.int | None = None,
                ) -> None:
                    ...

                @classmethod
                def link(
                    cls,
                    obj: schema.InheritingObject,
                    /,
                    *,
                    index: ___builtins_3__.int | None = None,
                ) -> Self:
                    ...

            class ancestors(
                schema.InheritingObject,
                ProxyModel[schema.InheritingObject],
            ):
                """link schema::InheritingObject.ancestors: schema::InheritingObject"""
                class __lprops__(GelLinkModel):
                    class __gel_reflection__(GelLinkModel.__gel_reflection__):
                        id = UUID(int=146784797615199985216077906349193491959)
                        name = SchemaPath('ancestors')
                        @LazyClassProperty["dict[str, GelPointerReflection]"]
                        @classmethod
                        def pointers(cls) -> dict[str, GelPointerReflection]:
                            my_ptrs: dict[str, GelPointerReflection] = {
                                'index': GelPointerReflection(
                                    name='index',
                                    type=SchemaPath('std', 'int64'),
                                    typexpr='std::int64',
                                    kind=PointerKind('Property'),
                                    cardinality=pydantic.Cardinality('AtMostOne'),
                                    computed=False,
                                    readonly=False,
                                    has_default=False,
                                    properties=None,
                                ),
                            }
                            return my_ptrs


                    index: OptionalProperty[___std__.int64, ___builtins_3__.int]
                __linkprops__: __lprops__

                def __init__(
                    self,
                    obj: schema.InheritingObject,
                    /,
                    *,
                    index: ___builtins_3__.int | None = None,
                ) -> None:
                    ...

                @classmethod
                def link(
                    cls,
                    obj: schema.InheritingObject,
                    /,
                    *,
                    index: ___builtins_3__.int | None = None,
                ) -> Self:
                    ...

        if not TYPE_CHECKING:
            @LazyClassProperty[type]
            @classmethod
            def bases(cls) -> type:
                class InheritingObject__bases(
                    ___schema__.InheritingObject,
                    ProxyModel[___schema__.InheritingObject],
                ):
                    """link schema::InheritingObject.bases: schema::InheritingObject"""
                    class __lprops__(GelLinkModel):
                        class __gel_reflection__(
                            GelLinkModel.__gel_reflection__,
                        ):
                            id = UUID(int=103009263448688509382637288792612543583)
                            name = SchemaPath('bases')
                            @LazyClassProperty["dict[str, GelPointerReflection]"]
                            @classmethod
                            def pointers(
                                cls,
                            ) -> dict[str, GelPointerReflection]:
                                my_ptrs: dict[str, GelPointerReflection] = {
                                    'index': GelPointerReflection(
                                        name='index',
                                        type=SchemaPath('std', 'int64'),
                                        typexpr='std::int64',
                                        kind=PointerKind('Property'),
                                        cardinality=pydantic.Cardinality('AtMostOne'),
                                        computed=False,
                                        readonly=False,
                                        has_default=False,
                                        properties=None,
                                    ),
                                }
                                return my_ptrs


                        index: OptionalProperty[std.int64, ___builtins_3__.int]
                    __linkprops__: __lprops__

                    def __init__(self, obj, /, **link_props) -> None:
                        ProxyModel.__init__(self, obj)
                        lprops = self.__class__.__lprops__(**link_props)
                        object.__setattr__(self, "__linkprops__", lprops)

                    @classmethod
                    def link(cls, obj, /, **link_props) -> Self:
                        return cls(obj, **link_props)

                InheritingObject__bases.__name__ = 'bases'
                InheritingObject__bases.__qualname__ = 'InheritingObject.bases'
                return InheritingObject__bases
            @LazyClassProperty[type]
            @classmethod
            def ancestors(cls) -> type:
                class InheritingObject__ancestors(
                    ___schema__.InheritingObject,
                    ProxyModel[___schema__.InheritingObject],
                ):
                    """link schema::InheritingObject.ancestors: schema::InheritingObject"""
                    class __lprops__(GelLinkModel):
                        class __gel_reflection__(
                            GelLinkModel.__gel_reflection__,
                        ):
                            id = UUID(int=146784797615199985216077906349193491959)
                            name = SchemaPath('ancestors')
                            @LazyClassProperty["dict[str, GelPointerReflection]"]
                            @classmethod
                            def pointers(
                                cls,
                            ) -> dict[str, GelPointerReflection]:
                                my_ptrs: dict[str, GelPointerReflection] = {
                                    'index': GelPointerReflection(
                                        name='index',
                                        type=SchemaPath('std', 'int64'),
                                        typexpr='std::int64',
                                        kind=PointerKind('Property'),
                                        cardinality=pydantic.Cardinality('AtMostOne'),
                                        computed=False,
                                        readonly=False,
                                        has_default=False,
                                        properties=None,
                                    ),
                                }
                                return my_ptrs


                        index: OptionalProperty[std.int64, ___builtins_3__.int]
                    __linkprops__: __lprops__

                    def __init__(self, obj, /, **link_props) -> None:
                        ProxyModel.__init__(self, obj)
                        lprops = self.__class__.__lprops__(**link_props)
                        object.__setattr__(self, "__linkprops__", lprops)

                    @classmethod
                    def link(cls, obj, /, **link_props) -> Self:
                        return cls(obj, **link_props)

                InheritingObject__ancestors.__name__ = 'ancestors'
                InheritingObject__ancestors.__qualname__ = 'InheritingObject.ancestors'
                return InheritingObject__ancestors
    class __links_partial__(SubclassableObject.__links_partial__):
        if TYPE_CHECKING:
            class bases(  # type: ignore [misc]
                schema.InheritingObject.__variants__.Partial,
                ProxyModel[schema.InheritingObject.__variants__.Partial],
            ):
                """link schema::InheritingObject.bases: schema::InheritingObject"""
                class __lprops__(GelLinkModel):
                    class __gel_reflection__(GelLinkModel.__gel_reflection__):
                        id = UUID(int=103009263448688509382637288792612543583)
                        name = SchemaPath('bases')
                        @LazyClassProperty["dict[str, GelPointerReflection]"]
                        @classmethod
                        def pointers(cls) -> dict[str, GelPointerReflection]:
                            my_ptrs: dict[str, GelPointerReflection] = {
                                'index': GelPointerReflection(
                                    name='index',
                                    type=SchemaPath('std', 'int64'),
                                    typexpr='std::int64',
                                    kind=PointerKind('Property'),
                                    cardinality=pydantic.Cardinality('AtMostOne'),
                                    computed=False,
                                    readonly=False,
                                    has_default=False,
                                    properties=None,
                                ),
                            }
                            return my_ptrs


                    index: OptionalProperty[___std__.int64, ___builtins_3__.int]
                __linkprops__: __lprops__

                def __init__(
                    self,
                    obj: schema.InheritingObject.__variants__.Partial,
                    /,
                    *,
                    index: ___builtins_3__.int | None = None,
                ) -> None:
                    ...

                @classmethod
                def link(
                    cls,
                    obj: schema.InheritingObject.__variants__.Partial,
                    /,
                    *,
                    index: ___builtins_3__.int | None = None,
                ) -> Self:
                    ...

            class ancestors(  # type: ignore [misc]
                schema.InheritingObject.__variants__.Partial,
                ProxyModel[schema.InheritingObject.__variants__.Partial],
            ):
                """link schema::InheritingObject.ancestors: schema::InheritingObject"""
                class __lprops__(GelLinkModel):
                    class __gel_reflection__(GelLinkModel.__gel_reflection__):
                        id = UUID(int=146784797615199985216077906349193491959)
                        name = SchemaPath('ancestors')
                        @LazyClassProperty["dict[str, GelPointerReflection]"]
                        @classmethod
                        def pointers(cls) -> dict[str, GelPointerReflection]:
                            my_ptrs: dict[str, GelPointerReflection] = {
                                'index': GelPointerReflection(
                                    name='index',
                                    type=SchemaPath('std', 'int64'),
                                    typexpr='std::int64',
                                    kind=PointerKind('Property'),
                                    cardinality=pydantic.Cardinality('AtMostOne'),
                                    computed=False,
                                    readonly=False,
                                    has_default=False,
                                    properties=None,
                                ),
                            }
                            return my_ptrs


                    index: OptionalProperty[___std__.int64, ___builtins_3__.int]
                __linkprops__: __lprops__

                def __init__(
                    self,
                    obj: schema.InheritingObject.__variants__.Partial,
                    /,
                    *,
                    index: ___builtins_3__.int | None = None,
                ) -> None:
                    ...

                @classmethod
                def link(
                    cls,
                    obj: schema.InheritingObject.__variants__.Partial,
                    /,
                    *,
                    index: ___builtins_3__.int | None = None,
                ) -> Self:
                    ...

        if not TYPE_CHECKING:
            @LazyClassProperty[type]
            @classmethod
            def bases(cls) -> type:
                class InheritingObject__bases(  # type: ignore [misc]
                    ___schema__.InheritingObject.__variants__.Partial,
                    ProxyModel[___schema__.InheritingObject.__variants__.Partial],
                ):
                    """link schema::InheritingObject.bases: schema::InheritingObject"""
                    class __lprops__(GelLinkModel):
                        class __gel_reflection__(
                            GelLinkModel.__gel_reflection__,
                        ):
                            id = UUID(int=103009263448688509382637288792612543583)
                            name = SchemaPath('bases')
                            @LazyClassProperty["dict[str, GelPointerReflection]"]
                            @classmethod
                            def pointers(
                                cls,
                            ) -> dict[str, GelPointerReflection]:
                                my_ptrs: dict[str, GelPointerReflection] = {
                                    'index': GelPointerReflection(
                                        name='index',
                                        type=SchemaPath('std', 'int64'),
                                        typexpr='std::int64',
                                        kind=PointerKind('Property'),
                                        cardinality=pydantic.Cardinality('AtMostOne'),
                                        computed=False,
                                        readonly=False,
                                        has_default=False,
                                        properties=None,
                                    ),
                                }
                                return my_ptrs


                        index: OptionalProperty[std.int64, ___builtins_3__.int]
                    __linkprops__: __lprops__

                    def __init__(self, obj, /, **link_props) -> None:
                        ProxyModel.__init__(self, obj)
                        lprops = self.__class__.__lprops__(**link_props)
                        object.__setattr__(self, "__linkprops__", lprops)

                    @classmethod
                    def link(cls, obj, /, **link_props) -> Self:
                        return cls(obj, **link_props)

                InheritingObject__bases.__name__ = 'bases'
                InheritingObject__bases.__qualname__ = 'InheritingObject.bases'
                return InheritingObject__bases
            @LazyClassProperty[type]
            @classmethod
            def ancestors(cls) -> type:
                class InheritingObject__ancestors(  # type: ignore [misc]
                    ___schema__.InheritingObject.__variants__.Partial,
                    ProxyModel[___schema__.InheritingObject.__variants__.Partial],
                ):
                    """link schema::InheritingObject.ancestors: schema::InheritingObject"""
                    class __lprops__(GelLinkModel):
                        class __gel_reflection__(
                            GelLinkModel.__gel_reflection__,
                        ):
                            id = UUID(int=146784797615199985216077906349193491959)
                            name = SchemaPath('ancestors')
                            @LazyClassProperty["dict[str, GelPointerReflection]"]
                            @classmethod
                            def pointers(
                                cls,
                            ) -> dict[str, GelPointerReflection]:
                                my_ptrs: dict[str, GelPointerReflection] = {
                                    'index': GelPointerReflection(
                                        name='index',
                                        type=SchemaPath('std', 'int64'),
                                        typexpr='std::int64',
                                        kind=PointerKind('Property'),
                                        cardinality=pydantic.Cardinality('AtMostOne'),
                                        computed=False,
                                        readonly=False,
                                        has_default=False,
                                        properties=None,
                                    ),
                                }
                                return my_ptrs


                        index: OptionalProperty[std.int64, ___builtins_3__.int]
                    __linkprops__: __lprops__

                    def __init__(self, obj, /, **link_props) -> None:
                        ProxyModel.__init__(self, obj)
                        lprops = self.__class__.__lprops__(**link_props)
                        object.__setattr__(self, "__linkprops__", lprops)

                    @classmethod
                    def link(cls, obj, /, **link_props) -> Self:
                        return cls(obj, **link_props)

                InheritingObject__ancestors.__name__ = 'ancestors'
                InheritingObject__ancestors.__qualname__ = 'InheritingObject.ancestors'
                return InheritingObject__ancestors

if not TYPE_CHECKING:
    InheritingObject.__variants__.Base = InheritingObject



#
# type schema::Type
#
class __Type_typeof_base__(
    __SubclassableObject_typeof_base__,
    __AnnotationSubject_typeof_base__,
):
    class __gel_reflection__(
        __SubclassableObject_typeof_base__.__gel_reflection__,
        __AnnotationSubject_typeof_base__.__gel_reflection__,
    ):
        id = UUID(int=189275509320180683892909643730550477571)
        name = SchemaPath('schema', 'Type')
        @LazyClassProperty["dict[str, GelPointerReflection]"]
        @classmethod
        def pointers(cls) -> dict[str, GelPointerReflection]:
            my_ptrs: dict[str, GelPointerReflection] = {
                'expr': GelPointerReflection(
                    name='expr',
                    type=SchemaPath('std', 'str'),
                    typexpr='std::str',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
                'from_alias': GelPointerReflection(
                    name='from_alias',
                    type=SchemaPath('std', 'bool'),
                    typexpr='std::bool',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
                'is_from_alias': GelPointerReflection(
                    name='is_from_alias',
                    type=SchemaPath('std', 'bool'),
                    typexpr='std::bool',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=True,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
            }
            return (
                my_ptrs
                | __SubclassableObject_typeof_base__.__gel_reflection__.pointers
                | __AnnotationSubject_typeof_base__.__gel_reflection__.pointers
            )

        @LazyClassProperty["schema.ObjectType"]
        @classmethod
        def object(cls) -> schema.ObjectType:
            from ... import schema as ___schema_1__
            return ___schema_1__.ObjectType(
                id=UUID(int=189275509320180683892909643730550477571),
                name='schema::Type',
                builtin=True,
                internal=False,
                abstract=True,
                final=False,
                compound_type=False,
            )

class __Type_typeof__(
    __SubclassableObject_typeof__,
    __AnnotationSubject_typeof__,
    __Type_typeof_base__,
):
    class __typeof__(
        __SubclassableObject_typeof__.__typeof__,
        __AnnotationSubject_typeof__.__typeof__,
    ):
        expr = TypeAliasType('expr', 'OptionalProperty[std.str, builtins.str]')
        from_alias = TypeAliasType('from_alias', 'OptionalProperty[std.bool, bool]')
        is_from_alias = TypeAliasType('is_from_alias', 'OptionalComputedProperty[std.bool, bool]')


class __Type_typeof_partial__(
    __SubclassableObject_typeof_partial__,
    __AnnotationSubject_typeof_partial__,
    __Type_typeof_base__,
):
    class __typeof__(
        __SubclassableObject_typeof_partial__.__typeof__,
        __AnnotationSubject_typeof_partial__.__typeof__,
    ):
        expr = TypeAliasType('expr', 'OptionalProperty[std.str, builtins.str]')
        from_alias = TypeAliasType('from_alias', 'OptionalProperty[std.bool, bool]')
        is_from_alias = TypeAliasType('is_from_alias', 'OptionalComputedProperty[std.bool, bool]')


class Type(
    __Type_typeof__,
    SubclassableObject,
    AnnotationSubject,
    __gel_type_id__=UUID(int=189275509320180683892909643730550477571),
):
    if TYPE_CHECKING:
        def __init__(
            self,
            /,
            *,
            id: UUID | DefaultValue = DEFAULT_VALUE,
            name: builtins.str,
            internal: bool | DefaultValue = DEFAULT_VALUE,
            builtin: bool | DefaultValue = DEFAULT_VALUE,
            computed_fields: list[builtins.str] | None = None,
            annotations: Iterable[Annotation] = [],
            abstract: bool | None | DefaultValue = DEFAULT_VALUE,
            final: bool,
            expr: builtins.str | None = None,
            from_alias: bool | None = None,
        ) -> None:
            """Create a new schema::Type instance from keyword arguments.

            Call db.save() on the returned object to persist it in the database.
            """
            ...

    if TYPE_CHECKING:
        @classmethod
        def update(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
            abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            from_alias: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Update schema::Type instances in the database.
            """
            ...

        @classmethod
        def select(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: PathAlias | Literal["*"],
            id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Annotation] | UnspecifiedType = Unspecified,
            abstract: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            final: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            expr: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            from_alias: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
        ) -> type[Self]:
            """Fetch schema::Type instances from the database.
            """
            ...

        @classmethod
        def filter(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], type[___std__.bool]],
            id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
            abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            final: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            from_alias: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Fetch schema::Type instances from the database.
            """
            ...

        @classmethod
        def order_by(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
            id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            abstract: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            final: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            expr: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            from_alias: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Specify the sort order for the selection"""
            ...


    class __variants__(
        SubclassableObject.__variants__,
        AnnotationSubject.__variants__,
    ):
        class Base(
            __Type_typeof__,
            SubclassableObject.__variants__.Base,
            AnnotationSubject.__variants__.Base,
            __gel_variant__="Base",
        ):
            if TYPE_CHECKING:
                def __init__(
                    self,
                    /,
                    *,
                    id: UUID | DefaultValue = DEFAULT_VALUE,
                    name: builtins.str,
                    internal: bool | DefaultValue = DEFAULT_VALUE,
                    builtin: bool | DefaultValue = DEFAULT_VALUE,
                    computed_fields: list[builtins.str] | None = None,
                    annotations: Iterable[Annotation] = [],
                    abstract: bool | None | DefaultValue = DEFAULT_VALUE,
                    final: bool,
                    expr: builtins.str | None = None,
                    from_alias: bool | None = None,
                ) -> None:
                    """Create a new schema::Type instance from keyword arguments.

                    Call db.save() on the returned object to persist it in the database.
                    """
                    ...

            if TYPE_CHECKING:
                @classmethod
                def update(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
                    abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    from_alias: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Update schema::Type instances in the database.
                    """
                    ...

                @classmethod
                def select(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: PathAlias | Literal["*"],
                    id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Annotation] | UnspecifiedType = Unspecified,
                    abstract: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    final: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    expr: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    from_alias: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
                ) -> type[Self]:
                    """Fetch schema::Type instances from the database.
                    """
                    ...

                @classmethod
                def filter(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], type[___std__.bool]],
                    id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
                    abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    final: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    from_alias: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Fetch schema::Type instances from the database.
                    """
                    ...

                @classmethod
                def order_by(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
                    id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    abstract: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    final: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    expr: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    from_alias: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Specify the sort order for the selection"""
                    ...

        class Required(
            Base,
            SubclassableObject.__variants__.Required,
            AnnotationSubject.__variants__.Required,
            __gel_variant__="Required",
        ):
            pass

        class PartialBase(  # type: ignore [misc, unused-ignore]
            __Type_typeof_partial__,
            Base,
            SubclassableObject.__variants__.PartialBase,
            AnnotationSubject.__variants__.PartialBase,
            __gel_variant__="PartialBase",
        ):
            pass

        class Partial(  # type: ignore [misc, unused-ignore]
            PartialBase,
            SubclassableObject.__variants__.Partial,
            AnnotationSubject.__variants__.Partial,
            __gel_variant__="Partial",
        ):
            expr: OptionalProperty[std.str, builtins.str]
            from_alias: OptionalProperty[std.bool, bool]


        Any = TypeVar("Any", bound="Type | Base | Required | Partial")
    class __links__(SubclassableObject.__links__, AnnotationSubject.__links__):
        pass
    class __links_partial__(
        SubclassableObject.__links_partial__,
        AnnotationSubject.__links_partial__,
    ):
        pass

if not TYPE_CHECKING:
    Type.__variants__.Base = Type



#
# type schema::Cast
#
class __Cast_typeof_base__(
    __AnnotationSubject_typeof_base__,
    __VolatilitySubject_typeof_base__,
):
    class __gel_reflection__(
        __AnnotationSubject_typeof_base__.__gel_reflection__,
        __VolatilitySubject_typeof_base__.__gel_reflection__,
    ):
        id = UUID(int=57352927458738121887507744293380160895)
        name = SchemaPath('schema', 'Cast')
        @LazyClassProperty["dict[str, GelPointerReflection]"]
        @classmethod
        def pointers(cls) -> dict[str, GelPointerReflection]:
            my_ptrs: dict[str, GelPointerReflection] = {
                'allow_implicit': GelPointerReflection(
                    name='allow_implicit',
                    type=SchemaPath('std', 'bool'),
                    typexpr='std::bool',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
                'allow_assignment': GelPointerReflection(
                    name='allow_assignment',
                    type=SchemaPath('std', 'bool'),
                    typexpr='std::bool',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
                'from_type': GelPointerReflection(
                    name='from_type',
                    type=SchemaPath('schema', 'Type'),
                    typexpr='schema::Type',
                    kind=PointerKind('Link'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
                'to_type': GelPointerReflection(
                    name='to_type',
                    type=SchemaPath('schema', 'Type'),
                    typexpr='schema::Type',
                    kind=PointerKind('Link'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
            }
            return (
                my_ptrs
                | __AnnotationSubject_typeof_base__.__gel_reflection__.pointers
                | __VolatilitySubject_typeof_base__.__gel_reflection__.pointers
            )

        @LazyClassProperty["schema.ObjectType"]
        @classmethod
        def object(cls) -> schema.ObjectType:
            from ... import schema as ___schema_1__
            return ___schema_1__.ObjectType(
                id=UUID(int=57352927458738121887507744293380160895),
                name='schema::Cast',
                builtin=True,
                internal=False,
                abstract=False,
                final=False,
                compound_type=False,
            )

class __Cast_typeof__(
    __AnnotationSubject_typeof__,
    __VolatilitySubject_typeof__,
    __Cast_typeof_base__,
):
    class __typeof__(
        __AnnotationSubject_typeof__.__typeof__,
        __VolatilitySubject_typeof__.__typeof__,
    ):
        allow_implicit = TypeAliasType('allow_implicit', 'OptionalProperty[std.bool, bool]')
        allow_assignment = TypeAliasType('allow_assignment', 'OptionalProperty[std.bool, bool]')
        from_type = TypeAliasType('from_type', 'OptionalLink[Type]')
        to_type = TypeAliasType('to_type', 'OptionalLink[Type]')


class __Cast_typeof_partial__(
    __AnnotationSubject_typeof_partial__,
    __VolatilitySubject_typeof_partial__,
    __Cast_typeof_base__,
):
    class __typeof__(
        __AnnotationSubject_typeof_partial__.__typeof__,
        __VolatilitySubject_typeof_partial__.__typeof__,
    ):
        allow_implicit = TypeAliasType('allow_implicit', 'OptionalProperty[std.bool, bool]')
        allow_assignment = TypeAliasType('allow_assignment', 'OptionalProperty[std.bool, bool]')
        from_type = TypeAliasType('from_type', 'OptionalLink[Type | Type.__variants__.Partial]')
        to_type = TypeAliasType('to_type', 'OptionalLink[Type | Type.__variants__.Partial]')


class Cast(
    __Cast_typeof__,
    AnnotationSubject,
    VolatilitySubject,
    __gel_type_id__=UUID(int=57352927458738121887507744293380160895),
):
    if TYPE_CHECKING:
        def __init__(
            self,
            /,
            *,
            id: UUID | DefaultValue = DEFAULT_VALUE,
            name: builtins.str,
            internal: bool | DefaultValue = DEFAULT_VALUE,
            builtin: bool | DefaultValue = DEFAULT_VALUE,
            computed_fields: list[builtins.str] | None = None,
            volatility: ___builtins_1__.str | None | DefaultValue = DEFAULT_VALUE,
            annotations: Iterable[Annotation] = [],
            allow_implicit: bool | None = None,
            allow_assignment: bool | None = None,
            from_type: Type | None = None,
            to_type: Type | None = None,
        ) -> None:
            """Create a new schema::Cast instance from keyword arguments.

            Call db.save() on the returned object to persist it in the database.
            """
            ...

    if TYPE_CHECKING:
        @classmethod
        def update(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            volatility: type[Volatility] | UnspecifiedType = Unspecified,
            annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
            allow_implicit: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            allow_assignment: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            from_type: type[schema.Type] | UnspecifiedType = Unspecified,
            to_type: type[schema.Type] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Update schema::Cast instances in the database.
            """
            ...

        @classmethod
        def select(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: PathAlias | Literal["*"],
            id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            volatility: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[Volatility] | UnspecifiedType = Unspecified,
            annotations: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Annotation] | UnspecifiedType = Unspecified,
            allow_implicit: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            allow_assignment: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            from_type: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Type] | UnspecifiedType = Unspecified,
            to_type: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Type] | UnspecifiedType = Unspecified,
            **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
        ) -> type[Self]:
            """Fetch schema::Cast instances from the database.
            """
            ...

        @classmethod
        def filter(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], type[___std__.bool]],
            id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            volatility: type[Volatility] | UnspecifiedType = Unspecified,
            annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
            allow_implicit: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            allow_assignment: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            from_type: type[schema.Type] | UnspecifiedType = Unspecified,
            to_type: type[schema.Type] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Fetch schema::Cast instances from the database.
            """
            ...

        @classmethod
        def order_by(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
            id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            allow_implicit: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            allow_assignment: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Specify the sort order for the selection"""
            ...


    class __variants__(
        AnnotationSubject.__variants__,
        VolatilitySubject.__variants__,
    ):
        class Base(
            __Cast_typeof__,
            AnnotationSubject.__variants__.Base,
            VolatilitySubject.__variants__.Base,
            __gel_variant__="Base",
        ):
            if TYPE_CHECKING:
                def __init__(
                    self,
                    /,
                    *,
                    id: UUID | DefaultValue = DEFAULT_VALUE,
                    name: builtins.str,
                    internal: bool | DefaultValue = DEFAULT_VALUE,
                    builtin: bool | DefaultValue = DEFAULT_VALUE,
                    computed_fields: list[builtins.str] | None = None,
                    volatility: ___builtins_1__.str | None | DefaultValue = DEFAULT_VALUE,
                    annotations: Iterable[Annotation] = [],
                    allow_implicit: bool | None = None,
                    allow_assignment: bool | None = None,
                    from_type: Type | None = None,
                    to_type: Type | None = None,
                ) -> None:
                    """Create a new schema::Cast instance from keyword arguments.

                    Call db.save() on the returned object to persist it in the database.
                    """
                    ...

            if TYPE_CHECKING:
                @classmethod
                def update(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    volatility: type[Volatility] | UnspecifiedType = Unspecified,
                    annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
                    allow_implicit: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    allow_assignment: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    from_type: type[schema.Type] | UnspecifiedType = Unspecified,
                    to_type: type[schema.Type] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Update schema::Cast instances in the database.
                    """
                    ...

                @classmethod
                def select(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: PathAlias | Literal["*"],
                    id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    volatility: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[Volatility] | UnspecifiedType = Unspecified,
                    annotations: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Annotation] | UnspecifiedType = Unspecified,
                    allow_implicit: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    allow_assignment: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    from_type: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Type] | UnspecifiedType = Unspecified,
                    to_type: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Type] | UnspecifiedType = Unspecified,
                    **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
                ) -> type[Self]:
                    """Fetch schema::Cast instances from the database.
                    """
                    ...

                @classmethod
                def filter(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], type[___std__.bool]],
                    id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    volatility: type[Volatility] | UnspecifiedType = Unspecified,
                    annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
                    allow_implicit: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    allow_assignment: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    from_type: type[schema.Type] | UnspecifiedType = Unspecified,
                    to_type: type[schema.Type] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Fetch schema::Cast instances from the database.
                    """
                    ...

                @classmethod
                def order_by(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
                    id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    allow_implicit: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    allow_assignment: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Specify the sort order for the selection"""
                    ...

        class Required(
            Base,
            AnnotationSubject.__variants__.Required,
            VolatilitySubject.__variants__.Required,
            __gel_variant__="Required",
        ):
            pass

        class PartialBase(  # type: ignore [misc, unused-ignore]
            __Cast_typeof_partial__,
            Base,
            AnnotationSubject.__variants__.PartialBase,
            VolatilitySubject.__variants__.PartialBase,
            __gel_variant__="PartialBase",
        ):
            pass

        class Partial(  # type: ignore [misc, unused-ignore]
            PartialBase,
            AnnotationSubject.__variants__.Partial,
            VolatilitySubject.__variants__.Partial,
            __gel_variant__="Partial",
        ):
            allow_implicit: OptionalProperty[std.bool, bool]
            allow_assignment: OptionalProperty[std.bool, bool]
            from_type: OptionalLink[___schema__.Type | ___schema__.Type.__variants__.Partial]
            to_type: OptionalLink[___schema__.Type | ___schema__.Type.__variants__.Partial]


        Any = TypeVar("Any", bound="Cast | Base | Required | Partial")
    class __links__(AnnotationSubject.__links__, VolatilitySubject.__links__):
        pass
    class __links_partial__(
        AnnotationSubject.__links_partial__,
        VolatilitySubject.__links_partial__,
    ):
        pass

if not TYPE_CHECKING:
    Cast.__variants__.Base = Cast



#
# type schema::Function
#
class __Function_typeof_base__(
    __CallableObject_typeof_base__,
    __VolatilitySubject_typeof_base__,
):
    class __gel_reflection__(
        __CallableObject_typeof_base__.__gel_reflection__,
        __VolatilitySubject_typeof_base__.__gel_reflection__,
    ):
        id = UUID(int=77598660217071330185177185139856935407)
        name = SchemaPath('schema', 'Function')
        @LazyClassProperty["dict[str, GelPointerReflection]"]
        @classmethod
        def pointers(cls) -> dict[str, GelPointerReflection]:
            my_ptrs: dict[str, GelPointerReflection] = {
                'preserves_optionality': GelPointerReflection(
                    name='preserves_optionality',
                    type=SchemaPath('std', 'bool'),
                    typexpr='std::bool',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=True,
                    properties={},
                ),
                'body': GelPointerReflection(
                    name='body',
                    type=SchemaPath('std', 'str'),
                    typexpr='std::str',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
                'language': GelPointerReflection(
                    name='language',
                    type=SchemaPath('std', 'str'),
                    typexpr='std::str',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('One'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
                'used_globals': GelPointerReflection(
                    name='used_globals',
                    type=SchemaPath('schema', 'Global'),
                    typexpr='schema::`Global`',
                    kind=PointerKind('Link'),
                    cardinality=pydantic.Cardinality('Many'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={
                    'index': GelPointerReflection(
                    name='index',
                    type=SchemaPath('std', 'int64'),
                    typexpr='std::int64',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties=None,
                ),
                },
                ),
            }
            return (
                my_ptrs
                | __CallableObject_typeof_base__.__gel_reflection__.pointers
                | __VolatilitySubject_typeof_base__.__gel_reflection__.pointers
            )

        @LazyClassProperty["schema.ObjectType"]
        @classmethod
        def object(cls) -> schema.ObjectType:
            from ... import schema as ___schema_1__
            return ___schema_1__.ObjectType(
                id=UUID(int=77598660217071330185177185139856935407),
                name='schema::Function',
                builtin=True,
                internal=False,
                abstract=False,
                final=False,
                compound_type=False,
            )

class __Function_typeof__(
    __CallableObject_typeof__,
    __VolatilitySubject_typeof__,
    __Function_typeof_base__,
):
    class __typeof__(
        __CallableObject_typeof__.__typeof__,
        __VolatilitySubject_typeof__.__typeof__,
    ):
        preserves_optionality = TypeAliasType('preserves_optionality', 'OptionalProperty[std.bool, bool]')
        body = TypeAliasType('body', 'OptionalProperty[std.str, builtins.str]')
        language = TypeAliasType('language', 'std.str')
        used_globals = TypeAliasType('used_globals', 'MultiLinkWithProps[Function.__links__.used_globals, Global]')


class __Function_typeof_partial__(
    __CallableObject_typeof_partial__,
    __VolatilitySubject_typeof_partial__,
    __Function_typeof_base__,
):
    class __typeof__(
        __CallableObject_typeof_partial__.__typeof__,
        __VolatilitySubject_typeof_partial__.__typeof__,
    ):
        preserves_optionality = TypeAliasType('preserves_optionality', 'OptionalProperty[std.bool, bool]')
        body = TypeAliasType('body', 'OptionalProperty[std.str, builtins.str]')
        language = TypeAliasType('language', 'OptionalProperty[std.str, builtins.str]')
        used_globals = TypeAliasType('used_globals', 'MultiLinkWithProps[Function.__links__.used_globals | Function.__links_partial__.used_globals, Global]')


class Function(
    __Function_typeof__,
    CallableObject,
    VolatilitySubject,
    __gel_type_id__=UUID(int=77598660217071330185177185139856935407),
):
    if TYPE_CHECKING:
        def __init__(
            self,
            /,
            *,
            id: UUID | DefaultValue = DEFAULT_VALUE,
            name: builtins.str,
            internal: bool | DefaultValue = DEFAULT_VALUE,
            builtin: bool | DefaultValue = DEFAULT_VALUE,
            computed_fields: list[builtins.str] | None = None,
            volatility: ___builtins_1__.str | None | DefaultValue = DEFAULT_VALUE,
            annotations: Iterable[Annotation] = [],
            return_typemod: ___builtins_1__.str | None = None,
            params: Iterable[Parameter] = [],
            return_type: Type | None = None,
            preserves_optionality: bool | None | DefaultValue = DEFAULT_VALUE,
            body: builtins.str | None = None,
            language: builtins.str,
            used_globals: Iterable[Global] = [],
        ) -> None:
            """Create a new schema::Function instance from keyword arguments.

            Call db.save() on the returned object to persist it in the database.
            """
            ...

    if TYPE_CHECKING:
        @classmethod
        def update(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            volatility: type[Volatility] | UnspecifiedType = Unspecified,
            annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
            return_typemod: type[TypeModifier] | UnspecifiedType = Unspecified,
            params: type[schema.Parameter] | UnspecifiedType = Unspecified,
            return_type: type[schema.Type] | UnspecifiedType = Unspecified,
            preserves_optionality: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            body: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            language: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            used_globals: type[schema.Global] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Update schema::Function instances in the database.
            """
            ...

        @classmethod
        def select(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: PathAlias | Literal["*"],
            id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            volatility: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[Volatility] | UnspecifiedType = Unspecified,
            annotations: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Annotation] | UnspecifiedType = Unspecified,
            return_typemod: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[TypeModifier] | UnspecifiedType = Unspecified,
            params: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Parameter] | UnspecifiedType = Unspecified,
            return_type: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Type] | UnspecifiedType = Unspecified,
            preserves_optionality: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            body: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            language: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            used_globals: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Global] | UnspecifiedType = Unspecified,
            **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
        ) -> type[Self]:
            """Fetch schema::Function instances from the database.
            """
            ...

        @classmethod
        def filter(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], type[___std__.bool]],
            id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            volatility: type[Volatility] | UnspecifiedType = Unspecified,
            annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
            return_typemod: type[TypeModifier] | UnspecifiedType = Unspecified,
            params: type[schema.Parameter] | UnspecifiedType = Unspecified,
            return_type: type[schema.Type] | UnspecifiedType = Unspecified,
            preserves_optionality: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            body: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            language: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            used_globals: type[schema.Global] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Fetch schema::Function instances from the database.
            """
            ...

        @classmethod
        def order_by(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
            id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            preserves_optionality: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            body: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            language: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Specify the sort order for the selection"""
            ...


    class __variants__(
        CallableObject.__variants__,
        VolatilitySubject.__variants__,
    ):
        class Base(
            __Function_typeof__,
            CallableObject.__variants__.Base,
            VolatilitySubject.__variants__.Base,
            __gel_variant__="Base",
        ):
            if TYPE_CHECKING:
                def __init__(
                    self,
                    /,
                    *,
                    id: UUID | DefaultValue = DEFAULT_VALUE,
                    name: builtins.str,
                    internal: bool | DefaultValue = DEFAULT_VALUE,
                    builtin: bool | DefaultValue = DEFAULT_VALUE,
                    computed_fields: list[builtins.str] | None = None,
                    volatility: ___builtins_1__.str | None | DefaultValue = DEFAULT_VALUE,
                    annotations: Iterable[Annotation] = [],
                    return_typemod: ___builtins_1__.str | None = None,
                    params: Iterable[Parameter] = [],
                    return_type: Type | None = None,
                    preserves_optionality: bool | None | DefaultValue = DEFAULT_VALUE,
                    body: builtins.str | None = None,
                    language: builtins.str,
                    used_globals: Iterable[Global] = [],
                ) -> None:
                    """Create a new schema::Function instance from keyword arguments.

                    Call db.save() on the returned object to persist it in the database.
                    """
                    ...

            if TYPE_CHECKING:
                @classmethod
                def update(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    volatility: type[Volatility] | UnspecifiedType = Unspecified,
                    annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
                    return_typemod: type[TypeModifier] | UnspecifiedType = Unspecified,
                    params: type[schema.Parameter] | UnspecifiedType = Unspecified,
                    return_type: type[schema.Type] | UnspecifiedType = Unspecified,
                    preserves_optionality: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    body: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    language: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    used_globals: type[schema.Global] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Update schema::Function instances in the database.
                    """
                    ...

                @classmethod
                def select(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: PathAlias | Literal["*"],
                    id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    volatility: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[Volatility] | UnspecifiedType = Unspecified,
                    annotations: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Annotation] | UnspecifiedType = Unspecified,
                    return_typemod: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[TypeModifier] | UnspecifiedType = Unspecified,
                    params: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Parameter] | UnspecifiedType = Unspecified,
                    return_type: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Type] | UnspecifiedType = Unspecified,
                    preserves_optionality: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    body: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    language: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    used_globals: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Global] | UnspecifiedType = Unspecified,
                    **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
                ) -> type[Self]:
                    """Fetch schema::Function instances from the database.
                    """
                    ...

                @classmethod
                def filter(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], type[___std__.bool]],
                    id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    volatility: type[Volatility] | UnspecifiedType = Unspecified,
                    annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
                    return_typemod: type[TypeModifier] | UnspecifiedType = Unspecified,
                    params: type[schema.Parameter] | UnspecifiedType = Unspecified,
                    return_type: type[schema.Type] | UnspecifiedType = Unspecified,
                    preserves_optionality: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    body: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    language: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    used_globals: type[schema.Global] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Fetch schema::Function instances from the database.
                    """
                    ...

                @classmethod
                def order_by(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
                    id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    preserves_optionality: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    body: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    language: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Specify the sort order for the selection"""
                    ...

        class Required(
            Base,
            CallableObject.__variants__.Required,
            VolatilitySubject.__variants__.Required,
            __gel_variant__="Required",
        ):
            language: std.str

        class PartialBase(  # type: ignore [misc, unused-ignore]
            __Function_typeof_partial__,
            Base,
            CallableObject.__variants__.PartialBase,
            VolatilitySubject.__variants__.PartialBase,
            __gel_variant__="PartialBase",
        ):
            pass

        class Partial(  # type: ignore [misc, unused-ignore]
            PartialBase,
            CallableObject.__variants__.Partial,
            VolatilitySubject.__variants__.Partial,
            __gel_variant__="Partial",
        ):
            preserves_optionality: OptionalProperty[std.bool, bool]
            body: OptionalProperty[std.str, builtins.str]
            language: OptionalProperty[std.str, builtins.str]
            used_globals: MultiLinkWithProps[Function.__links__.used_globals | Function.__links_partial__.used_globals, ___schema__.Global]


        Any = TypeVar("Any", bound="Function | Base | Required | Partial")
    class __links__(CallableObject.__links__, VolatilitySubject.__links__):
        if TYPE_CHECKING:
            class used_globals(schema.Global, ProxyModel[schema.Global]):
                """link schema::Function.used_globals: schema::Global"""
                class __lprops__(GelLinkModel):
                    class __gel_reflection__(GelLinkModel.__gel_reflection__):
                        id = UUID(int=207628291052703181045372163498338108925)
                        name = SchemaPath('used_globals')
                        @LazyClassProperty["dict[str, GelPointerReflection]"]
                        @classmethod
                        def pointers(cls) -> dict[str, GelPointerReflection]:
                            my_ptrs: dict[str, GelPointerReflection] = {
                                'index': GelPointerReflection(
                                    name='index',
                                    type=SchemaPath('std', 'int64'),
                                    typexpr='std::int64',
                                    kind=PointerKind('Property'),
                                    cardinality=pydantic.Cardinality('AtMostOne'),
                                    computed=False,
                                    readonly=False,
                                    has_default=False,
                                    properties=None,
                                ),
                            }
                            return my_ptrs


                    index: OptionalProperty[___std__.int64, ___builtins_3__.int]
                __linkprops__: __lprops__

                def __init__(
                    self,
                    obj: schema.Global,
                    /,
                    *,
                    index: ___builtins_3__.int | None = None,
                ) -> None:
                    ...

                @classmethod
                def link(
                    cls,
                    obj: schema.Global,
                    /,
                    *,
                    index: ___builtins_3__.int | None = None,
                ) -> Self:
                    ...

        if not TYPE_CHECKING:
            @LazyClassProperty[type]
            @classmethod
            def used_globals(cls) -> type:
                class Function__used_globals(
                    ___schema__.Global,
                    ProxyModel[___schema__.Global],
                ):
                    """link schema::Function.used_globals: schema::Global"""
                    class __lprops__(GelLinkModel):
                        class __gel_reflection__(
                            GelLinkModel.__gel_reflection__,
                        ):
                            id = UUID(int=207628291052703181045372163498338108925)
                            name = SchemaPath('used_globals')
                            @LazyClassProperty["dict[str, GelPointerReflection]"]
                            @classmethod
                            def pointers(
                                cls,
                            ) -> dict[str, GelPointerReflection]:
                                my_ptrs: dict[str, GelPointerReflection] = {
                                    'index': GelPointerReflection(
                                        name='index',
                                        type=SchemaPath('std', 'int64'),
                                        typexpr='std::int64',
                                        kind=PointerKind('Property'),
                                        cardinality=pydantic.Cardinality('AtMostOne'),
                                        computed=False,
                                        readonly=False,
                                        has_default=False,
                                        properties=None,
                                    ),
                                }
                                return my_ptrs


                        index: OptionalProperty[std.int64, ___builtins_3__.int]
                    __linkprops__: __lprops__

                    def __init__(self, obj, /, **link_props) -> None:
                        ProxyModel.__init__(self, obj)
                        lprops = self.__class__.__lprops__(**link_props)
                        object.__setattr__(self, "__linkprops__", lprops)

                    @classmethod
                    def link(cls, obj, /, **link_props) -> Self:
                        return cls(obj, **link_props)

                Function__used_globals.__name__ = 'used_globals'
                Function__used_globals.__qualname__ = 'Function.used_globals'
                return Function__used_globals
    class __links_partial__(
        CallableObject.__links_partial__,
        VolatilitySubject.__links_partial__,
    ):
        if TYPE_CHECKING:
            class used_globals(  # type: ignore [misc]
                schema.Global.__variants__.Partial,
                ProxyModel[schema.Global.__variants__.Partial],
            ):
                """link schema::Function.used_globals: schema::Global"""
                class __lprops__(GelLinkModel):
                    class __gel_reflection__(GelLinkModel.__gel_reflection__):
                        id = UUID(int=207628291052703181045372163498338108925)
                        name = SchemaPath('used_globals')
                        @LazyClassProperty["dict[str, GelPointerReflection]"]
                        @classmethod
                        def pointers(cls) -> dict[str, GelPointerReflection]:
                            my_ptrs: dict[str, GelPointerReflection] = {
                                'index': GelPointerReflection(
                                    name='index',
                                    type=SchemaPath('std', 'int64'),
                                    typexpr='std::int64',
                                    kind=PointerKind('Property'),
                                    cardinality=pydantic.Cardinality('AtMostOne'),
                                    computed=False,
                                    readonly=False,
                                    has_default=False,
                                    properties=None,
                                ),
                            }
                            return my_ptrs


                    index: OptionalProperty[___std__.int64, ___builtins_3__.int]
                __linkprops__: __lprops__

                def __init__(
                    self,
                    obj: schema.Global.__variants__.Partial,
                    /,
                    *,
                    index: ___builtins_3__.int | None = None,
                ) -> None:
                    ...

                @classmethod
                def link(
                    cls,
                    obj: schema.Global.__variants__.Partial,
                    /,
                    *,
                    index: ___builtins_3__.int | None = None,
                ) -> Self:
                    ...

        if not TYPE_CHECKING:
            @LazyClassProperty[type]
            @classmethod
            def used_globals(cls) -> type:
                class Function__used_globals(  # type: ignore [misc]
                    ___schema__.Global.__variants__.Partial,
                    ProxyModel[___schema__.Global.__variants__.Partial],
                ):
                    """link schema::Function.used_globals: schema::Global"""
                    class __lprops__(GelLinkModel):
                        class __gel_reflection__(
                            GelLinkModel.__gel_reflection__,
                        ):
                            id = UUID(int=207628291052703181045372163498338108925)
                            name = SchemaPath('used_globals')
                            @LazyClassProperty["dict[str, GelPointerReflection]"]
                            @classmethod
                            def pointers(
                                cls,
                            ) -> dict[str, GelPointerReflection]:
                                my_ptrs: dict[str, GelPointerReflection] = {
                                    'index': GelPointerReflection(
                                        name='index',
                                        type=SchemaPath('std', 'int64'),
                                        typexpr='std::int64',
                                        kind=PointerKind('Property'),
                                        cardinality=pydantic.Cardinality('AtMostOne'),
                                        computed=False,
                                        readonly=False,
                                        has_default=False,
                                        properties=None,
                                    ),
                                }
                                return my_ptrs


                        index: OptionalProperty[std.int64, ___builtins_3__.int]
                    __linkprops__: __lprops__

                    def __init__(self, obj, /, **link_props) -> None:
                        ProxyModel.__init__(self, obj)
                        lprops = self.__class__.__lprops__(**link_props)
                        object.__setattr__(self, "__linkprops__", lprops)

                    @classmethod
                    def link(cls, obj, /, **link_props) -> Self:
                        return cls(obj, **link_props)

                Function__used_globals.__name__ = 'used_globals'
                Function__used_globals.__qualname__ = 'Function.used_globals'
                return Function__used_globals

if not TYPE_CHECKING:
    Function.__variants__.Base = Function



#
# type schema::Operator
#
class __Operator_typeof_base__(
    __CallableObject_typeof_base__,
    __VolatilitySubject_typeof_base__,
):
    class __gel_reflection__(
        __CallableObject_typeof_base__.__gel_reflection__,
        __VolatilitySubject_typeof_base__.__gel_reflection__,
    ):
        id = UUID(int=302377796033846204813264836927507411646)
        name = SchemaPath('schema', 'Operator')
        @LazyClassProperty["dict[str, GelPointerReflection]"]
        @classmethod
        def pointers(cls) -> dict[str, GelPointerReflection]:
            my_ptrs: dict[str, GelPointerReflection] = {
                'operator_kind': GelPointerReflection(
                    name='operator_kind',
                    type=SchemaPath('schema', 'OperatorKind'),
                    typexpr='schema::OperatorKind',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
                'is_abstract': GelPointerReflection(
                    name='is_abstract',
                    type=SchemaPath('std', 'bool'),
                    typexpr='std::bool',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=True,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
                'abstract': GelPointerReflection(
                    name='abstract',
                    type=SchemaPath('std', 'bool'),
                    typexpr='std::bool',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=True,
                    properties={},
                ),
            }
            return (
                my_ptrs
                | __CallableObject_typeof_base__.__gel_reflection__.pointers
                | __VolatilitySubject_typeof_base__.__gel_reflection__.pointers
            )

        @LazyClassProperty["schema.ObjectType"]
        @classmethod
        def object(cls) -> schema.ObjectType:
            from ... import schema as ___schema_1__
            return ___schema_1__.ObjectType(
                id=UUID(int=302377796033846204813264836927507411646),
                name='schema::Operator',
                builtin=True,
                internal=False,
                abstract=False,
                final=False,
                compound_type=False,
            )

class __Operator_typeof__(
    __CallableObject_typeof__,
    __VolatilitySubject_typeof__,
    __Operator_typeof_base__,
):
    class __typeof__(
        __CallableObject_typeof__.__typeof__,
        __VolatilitySubject_typeof__.__typeof__,
    ):
        operator_kind = TypeAliasType('operator_kind', 'OptionalProperty[OperatorKind, ___builtins_1__.str]')
        is_abstract = TypeAliasType('is_abstract', 'OptionalComputedProperty[std.bool, bool]')
        abstract = TypeAliasType('abstract', 'OptionalProperty[std.bool, bool]')


class __Operator_typeof_partial__(
    __CallableObject_typeof_partial__,
    __VolatilitySubject_typeof_partial__,
    __Operator_typeof_base__,
):
    class __typeof__(
        __CallableObject_typeof_partial__.__typeof__,
        __VolatilitySubject_typeof_partial__.__typeof__,
    ):
        operator_kind = TypeAliasType('operator_kind', 'OptionalProperty[OperatorKind, ___builtins_1__.str]')
        is_abstract = TypeAliasType('is_abstract', 'OptionalComputedProperty[std.bool, bool]')
        abstract = TypeAliasType('abstract', 'OptionalProperty[std.bool, bool]')


class Operator(
    __Operator_typeof__,
    CallableObject,
    VolatilitySubject,
    __gel_type_id__=UUID(int=302377796033846204813264836927507411646),
):
    if TYPE_CHECKING:
        def __init__(
            self,
            /,
            *,
            id: UUID | DefaultValue = DEFAULT_VALUE,
            name: builtins.str,
            internal: bool | DefaultValue = DEFAULT_VALUE,
            builtin: bool | DefaultValue = DEFAULT_VALUE,
            computed_fields: list[builtins.str] | None = None,
            volatility: ___builtins_1__.str | None | DefaultValue = DEFAULT_VALUE,
            annotations: Iterable[Annotation] = [],
            return_typemod: ___builtins_1__.str | None = None,
            params: Iterable[Parameter] = [],
            return_type: Type | None = None,
            operator_kind: ___builtins_1__.str | None = None,
            abstract: bool | None | DefaultValue = DEFAULT_VALUE,
        ) -> None:
            """Create a new schema::Operator instance from keyword arguments.

            Call db.save() on the returned object to persist it in the database.
            """
            ...

    if TYPE_CHECKING:
        @classmethod
        def update(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            volatility: type[Volatility] | UnspecifiedType = Unspecified,
            annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
            return_typemod: type[TypeModifier] | UnspecifiedType = Unspecified,
            params: type[schema.Parameter] | UnspecifiedType = Unspecified,
            return_type: type[schema.Type] | UnspecifiedType = Unspecified,
            operator_kind: type[OperatorKind] | UnspecifiedType = Unspecified,
            abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Update schema::Operator instances in the database.
            """
            ...

        @classmethod
        def select(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: PathAlias | Literal["*"],
            id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            volatility: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[Volatility] | UnspecifiedType = Unspecified,
            annotations: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Annotation] | UnspecifiedType = Unspecified,
            return_typemod: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[TypeModifier] | UnspecifiedType = Unspecified,
            params: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Parameter] | UnspecifiedType = Unspecified,
            return_type: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Type] | UnspecifiedType = Unspecified,
            operator_kind: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[OperatorKind] | UnspecifiedType = Unspecified,
            abstract: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
        ) -> type[Self]:
            """Fetch schema::Operator instances from the database.
            """
            ...

        @classmethod
        def filter(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], type[___std__.bool]],
            id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            volatility: type[Volatility] | UnspecifiedType = Unspecified,
            annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
            return_typemod: type[TypeModifier] | UnspecifiedType = Unspecified,
            params: type[schema.Parameter] | UnspecifiedType = Unspecified,
            return_type: type[schema.Type] | UnspecifiedType = Unspecified,
            operator_kind: type[OperatorKind] | UnspecifiedType = Unspecified,
            abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Fetch schema::Operator instances from the database.
            """
            ...

        @classmethod
        def order_by(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
            id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            abstract: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Specify the sort order for the selection"""
            ...


    class __variants__(
        CallableObject.__variants__,
        VolatilitySubject.__variants__,
    ):
        class Base(
            __Operator_typeof__,
            CallableObject.__variants__.Base,
            VolatilitySubject.__variants__.Base,
            __gel_variant__="Base",
        ):
            if TYPE_CHECKING:
                def __init__(
                    self,
                    /,
                    *,
                    id: UUID | DefaultValue = DEFAULT_VALUE,
                    name: builtins.str,
                    internal: bool | DefaultValue = DEFAULT_VALUE,
                    builtin: bool | DefaultValue = DEFAULT_VALUE,
                    computed_fields: list[builtins.str] | None = None,
                    volatility: ___builtins_1__.str | None | DefaultValue = DEFAULT_VALUE,
                    annotations: Iterable[Annotation] = [],
                    return_typemod: ___builtins_1__.str | None = None,
                    params: Iterable[Parameter] = [],
                    return_type: Type | None = None,
                    operator_kind: ___builtins_1__.str | None = None,
                    abstract: bool | None | DefaultValue = DEFAULT_VALUE,
                ) -> None:
                    """Create a new schema::Operator instance from keyword arguments.

                    Call db.save() on the returned object to persist it in the database.
                    """
                    ...

            if TYPE_CHECKING:
                @classmethod
                def update(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    volatility: type[Volatility] | UnspecifiedType = Unspecified,
                    annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
                    return_typemod: type[TypeModifier] | UnspecifiedType = Unspecified,
                    params: type[schema.Parameter] | UnspecifiedType = Unspecified,
                    return_type: type[schema.Type] | UnspecifiedType = Unspecified,
                    operator_kind: type[OperatorKind] | UnspecifiedType = Unspecified,
                    abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Update schema::Operator instances in the database.
                    """
                    ...

                @classmethod
                def select(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: PathAlias | Literal["*"],
                    id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    volatility: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[Volatility] | UnspecifiedType = Unspecified,
                    annotations: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Annotation] | UnspecifiedType = Unspecified,
                    return_typemod: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[TypeModifier] | UnspecifiedType = Unspecified,
                    params: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Parameter] | UnspecifiedType = Unspecified,
                    return_type: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Type] | UnspecifiedType = Unspecified,
                    operator_kind: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[OperatorKind] | UnspecifiedType = Unspecified,
                    abstract: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
                ) -> type[Self]:
                    """Fetch schema::Operator instances from the database.
                    """
                    ...

                @classmethod
                def filter(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], type[___std__.bool]],
                    id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    volatility: type[Volatility] | UnspecifiedType = Unspecified,
                    annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
                    return_typemod: type[TypeModifier] | UnspecifiedType = Unspecified,
                    params: type[schema.Parameter] | UnspecifiedType = Unspecified,
                    return_type: type[schema.Type] | UnspecifiedType = Unspecified,
                    operator_kind: type[OperatorKind] | UnspecifiedType = Unspecified,
                    abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Fetch schema::Operator instances from the database.
                    """
                    ...

                @classmethod
                def order_by(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
                    id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    abstract: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Specify the sort order for the selection"""
                    ...

        class Required(
            Base,
            CallableObject.__variants__.Required,
            VolatilitySubject.__variants__.Required,
            __gel_variant__="Required",
        ):
            pass

        class PartialBase(  # type: ignore [misc, unused-ignore]
            __Operator_typeof_partial__,
            Base,
            CallableObject.__variants__.PartialBase,
            VolatilitySubject.__variants__.PartialBase,
            __gel_variant__="PartialBase",
        ):
            pass

        class Partial(  # type: ignore [misc, unused-ignore]
            PartialBase,
            CallableObject.__variants__.Partial,
            VolatilitySubject.__variants__.Partial,
            __gel_variant__="Partial",
        ):
            operator_kind: OptionalProperty[OperatorKind, ___builtins_1__.str]
            abstract: OptionalProperty[std.bool, bool]


        Any = TypeVar("Any", bound="Operator | Base | Required | Partial")
    class __links__(CallableObject.__links__, VolatilitySubject.__links__):
        pass
    class __links_partial__(
        CallableObject.__links_partial__,
        VolatilitySubject.__links_partial__,
    ):
        pass

if not TYPE_CHECKING:
    Operator.__variants__.Base = Operator



#
# type schema::AccessPolicy
#
class __AccessPolicy_typeof_base__(
    __InheritingObject_typeof_base__,
    __AnnotationSubject_typeof_base__,
):
    class __gel_reflection__(
        __InheritingObject_typeof_base__.__gel_reflection__,
        __AnnotationSubject_typeof_base__.__gel_reflection__,
    ):
        id = UUID(int=223674422221926051711980301232417846096)
        name = SchemaPath('schema', 'AccessPolicy')
        @LazyClassProperty["dict[str, GelPointerReflection]"]
        @classmethod
        def pointers(cls) -> dict[str, GelPointerReflection]:
            my_ptrs: dict[str, GelPointerReflection] = {
                'access_kinds': GelPointerReflection(
                    name='access_kinds',
                    type=SchemaPath('schema', 'AccessKind'),
                    typexpr='schema::AccessKind',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('Many'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
                'condition': GelPointerReflection(
                    name='condition',
                    type=SchemaPath('std', 'str'),
                    typexpr='std::str',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
                'action': GelPointerReflection(
                    name='action',
                    type=SchemaPath('schema', 'AccessPolicyAction'),
                    typexpr='schema::AccessPolicyAction',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('One'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
                'expr': GelPointerReflection(
                    name='expr',
                    type=SchemaPath('std', 'str'),
                    typexpr='std::str',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
                'errmessage': GelPointerReflection(
                    name='errmessage',
                    type=SchemaPath('std', 'str'),
                    typexpr='std::str',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
                'subject': GelPointerReflection(
                    name='subject',
                    type=SchemaPath('schema', 'ObjectType'),
                    typexpr='schema::ObjectType',
                    kind=PointerKind('Link'),
                    cardinality=pydantic.Cardinality('One'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
            }
            return (
                my_ptrs
                | __InheritingObject_typeof_base__.__gel_reflection__.pointers
                | __AnnotationSubject_typeof_base__.__gel_reflection__.pointers
            )

        @LazyClassProperty["schema.ObjectType"]
        @classmethod
        def object(cls) -> schema.ObjectType:
            from ... import schema as ___schema_1__
            return ___schema_1__.ObjectType(
                id=UUID(int=223674422221926051711980301232417846096),
                name='schema::AccessPolicy',
                builtin=True,
                internal=False,
                abstract=False,
                final=False,
                compound_type=False,
            )

class __AccessPolicy_typeof__(
    __InheritingObject_typeof__,
    __AnnotationSubject_typeof__,
    __AccessPolicy_typeof_base__,
):
    class __typeof__(
        __InheritingObject_typeof__.__typeof__,
        __AnnotationSubject_typeof__.__typeof__,
    ):
        access_kinds = TypeAliasType('access_kinds', 'MultiProperty[AccessKind, ___builtins_1__.str]')
        condition = TypeAliasType('condition', 'OptionalProperty[std.str, builtins.str]')
        action = TypeAliasType('action', 'AccessPolicyAction')
        expr = TypeAliasType('expr', 'OptionalProperty[std.str, builtins.str]')
        errmessage = TypeAliasType('errmessage', 'OptionalProperty[std.str, builtins.str]')
        subject = TypeAliasType('subject', 'ObjectType')


class __AccessPolicy_typeof_partial__(
    __InheritingObject_typeof_partial__,
    __AnnotationSubject_typeof_partial__,
    __AccessPolicy_typeof_base__,
):
    class __typeof__(
        __InheritingObject_typeof_partial__.__typeof__,
        __AnnotationSubject_typeof_partial__.__typeof__,
    ):
        access_kinds = TypeAliasType('access_kinds', 'MultiProperty[AccessKind, ___builtins_1__.str]')
        condition = TypeAliasType('condition', 'OptionalProperty[std.str, builtins.str]')
        action = TypeAliasType('action', 'OptionalProperty[AccessPolicyAction, ___builtins_1__.str]')
        expr = TypeAliasType('expr', 'OptionalProperty[std.str, builtins.str]')
        errmessage = TypeAliasType('errmessage', 'OptionalProperty[std.str, builtins.str]')
        subject = TypeAliasType('subject', 'ObjectType | ObjectType.__variants__.Partial')


class AccessPolicy(
    __AccessPolicy_typeof__,
    InheritingObject,
    AnnotationSubject,
    __gel_type_id__=UUID(int=223674422221926051711980301232417846096),
):
    if TYPE_CHECKING:
        def __init__(
            self,
            /,
            *,
            id: UUID | DefaultValue = DEFAULT_VALUE,
            name: builtins.str,
            internal: bool | DefaultValue = DEFAULT_VALUE,
            builtin: bool | DefaultValue = DEFAULT_VALUE,
            computed_fields: list[builtins.str] | None = None,
            annotations: Iterable[Annotation] = [],
            abstract: bool | None | DefaultValue = DEFAULT_VALUE,
            final: bool,
            inherited_fields: list[builtins.str] | None = None,
            bases: Iterable[InheritingObject] = [],
            ancestors: Iterable[InheritingObject] = [],
            access_kinds: Iterable[___builtins_1__.str] = [],
            condition: builtins.str | None = None,
            action: ___builtins_1__.str,
            expr: builtins.str | None = None,
            errmessage: builtins.str | None = None,
            subject: ObjectType | None = None,
        ) -> None:
            """Create a new schema::AccessPolicy instance from keyword arguments.

            Call db.save() on the returned object to persist it in the database.
            """
            ...

    if TYPE_CHECKING:
        @classmethod
        def update(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
            abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            inherited_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            bases: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            ancestors: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            access_kinds: type[AccessKind] | UnspecifiedType = Unspecified,
            condition: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            action: type[AccessPolicyAction] | UnspecifiedType = Unspecified,
            expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            errmessage: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            subject: type[schema.ObjectType] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Update schema::AccessPolicy instances in the database.
            """
            ...

        @classmethod
        def select(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: PathAlias | Literal["*"],
            id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Annotation] | UnspecifiedType = Unspecified,
            abstract: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            final: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            inherited_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            bases: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            ancestors: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            access_kinds: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[AccessKind] | UnspecifiedType = Unspecified,
            condition: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            action: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[AccessPolicyAction] | UnspecifiedType = Unspecified,
            expr: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            errmessage: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            subject: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.ObjectType] | UnspecifiedType = Unspecified,
            **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
        ) -> type[Self]:
            """Fetch schema::AccessPolicy instances from the database.
            """
            ...

        @classmethod
        def filter(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], type[___std__.bool]],
            id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
            abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            final: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            inherited_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            bases: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            ancestors: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            access_kinds: type[AccessKind] | UnspecifiedType = Unspecified,
            condition: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            action: type[AccessPolicyAction] | UnspecifiedType = Unspecified,
            expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            errmessage: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            subject: type[schema.ObjectType] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Fetch schema::AccessPolicy instances from the database.
            """
            ...

        @classmethod
        def order_by(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
            id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            abstract: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            final: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            condition: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            expr: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            errmessage: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Specify the sort order for the selection"""
            ...


    class __variants__(
        InheritingObject.__variants__,
        AnnotationSubject.__variants__,
    ):
        class Base(
            __AccessPolicy_typeof__,
            InheritingObject.__variants__.Base,
            AnnotationSubject.__variants__.Base,
            __gel_variant__="Base",
        ):
            if TYPE_CHECKING:
                def __init__(
                    self,
                    /,
                    *,
                    id: UUID | DefaultValue = DEFAULT_VALUE,
                    name: builtins.str,
                    internal: bool | DefaultValue = DEFAULT_VALUE,
                    builtin: bool | DefaultValue = DEFAULT_VALUE,
                    computed_fields: list[builtins.str] | None = None,
                    annotations: Iterable[Annotation] = [],
                    abstract: bool | None | DefaultValue = DEFAULT_VALUE,
                    final: bool,
                    inherited_fields: list[builtins.str] | None = None,
                    bases: Iterable[InheritingObject] = [],
                    ancestors: Iterable[InheritingObject] = [],
                    access_kinds: Iterable[___builtins_1__.str] = [],
                    condition: builtins.str | None = None,
                    action: ___builtins_1__.str,
                    expr: builtins.str | None = None,
                    errmessage: builtins.str | None = None,
                    subject: ObjectType | None = None,
                ) -> None:
                    """Create a new schema::AccessPolicy instance from keyword arguments.

                    Call db.save() on the returned object to persist it in the database.
                    """
                    ...

            if TYPE_CHECKING:
                @classmethod
                def update(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
                    abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    inherited_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    bases: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    ancestors: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    access_kinds: type[AccessKind] | UnspecifiedType = Unspecified,
                    condition: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    action: type[AccessPolicyAction] | UnspecifiedType = Unspecified,
                    expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    errmessage: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    subject: type[schema.ObjectType] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Update schema::AccessPolicy instances in the database.
                    """
                    ...

                @classmethod
                def select(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: PathAlias | Literal["*"],
                    id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Annotation] | UnspecifiedType = Unspecified,
                    abstract: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    final: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    inherited_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    bases: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    ancestors: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    access_kinds: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[AccessKind] | UnspecifiedType = Unspecified,
                    condition: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    action: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[AccessPolicyAction] | UnspecifiedType = Unspecified,
                    expr: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    errmessage: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    subject: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.ObjectType] | UnspecifiedType = Unspecified,
                    **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
                ) -> type[Self]:
                    """Fetch schema::AccessPolicy instances from the database.
                    """
                    ...

                @classmethod
                def filter(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], type[___std__.bool]],
                    id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
                    abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    final: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    inherited_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    bases: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    ancestors: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    access_kinds: type[AccessKind] | UnspecifiedType = Unspecified,
                    condition: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    action: type[AccessPolicyAction] | UnspecifiedType = Unspecified,
                    expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    errmessage: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    subject: type[schema.ObjectType] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Fetch schema::AccessPolicy instances from the database.
                    """
                    ...

                @classmethod
                def order_by(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
                    id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    abstract: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    final: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    condition: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    expr: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    errmessage: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Specify the sort order for the selection"""
                    ...

        class Required(
            Base,
            InheritingObject.__variants__.Required,
            AnnotationSubject.__variants__.Required,
            __gel_variant__="Required",
        ):
            action: AccessPolicyAction
            subject: ___schema__.ObjectType

        class PartialBase(  # type: ignore [misc, unused-ignore]
            __AccessPolicy_typeof_partial__,
            Base,
            InheritingObject.__variants__.PartialBase,
            AnnotationSubject.__variants__.PartialBase,
            __gel_variant__="PartialBase",
        ):
            pass

        class Partial(  # type: ignore [misc, unused-ignore]
            PartialBase,
            InheritingObject.__variants__.Partial,
            AnnotationSubject.__variants__.Partial,
            __gel_variant__="Partial",
        ):
            access_kinds: MultiProperty[AccessKind, ___builtins_1__.str]
            condition: OptionalProperty[std.str, builtins.str]
            action: OptionalProperty[AccessPolicyAction, ___builtins_1__.str]
            expr: OptionalProperty[std.str, builtins.str]
            errmessage: OptionalProperty[std.str, builtins.str]
            subject: ___schema__.ObjectType | ___schema__.ObjectType.__variants__.Partial


        Any = TypeVar("Any", bound="AccessPolicy | Base | Required | Partial")
    class __links__(InheritingObject.__links__, AnnotationSubject.__links__):
        pass
    class __links_partial__(
        InheritingObject.__links_partial__,
        AnnotationSubject.__links_partial__,
    ):
        pass

if not TYPE_CHECKING:
    AccessPolicy.__variants__.Base = AccessPolicy



#
# type schema::Annotation
#
class __Annotation_typeof_base__(
    __InheritingObject_typeof_base__,
    __AnnotationSubject_typeof_base__,
):
    class __gel_reflection__(
        __InheritingObject_typeof_base__.__gel_reflection__,
        __AnnotationSubject_typeof_base__.__gel_reflection__,
    ):
        id = UUID(int=52148979689992418483179854258332537093)
        name = SchemaPath('schema', 'Annotation')
        @LazyClassProperty["dict[str, GelPointerReflection]"]
        @classmethod
        def pointers(cls) -> dict[str, GelPointerReflection]:
            my_ptrs: dict[str, GelPointerReflection] = {
                'inheritable': GelPointerReflection(
                    name='inheritable',
                    type=SchemaPath('std', 'bool'),
                    typexpr='std::bool',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
            }
            return (
                my_ptrs
                | __InheritingObject_typeof_base__.__gel_reflection__.pointers
                | __AnnotationSubject_typeof_base__.__gel_reflection__.pointers
            )

        @LazyClassProperty["schema.ObjectType"]
        @classmethod
        def object(cls) -> schema.ObjectType:
            from ... import schema as ___schema_1__
            return ___schema_1__.ObjectType(
                id=UUID(int=52148979689992418483179854258332537093),
                name='schema::Annotation',
                builtin=True,
                internal=False,
                abstract=False,
                final=False,
                compound_type=False,
            )

class __Annotation_typeof__(
    __InheritingObject_typeof__,
    __AnnotationSubject_typeof__,
    __Annotation_typeof_base__,
):
    class __typeof__(
        __InheritingObject_typeof__.__typeof__,
        __AnnotationSubject_typeof__.__typeof__,
    ):
        inheritable = TypeAliasType('inheritable', 'OptionalProperty[std.bool, bool]')


class __Annotation_typeof_partial__(
    __InheritingObject_typeof_partial__,
    __AnnotationSubject_typeof_partial__,
    __Annotation_typeof_base__,
):
    class __typeof__(
        __InheritingObject_typeof_partial__.__typeof__,
        __AnnotationSubject_typeof_partial__.__typeof__,
    ):
        inheritable = TypeAliasType('inheritable', 'OptionalProperty[std.bool, bool]')


class Annotation(
    __Annotation_typeof__,
    InheritingObject,
    AnnotationSubject,
    __gel_type_id__=UUID(int=52148979689992418483179854258332537093),
):
    if TYPE_CHECKING:
        def __init__(
            self,
            /,
            *,
            id: UUID | DefaultValue = DEFAULT_VALUE,
            name: builtins.str,
            internal: bool | DefaultValue = DEFAULT_VALUE,
            builtin: bool | DefaultValue = DEFAULT_VALUE,
            computed_fields: list[builtins.str] | None = None,
            annotations: Iterable[Annotation] = [],
            abstract: bool | None | DefaultValue = DEFAULT_VALUE,
            final: bool,
            inherited_fields: list[builtins.str] | None = None,
            bases: Iterable[InheritingObject] = [],
            ancestors: Iterable[InheritingObject] = [],
            inheritable: bool | None = None,
        ) -> None:
            """Create a new schema::Annotation instance from keyword arguments.

            Call db.save() on the returned object to persist it in the database.
            """
            ...

    if TYPE_CHECKING:
        @classmethod
        def update(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
            abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            inherited_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            bases: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            ancestors: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            inheritable: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Update schema::Annotation instances in the database.
            """
            ...

        @classmethod
        def select(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: PathAlias | Literal["*"],
            id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Annotation] | UnspecifiedType = Unspecified,
            abstract: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            final: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            inherited_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            bases: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            ancestors: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            inheritable: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
        ) -> type[Self]:
            """Fetch schema::Annotation instances from the database.
            """
            ...

        @classmethod
        def filter(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], type[___std__.bool]],
            id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
            abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            final: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            inherited_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            bases: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            ancestors: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            inheritable: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Fetch schema::Annotation instances from the database.
            """
            ...

        @classmethod
        def order_by(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
            id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            abstract: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            final: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            inheritable: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Specify the sort order for the selection"""
            ...


    class __variants__(
        InheritingObject.__variants__,
        AnnotationSubject.__variants__,
    ):
        class Base(
            __Annotation_typeof__,
            InheritingObject.__variants__.Base,
            AnnotationSubject.__variants__.Base,
            __gel_variant__="Base",
        ):
            if TYPE_CHECKING:
                def __init__(
                    self,
                    /,
                    *,
                    id: UUID | DefaultValue = DEFAULT_VALUE,
                    name: builtins.str,
                    internal: bool | DefaultValue = DEFAULT_VALUE,
                    builtin: bool | DefaultValue = DEFAULT_VALUE,
                    computed_fields: list[builtins.str] | None = None,
                    annotations: Iterable[Annotation] = [],
                    abstract: bool | None | DefaultValue = DEFAULT_VALUE,
                    final: bool,
                    inherited_fields: list[builtins.str] | None = None,
                    bases: Iterable[InheritingObject] = [],
                    ancestors: Iterable[InheritingObject] = [],
                    inheritable: bool | None = None,
                ) -> None:
                    """Create a new schema::Annotation instance from keyword arguments.

                    Call db.save() on the returned object to persist it in the database.
                    """
                    ...

            if TYPE_CHECKING:
                @classmethod
                def update(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
                    abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    inherited_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    bases: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    ancestors: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    inheritable: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Update schema::Annotation instances in the database.
                    """
                    ...

                @classmethod
                def select(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: PathAlias | Literal["*"],
                    id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Annotation] | UnspecifiedType = Unspecified,
                    abstract: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    final: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    inherited_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    bases: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    ancestors: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    inheritable: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
                ) -> type[Self]:
                    """Fetch schema::Annotation instances from the database.
                    """
                    ...

                @classmethod
                def filter(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], type[___std__.bool]],
                    id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
                    abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    final: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    inherited_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    bases: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    ancestors: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    inheritable: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Fetch schema::Annotation instances from the database.
                    """
                    ...

                @classmethod
                def order_by(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
                    id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    abstract: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    final: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    inheritable: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Specify the sort order for the selection"""
                    ...

        class Required(
            Base,
            InheritingObject.__variants__.Required,
            AnnotationSubject.__variants__.Required,
            __gel_variant__="Required",
        ):
            pass

        class PartialBase(  # type: ignore [misc, unused-ignore]
            __Annotation_typeof_partial__,
            Base,
            InheritingObject.__variants__.PartialBase,
            AnnotationSubject.__variants__.PartialBase,
            __gel_variant__="PartialBase",
        ):
            pass

        class Partial(  # type: ignore [misc, unused-ignore]
            PartialBase,
            InheritingObject.__variants__.Partial,
            AnnotationSubject.__variants__.Partial,
            __gel_variant__="Partial",
        ):
            inheritable: OptionalProperty[std.bool, bool]


        Any = TypeVar("Any", bound="Annotation | Base | Required | Partial")
    class __links__(InheritingObject.__links__, AnnotationSubject.__links__):
        pass
    class __links_partial__(
        InheritingObject.__links_partial__,
        AnnotationSubject.__links_partial__,
    ):
        pass

if not TYPE_CHECKING:
    Annotation.__variants__.Base = Annotation



#
# type schema::ConsistencySubject
#
class __ConsistencySubject_typeof_base__(
    __InheritingObject_typeof_base__,
    __AnnotationSubject_typeof_base__,
):
    class __gel_reflection__(
        __InheritingObject_typeof_base__.__gel_reflection__,
        __AnnotationSubject_typeof_base__.__gel_reflection__,
    ):
        id = UUID(int=181100937149158556163506130951259876648)
        name = SchemaPath('schema', 'ConsistencySubject')
        @LazyClassProperty["dict[str, GelPointerReflection]"]
        @classmethod
        def pointers(cls) -> dict[str, GelPointerReflection]:
            my_ptrs: dict[str, GelPointerReflection] = {
                'constraints': GelPointerReflection(
                    name='constraints',
                    type=SchemaPath('schema', 'Constraint'),
                    typexpr='schema::Constraint',
                    kind=PointerKind('Link'),
                    cardinality=pydantic.Cardinality('Many'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={
                    'owned': GelPointerReflection(
                    name='owned',
                    type=SchemaPath('std', 'bool'),
                    typexpr='std::bool',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties=None,
                ),
                    'is_owned': GelPointerReflection(
                    name='is_owned',
                    type=SchemaPath('std', 'bool'),
                    typexpr='std::bool',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties=None,
                ),
                },
                ),
            }
            return (
                my_ptrs
                | __InheritingObject_typeof_base__.__gel_reflection__.pointers
                | __AnnotationSubject_typeof_base__.__gel_reflection__.pointers
            )

        @LazyClassProperty["schema.ObjectType"]
        @classmethod
        def object(cls) -> schema.ObjectType:
            from ... import schema as ___schema_1__
            return ___schema_1__.ObjectType(
                id=UUID(int=181100937149158556163506130951259876648),
                name='schema::ConsistencySubject',
                builtin=True,
                internal=False,
                abstract=True,
                final=False,
                compound_type=False,
            )

class __ConsistencySubject_typeof__(
    __InheritingObject_typeof__,
    __AnnotationSubject_typeof__,
    __ConsistencySubject_typeof_base__,
):
    class __typeof__(
        __InheritingObject_typeof__.__typeof__,
        __AnnotationSubject_typeof__.__typeof__,
    ):
        constraints = TypeAliasType('constraints', 'MultiLinkWithProps[ConsistencySubject.__links__.constraints, Constraint]')


class __ConsistencySubject_typeof_partial__(
    __InheritingObject_typeof_partial__,
    __AnnotationSubject_typeof_partial__,
    __ConsistencySubject_typeof_base__,
):
    class __typeof__(
        __InheritingObject_typeof_partial__.__typeof__,
        __AnnotationSubject_typeof_partial__.__typeof__,
    ):
        constraints = TypeAliasType('constraints', 'MultiLinkWithProps[ConsistencySubject.__links__.constraints | ConsistencySubject.__links_partial__.constraints, Constraint]')


class ConsistencySubject(
    __ConsistencySubject_typeof__,
    InheritingObject,
    AnnotationSubject,
    __gel_type_id__=UUID(int=181100937149158556163506130951259876648),
):
    if TYPE_CHECKING:
        def __init__(
            self,
            /,
            *,
            id: UUID | DefaultValue = DEFAULT_VALUE,
            name: builtins.str,
            internal: bool | DefaultValue = DEFAULT_VALUE,
            builtin: bool | DefaultValue = DEFAULT_VALUE,
            computed_fields: list[builtins.str] | None = None,
            annotations: Iterable[Annotation] = [],
            abstract: bool | None | DefaultValue = DEFAULT_VALUE,
            final: bool,
            inherited_fields: list[builtins.str] | None = None,
            bases: Iterable[InheritingObject] = [],
            ancestors: Iterable[InheritingObject] = [],
            constraints: Iterable[Constraint] = [],
        ) -> None:
            """Create a new schema::ConsistencySubject instance from keyword arguments.

            Call db.save() on the returned object to persist it in the database.
            """
            ...

    if TYPE_CHECKING:
        @classmethod
        def update(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
            abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            inherited_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            bases: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            ancestors: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            constraints: type[schema.Constraint] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Update schema::ConsistencySubject instances in the database.
            """
            ...

        @classmethod
        def select(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: PathAlias | Literal["*"],
            id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Annotation] | UnspecifiedType = Unspecified,
            abstract: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            final: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            inherited_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            bases: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            ancestors: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            constraints: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Constraint] | UnspecifiedType = Unspecified,
            **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
        ) -> type[Self]:
            """Fetch schema::ConsistencySubject instances from the database.
            """
            ...

        @classmethod
        def filter(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], type[___std__.bool]],
            id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
            abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            final: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            inherited_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            bases: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            ancestors: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            constraints: type[schema.Constraint] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Fetch schema::ConsistencySubject instances from the database.
            """
            ...

        @classmethod
        def order_by(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
            id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            abstract: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            final: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Specify the sort order for the selection"""
            ...


    class __variants__(
        InheritingObject.__variants__,
        AnnotationSubject.__variants__,
    ):
        class Base(
            __ConsistencySubject_typeof__,
            InheritingObject.__variants__.Base,
            AnnotationSubject.__variants__.Base,
            __gel_variant__="Base",
        ):
            if TYPE_CHECKING:
                def __init__(
                    self,
                    /,
                    *,
                    id: UUID | DefaultValue = DEFAULT_VALUE,
                    name: builtins.str,
                    internal: bool | DefaultValue = DEFAULT_VALUE,
                    builtin: bool | DefaultValue = DEFAULT_VALUE,
                    computed_fields: list[builtins.str] | None = None,
                    annotations: Iterable[Annotation] = [],
                    abstract: bool | None | DefaultValue = DEFAULT_VALUE,
                    final: bool,
                    inherited_fields: list[builtins.str] | None = None,
                    bases: Iterable[InheritingObject] = [],
                    ancestors: Iterable[InheritingObject] = [],
                    constraints: Iterable[Constraint] = [],
                ) -> None:
                    """Create a new schema::ConsistencySubject instance from keyword arguments.

                    Call db.save() on the returned object to persist it in the database.
                    """
                    ...

            if TYPE_CHECKING:
                @classmethod
                def update(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
                    abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    inherited_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    bases: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    ancestors: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    constraints: type[schema.Constraint] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Update schema::ConsistencySubject instances in the database.
                    """
                    ...

                @classmethod
                def select(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: PathAlias | Literal["*"],
                    id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Annotation] | UnspecifiedType = Unspecified,
                    abstract: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    final: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    inherited_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    bases: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    ancestors: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    constraints: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Constraint] | UnspecifiedType = Unspecified,
                    **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
                ) -> type[Self]:
                    """Fetch schema::ConsistencySubject instances from the database.
                    """
                    ...

                @classmethod
                def filter(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], type[___std__.bool]],
                    id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
                    abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    final: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    inherited_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    bases: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    ancestors: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    constraints: type[schema.Constraint] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Fetch schema::ConsistencySubject instances from the database.
                    """
                    ...

                @classmethod
                def order_by(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
                    id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    abstract: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    final: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Specify the sort order for the selection"""
                    ...

        class Required(
            Base,
            InheritingObject.__variants__.Required,
            AnnotationSubject.__variants__.Required,
            __gel_variant__="Required",
        ):
            pass

        class PartialBase(  # type: ignore [misc, unused-ignore]
            __ConsistencySubject_typeof_partial__,
            Base,
            InheritingObject.__variants__.PartialBase,
            AnnotationSubject.__variants__.PartialBase,
            __gel_variant__="PartialBase",
        ):
            pass

        class Partial(  # type: ignore [misc, unused-ignore]
            PartialBase,
            InheritingObject.__variants__.Partial,
            AnnotationSubject.__variants__.Partial,
            __gel_variant__="Partial",
        ):
            constraints: MultiLinkWithProps[ConsistencySubject.__links__.constraints | ConsistencySubject.__links_partial__.constraints, ___schema__.Constraint]


        Any = TypeVar("Any", bound="ConsistencySubject | Base | Required | Partial")
    class __links__(InheritingObject.__links__, AnnotationSubject.__links__):
        if TYPE_CHECKING:
            class constraints(
                schema.Constraint,
                ProxyModel[schema.Constraint],
            ):
                """link schema::ConsistencySubject.constraints: schema::Constraint"""
                class __lprops__(GelLinkModel):
                    class __gel_reflection__(GelLinkModel.__gel_reflection__):
                        id = UUID(int=200421206014242147397734703104350379594)
                        name = SchemaPath('constraints')
                        @LazyClassProperty["dict[str, GelPointerReflection]"]
                        @classmethod
                        def pointers(cls) -> dict[str, GelPointerReflection]:
                            my_ptrs: dict[str, GelPointerReflection] = {
                                'owned': GelPointerReflection(
                                    name='owned',
                                    type=SchemaPath('std', 'bool'),
                                    typexpr='std::bool',
                                    kind=PointerKind('Property'),
                                    cardinality=pydantic.Cardinality('AtMostOne'),
                                    computed=False,
                                    readonly=False,
                                    has_default=False,
                                    properties=None,
                                ),
                                'is_owned': GelPointerReflection(
                                    name='is_owned',
                                    type=SchemaPath('std', 'bool'),
                                    typexpr='std::bool',
                                    kind=PointerKind('Property'),
                                    cardinality=pydantic.Cardinality('AtMostOne'),
                                    computed=False,
                                    readonly=False,
                                    has_default=False,
                                    properties=None,
                                ),
                            }
                            return my_ptrs


                    owned: OptionalProperty[___std__.bool, ___builtins_2__.bool]
                    is_owned: OptionalProperty[___std__.bool, ___builtins_2__.bool]
                __linkprops__: __lprops__

                def __init__(
                    self,
                    obj: schema.Constraint,
                    /,
                    *,
                    owned: ___builtins_2__.bool | None = None,
                    is_owned: ___builtins_2__.bool | None = None,
                ) -> None:
                    ...

                @classmethod
                def link(
                    cls,
                    obj: schema.Constraint,
                    /,
                    *,
                    owned: ___builtins_2__.bool | None = None,
                    is_owned: ___builtins_2__.bool | None = None,
                ) -> Self:
                    ...

        if not TYPE_CHECKING:
            @LazyClassProperty[type]
            @classmethod
            def constraints(cls) -> type:
                class ConsistencySubject__constraints(
                    ___schema__.Constraint,
                    ProxyModel[___schema__.Constraint],
                ):
                    """link schema::ConsistencySubject.constraints: schema::Constraint"""
                    class __lprops__(GelLinkModel):
                        class __gel_reflection__(
                            GelLinkModel.__gel_reflection__,
                        ):
                            id = UUID(int=200421206014242147397734703104350379594)
                            name = SchemaPath('constraints')
                            @LazyClassProperty["dict[str, GelPointerReflection]"]
                            @classmethod
                            def pointers(
                                cls,
                            ) -> dict[str, GelPointerReflection]:
                                my_ptrs: dict[str, GelPointerReflection] = {
                                    'owned': GelPointerReflection(
                                        name='owned',
                                        type=SchemaPath('std', 'bool'),
                                        typexpr='std::bool',
                                        kind=PointerKind('Property'),
                                        cardinality=pydantic.Cardinality('AtMostOne'),
                                        computed=False,
                                        readonly=False,
                                        has_default=False,
                                        properties=None,
                                    ),
                                    'is_owned': GelPointerReflection(
                                        name='is_owned',
                                        type=SchemaPath('std', 'bool'),
                                        typexpr='std::bool',
                                        kind=PointerKind('Property'),
                                        cardinality=pydantic.Cardinality('AtMostOne'),
                                        computed=False,
                                        readonly=False,
                                        has_default=False,
                                        properties=None,
                                    ),
                                }
                                return my_ptrs


                        owned: OptionalProperty[std.bool, ___builtins_2__.bool]
                        is_owned: OptionalProperty[std.bool, ___builtins_2__.bool]
                    __linkprops__: __lprops__

                    def __init__(self, obj, /, **link_props) -> None:
                        ProxyModel.__init__(self, obj)
                        lprops = self.__class__.__lprops__(**link_props)
                        object.__setattr__(self, "__linkprops__", lprops)

                    @classmethod
                    def link(cls, obj, /, **link_props) -> Self:
                        return cls(obj, **link_props)

                ConsistencySubject__constraints.__name__ = 'constraints'
                ConsistencySubject__constraints.__qualname__ = 'ConsistencySubject.constraints'
                return ConsistencySubject__constraints
    class __links_partial__(
        InheritingObject.__links_partial__,
        AnnotationSubject.__links_partial__,
    ):
        if TYPE_CHECKING:
            class constraints(  # type: ignore [misc]
                schema.Constraint.__variants__.Partial,
                ProxyModel[schema.Constraint.__variants__.Partial],
            ):
                """link schema::ConsistencySubject.constraints: schema::Constraint"""
                class __lprops__(GelLinkModel):
                    class __gel_reflection__(GelLinkModel.__gel_reflection__):
                        id = UUID(int=200421206014242147397734703104350379594)
                        name = SchemaPath('constraints')
                        @LazyClassProperty["dict[str, GelPointerReflection]"]
                        @classmethod
                        def pointers(cls) -> dict[str, GelPointerReflection]:
                            my_ptrs: dict[str, GelPointerReflection] = {
                                'owned': GelPointerReflection(
                                    name='owned',
                                    type=SchemaPath('std', 'bool'),
                                    typexpr='std::bool',
                                    kind=PointerKind('Property'),
                                    cardinality=pydantic.Cardinality('AtMostOne'),
                                    computed=False,
                                    readonly=False,
                                    has_default=False,
                                    properties=None,
                                ),
                                'is_owned': GelPointerReflection(
                                    name='is_owned',
                                    type=SchemaPath('std', 'bool'),
                                    typexpr='std::bool',
                                    kind=PointerKind('Property'),
                                    cardinality=pydantic.Cardinality('AtMostOne'),
                                    computed=False,
                                    readonly=False,
                                    has_default=False,
                                    properties=None,
                                ),
                            }
                            return my_ptrs


                    owned: OptionalProperty[___std__.bool, ___builtins_2__.bool]
                    is_owned: OptionalProperty[___std__.bool, ___builtins_2__.bool]
                __linkprops__: __lprops__

                def __init__(
                    self,
                    obj: schema.Constraint.__variants__.Partial,
                    /,
                    *,
                    owned: ___builtins_2__.bool | None = None,
                    is_owned: ___builtins_2__.bool | None = None,
                ) -> None:
                    ...

                @classmethod
                def link(
                    cls,
                    obj: schema.Constraint.__variants__.Partial,
                    /,
                    *,
                    owned: ___builtins_2__.bool | None = None,
                    is_owned: ___builtins_2__.bool | None = None,
                ) -> Self:
                    ...

        if not TYPE_CHECKING:
            @LazyClassProperty[type]
            @classmethod
            def constraints(cls) -> type:
                class ConsistencySubject__constraints(  # type: ignore [misc]
                    ___schema__.Constraint.__variants__.Partial,
                    ProxyModel[___schema__.Constraint.__variants__.Partial],
                ):
                    """link schema::ConsistencySubject.constraints: schema::Constraint"""
                    class __lprops__(GelLinkModel):
                        class __gel_reflection__(
                            GelLinkModel.__gel_reflection__,
                        ):
                            id = UUID(int=200421206014242147397734703104350379594)
                            name = SchemaPath('constraints')
                            @LazyClassProperty["dict[str, GelPointerReflection]"]
                            @classmethod
                            def pointers(
                                cls,
                            ) -> dict[str, GelPointerReflection]:
                                my_ptrs: dict[str, GelPointerReflection] = {
                                    'owned': GelPointerReflection(
                                        name='owned',
                                        type=SchemaPath('std', 'bool'),
                                        typexpr='std::bool',
                                        kind=PointerKind('Property'),
                                        cardinality=pydantic.Cardinality('AtMostOne'),
                                        computed=False,
                                        readonly=False,
                                        has_default=False,
                                        properties=None,
                                    ),
                                    'is_owned': GelPointerReflection(
                                        name='is_owned',
                                        type=SchemaPath('std', 'bool'),
                                        typexpr='std::bool',
                                        kind=PointerKind('Property'),
                                        cardinality=pydantic.Cardinality('AtMostOne'),
                                        computed=False,
                                        readonly=False,
                                        has_default=False,
                                        properties=None,
                                    ),
                                }
                                return my_ptrs


                        owned: OptionalProperty[std.bool, ___builtins_2__.bool]
                        is_owned: OptionalProperty[std.bool, ___builtins_2__.bool]
                    __linkprops__: __lprops__

                    def __init__(self, obj, /, **link_props) -> None:
                        ProxyModel.__init__(self, obj)
                        lprops = self.__class__.__lprops__(**link_props)
                        object.__setattr__(self, "__linkprops__", lprops)

                    @classmethod
                    def link(cls, obj, /, **link_props) -> Self:
                        return cls(obj, **link_props)

                ConsistencySubject__constraints.__name__ = 'constraints'
                ConsistencySubject__constraints.__qualname__ = 'ConsistencySubject.constraints'
                return ConsistencySubject__constraints

if not TYPE_CHECKING:
    ConsistencySubject.__variants__.Base = ConsistencySubject



#
# type schema::Constraint
#
class __Constraint_typeof_base__(
    __CallableObject_typeof_base__,
    __InheritingObject_typeof_base__,
):
    class __gel_reflection__(
        __CallableObject_typeof_base__.__gel_reflection__,
        __InheritingObject_typeof_base__.__gel_reflection__,
    ):
        id = UUID(int=195763951784768659695883964066391108399)
        name = SchemaPath('schema', 'Constraint')
        @LazyClassProperty["dict[str, GelPointerReflection]"]
        @classmethod
        def pointers(cls) -> dict[str, GelPointerReflection]:
            my_ptrs: dict[str, GelPointerReflection] = {
                'expr': GelPointerReflection(
                    name='expr',
                    type=SchemaPath('std', 'str'),
                    typexpr='std::str',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
                'subjectexpr': GelPointerReflection(
                    name='subjectexpr',
                    type=SchemaPath('std', 'str'),
                    typexpr='std::str',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
                'finalexpr': GelPointerReflection(
                    name='finalexpr',
                    type=SchemaPath('std', 'str'),
                    typexpr='std::str',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
                'errmessage': GelPointerReflection(
                    name='errmessage',
                    type=SchemaPath('std', 'str'),
                    typexpr='std::str',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
                'delegated': GelPointerReflection(
                    name='delegated',
                    type=SchemaPath('std', 'bool'),
                    typexpr='std::bool',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
                'except_expr': GelPointerReflection(
                    name='except_expr',
                    type=SchemaPath('std', 'str'),
                    typexpr='std::str',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
                'subject': GelPointerReflection(
                    name='subject',
                    type=SchemaPath('schema', 'ConsistencySubject'),
                    typexpr='schema::ConsistencySubject',
                    kind=PointerKind('Link'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
                'params': GelPointerReflection(
                    name='params',
                    type=SchemaPath('schema', 'Parameter'),
                    typexpr='schema::Parameter',
                    kind=PointerKind('Link'),
                    cardinality=pydantic.Cardinality('Many'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={
                    'index': GelPointerReflection(
                    name='index',
                    type=SchemaPath('std', 'int64'),
                    typexpr='std::int64',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties=None,
                ),
                    'value': GelPointerReflection(
                    name='value',
                    type=SchemaPath('std', 'str'),
                    typexpr='std::str',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties=None,
                ),
                },
                ),
            }
            return (
                my_ptrs
                | __CallableObject_typeof_base__.__gel_reflection__.pointers
                | __InheritingObject_typeof_base__.__gel_reflection__.pointers
            )

        @LazyClassProperty["schema.ObjectType"]
        @classmethod
        def object(cls) -> schema.ObjectType:
            from ... import schema as ___schema_1__
            return ___schema_1__.ObjectType(
                id=UUID(int=195763951784768659695883964066391108399),
                name='schema::Constraint',
                builtin=True,
                internal=False,
                abstract=False,
                final=False,
                compound_type=False,
            )

class __Constraint_typeof__(
    __CallableObject_typeof__,
    __InheritingObject_typeof__,
    __Constraint_typeof_base__,
):
    class __typeof__(
        __CallableObject_typeof__.__typeof__,
        __InheritingObject_typeof__.__typeof__,
    ):
        expr = TypeAliasType('expr', 'OptionalProperty[std.str, builtins.str]')
        subjectexpr = TypeAliasType('subjectexpr', 'OptionalProperty[std.str, builtins.str]')
        finalexpr = TypeAliasType('finalexpr', 'OptionalProperty[std.str, builtins.str]')
        errmessage = TypeAliasType('errmessage', 'OptionalProperty[std.str, builtins.str]')
        delegated = TypeAliasType('delegated', 'OptionalProperty[std.bool, bool]')
        except_expr = TypeAliasType('except_expr', 'OptionalProperty[std.str, builtins.str]')
        subject = TypeAliasType('subject', 'OptionalLink[ConsistencySubject]')
        params = TypeAliasType('params', 'MultiLinkWithProps[Constraint.__links__.params, Parameter]')


class __Constraint_typeof_partial__(
    __CallableObject_typeof_partial__,
    __InheritingObject_typeof_partial__,
    __Constraint_typeof_base__,
):
    class __typeof__(
        __CallableObject_typeof_partial__.__typeof__,
        __InheritingObject_typeof_partial__.__typeof__,
    ):
        expr = TypeAliasType('expr', 'OptionalProperty[std.str, builtins.str]')
        subjectexpr = TypeAliasType('subjectexpr', 'OptionalProperty[std.str, builtins.str]')
        finalexpr = TypeAliasType('finalexpr', 'OptionalProperty[std.str, builtins.str]')
        errmessage = TypeAliasType('errmessage', 'OptionalProperty[std.str, builtins.str]')
        delegated = TypeAliasType('delegated', 'OptionalProperty[std.bool, bool]')
        except_expr = TypeAliasType('except_expr', 'OptionalProperty[std.str, builtins.str]')
        subject = TypeAliasType('subject', 'OptionalLink[ConsistencySubject | ConsistencySubject.__variants__.Partial]')
        params = TypeAliasType('params', 'MultiLinkWithProps[Constraint.__links__.params | Constraint.__links_partial__.params, Parameter]')


class Constraint(
    __Constraint_typeof__,
    CallableObject,
    InheritingObject,
    __gel_type_id__=UUID(int=195763951784768659695883964066391108399),
):
    if TYPE_CHECKING:
        def __init__(
            self,
            /,
            *,
            id: UUID | DefaultValue = DEFAULT_VALUE,
            name: builtins.str,
            internal: bool | DefaultValue = DEFAULT_VALUE,
            builtin: bool | DefaultValue = DEFAULT_VALUE,
            computed_fields: list[builtins.str] | None = None,
            annotations: Iterable[Annotation] = [],
            abstract: bool | None | DefaultValue = DEFAULT_VALUE,
            final: bool,
            inherited_fields: list[builtins.str] | None = None,
            bases: Iterable[InheritingObject] = [],
            ancestors: Iterable[InheritingObject] = [],
            return_typemod: ___builtins_1__.str | None = None,
            params: Iterable[Parameter] = [],
            return_type: Type | None = None,
            expr: builtins.str | None = None,
            subjectexpr: builtins.str | None = None,
            finalexpr: builtins.str | None = None,
            errmessage: builtins.str | None = None,
            delegated: bool | None = None,
            except_expr: builtins.str | None = None,
            subject: ConsistencySubject | None = None,
        ) -> None:
            """Create a new schema::Constraint instance from keyword arguments.

            Call db.save() on the returned object to persist it in the database.
            """
            ...

    if TYPE_CHECKING:
        @classmethod
        def update(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
            abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            inherited_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            bases: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            ancestors: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            return_typemod: type[TypeModifier] | UnspecifiedType = Unspecified,
            params: type[schema.Parameter] | UnspecifiedType = Unspecified,
            return_type: type[schema.Type] | UnspecifiedType = Unspecified,
            expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            subjectexpr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            finalexpr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            errmessage: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            delegated: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            except_expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            subject: type[schema.ConsistencySubject] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Update schema::Constraint instances in the database.
            """
            ...

        @classmethod
        def select(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: PathAlias | Literal["*"],
            id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Annotation] | UnspecifiedType = Unspecified,
            abstract: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            final: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            inherited_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            bases: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            ancestors: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            return_typemod: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[TypeModifier] | UnspecifiedType = Unspecified,
            params: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Parameter] | UnspecifiedType = Unspecified,
            return_type: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Type] | UnspecifiedType = Unspecified,
            expr: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            subjectexpr: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            finalexpr: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            errmessage: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            delegated: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            except_expr: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            subject: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.ConsistencySubject] | UnspecifiedType = Unspecified,
            **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
        ) -> type[Self]:
            """Fetch schema::Constraint instances from the database.
            """
            ...

        @classmethod
        def filter(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], type[___std__.bool]],
            id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
            abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            final: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            inherited_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            bases: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            ancestors: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            return_typemod: type[TypeModifier] | UnspecifiedType = Unspecified,
            params: type[schema.Parameter] | UnspecifiedType = Unspecified,
            return_type: type[schema.Type] | UnspecifiedType = Unspecified,
            expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            subjectexpr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            finalexpr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            errmessage: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            delegated: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            except_expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            subject: type[schema.ConsistencySubject] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Fetch schema::Constraint instances from the database.
            """
            ...

        @classmethod
        def order_by(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
            id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            abstract: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            final: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            expr: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            subjectexpr: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            finalexpr: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            errmessage: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            delegated: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            except_expr: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Specify the sort order for the selection"""
            ...


    class __variants__(
        CallableObject.__variants__,
        InheritingObject.__variants__,
    ):
        class Base(
            __Constraint_typeof__,
            CallableObject.__variants__.Base,
            InheritingObject.__variants__.Base,
            __gel_variant__="Base",
        ):
            if TYPE_CHECKING:
                def __init__(
                    self,
                    /,
                    *,
                    id: UUID | DefaultValue = DEFAULT_VALUE,
                    name: builtins.str,
                    internal: bool | DefaultValue = DEFAULT_VALUE,
                    builtin: bool | DefaultValue = DEFAULT_VALUE,
                    computed_fields: list[builtins.str] | None = None,
                    annotations: Iterable[Annotation] = [],
                    abstract: bool | None | DefaultValue = DEFAULT_VALUE,
                    final: bool,
                    inherited_fields: list[builtins.str] | None = None,
                    bases: Iterable[InheritingObject] = [],
                    ancestors: Iterable[InheritingObject] = [],
                    return_typemod: ___builtins_1__.str | None = None,
                    params: Iterable[Parameter] = [],
                    return_type: Type | None = None,
                    expr: builtins.str | None = None,
                    subjectexpr: builtins.str | None = None,
                    finalexpr: builtins.str | None = None,
                    errmessage: builtins.str | None = None,
                    delegated: bool | None = None,
                    except_expr: builtins.str | None = None,
                    subject: ConsistencySubject | None = None,
                ) -> None:
                    """Create a new schema::Constraint instance from keyword arguments.

                    Call db.save() on the returned object to persist it in the database.
                    """
                    ...

            if TYPE_CHECKING:
                @classmethod
                def update(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
                    abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    inherited_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    bases: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    ancestors: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    return_typemod: type[TypeModifier] | UnspecifiedType = Unspecified,
                    params: type[schema.Parameter] | UnspecifiedType = Unspecified,
                    return_type: type[schema.Type] | UnspecifiedType = Unspecified,
                    expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    subjectexpr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    finalexpr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    errmessage: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    delegated: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    except_expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    subject: type[schema.ConsistencySubject] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Update schema::Constraint instances in the database.
                    """
                    ...

                @classmethod
                def select(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: PathAlias | Literal["*"],
                    id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Annotation] | UnspecifiedType = Unspecified,
                    abstract: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    final: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    inherited_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    bases: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    ancestors: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    return_typemod: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[TypeModifier] | UnspecifiedType = Unspecified,
                    params: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Parameter] | UnspecifiedType = Unspecified,
                    return_type: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Type] | UnspecifiedType = Unspecified,
                    expr: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    subjectexpr: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    finalexpr: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    errmessage: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    delegated: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    except_expr: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    subject: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.ConsistencySubject] | UnspecifiedType = Unspecified,
                    **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
                ) -> type[Self]:
                    """Fetch schema::Constraint instances from the database.
                    """
                    ...

                @classmethod
                def filter(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], type[___std__.bool]],
                    id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
                    abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    final: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    inherited_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    bases: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    ancestors: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    return_typemod: type[TypeModifier] | UnspecifiedType = Unspecified,
                    params: type[schema.Parameter] | UnspecifiedType = Unspecified,
                    return_type: type[schema.Type] | UnspecifiedType = Unspecified,
                    expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    subjectexpr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    finalexpr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    errmessage: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    delegated: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    except_expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    subject: type[schema.ConsistencySubject] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Fetch schema::Constraint instances from the database.
                    """
                    ...

                @classmethod
                def order_by(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
                    id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    abstract: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    final: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    expr: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    subjectexpr: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    finalexpr: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    errmessage: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    delegated: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    except_expr: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Specify the sort order for the selection"""
                    ...

        class Required(
            Base,
            CallableObject.__variants__.Required,
            InheritingObject.__variants__.Required,
            __gel_variant__="Required",
        ):
            pass

        class PartialBase(  # type: ignore [misc, unused-ignore]
            __Constraint_typeof_partial__,
            Base,
            CallableObject.__variants__.PartialBase,
            InheritingObject.__variants__.PartialBase,
            __gel_variant__="PartialBase",
        ):
            pass

        class Partial(  # type: ignore [misc, unused-ignore]
            PartialBase,
            CallableObject.__variants__.Partial,
            InheritingObject.__variants__.Partial,
            __gel_variant__="Partial",
        ):
            expr: OptionalProperty[std.str, builtins.str]
            subjectexpr: OptionalProperty[std.str, builtins.str]
            finalexpr: OptionalProperty[std.str, builtins.str]
            errmessage: OptionalProperty[std.str, builtins.str]
            delegated: OptionalProperty[std.bool, bool]
            except_expr: OptionalProperty[std.str, builtins.str]
            subject: OptionalLink[___schema__.ConsistencySubject | ___schema__.ConsistencySubject.__variants__.Partial]
            params: MultiLinkWithProps[Constraint.__links__.params | Constraint.__links_partial__.params, ___schema__.Parameter]


        Any = TypeVar("Any", bound="Constraint | Base | Required | Partial")
    class __links__(CallableObject.__links__, InheritingObject.__links__):
        if TYPE_CHECKING:
            class params(
                CallableObject.__links__.params,
                schema.Parameter,
                ProxyModel[schema.Parameter],
            ):
                """link schema::Constraint.params: schema::Parameter"""
                class __lprops__(CallableObject.__links__.params.__lprops__):
                    class __gel_reflection__(
                        CallableObject.__links__.params.__lprops__.__gel_reflection__,
                    ):
                        id = UUID(int=262009166219392732690753003575503864799)
                        name = SchemaPath('params')
                        @LazyClassProperty["dict[str, GelPointerReflection]"]
                        @classmethod
                        def pointers(cls) -> dict[str, GelPointerReflection]:
                            my_ptrs: dict[str, GelPointerReflection] = {
                                'index': GelPointerReflection(
                                    name='index',
                                    type=SchemaPath('std', 'int64'),
                                    typexpr='std::int64',
                                    kind=PointerKind('Property'),
                                    cardinality=pydantic.Cardinality('AtMostOne'),
                                    computed=False,
                                    readonly=False,
                                    has_default=False,
                                    properties=None,
                                ),
                                'value': GelPointerReflection(
                                    name='value',
                                    type=SchemaPath('std', 'str'),
                                    typexpr='std::str',
                                    kind=PointerKind('Property'),
                                    cardinality=pydantic.Cardinality('AtMostOne'),
                                    computed=False,
                                    readonly=False,
                                    has_default=False,
                                    properties=None,
                                ),
                            }
                            return (
                                my_ptrs
                                | CallableObject.__links__.params.__lprops__.__gel_reflection__.pointers
                            )


                    index: OptionalProperty[___std__.int64, ___builtins_3__.int]
                    value: OptionalProperty[___std__.str, ___builtins_1__.str]
                __linkprops__: __lprops__

                def __init__(
                    self,
                    obj: schema.Parameter,
                    /,
                    *,
                    index: ___builtins_3__.int | None = None,
                    value: ___builtins_1__.str | None = None,
                ) -> None:
                    ...

                @classmethod
                def link(
                    cls,
                    obj: schema.Parameter,
                    /,
                    *,
                    index: ___builtins_3__.int | None = None,
                    value: ___builtins_1__.str | None = None,
                ) -> Self:
                    ...

        if not TYPE_CHECKING:
            @LazyClassProperty[type]
            @classmethod
            def params(cls) -> type:
                class Constraint__params(
                    CallableObject.__links__.params,
                    ___schema__.Parameter,
                    ProxyModel[___schema__.Parameter],
                ):
                    """link schema::Constraint.params: schema::Parameter"""
                    class __lprops__(
                        CallableObject.__links__.params.__lprops__,
                    ):
                        class __gel_reflection__(
                            CallableObject.__links__.params.__lprops__.__gel_reflection__,
                        ):
                            id = UUID(int=262009166219392732690753003575503864799)
                            name = SchemaPath('params')
                            @LazyClassProperty["dict[str, GelPointerReflection]"]
                            @classmethod
                            def pointers(
                                cls,
                            ) -> dict[str, GelPointerReflection]:
                                my_ptrs: dict[str, GelPointerReflection] = {
                                    'index': GelPointerReflection(
                                        name='index',
                                        type=SchemaPath('std', 'int64'),
                                        typexpr='std::int64',
                                        kind=PointerKind('Property'),
                                        cardinality=pydantic.Cardinality('AtMostOne'),
                                        computed=False,
                                        readonly=False,
                                        has_default=False,
                                        properties=None,
                                    ),
                                    'value': GelPointerReflection(
                                        name='value',
                                        type=SchemaPath('std', 'str'),
                                        typexpr='std::str',
                                        kind=PointerKind('Property'),
                                        cardinality=pydantic.Cardinality('AtMostOne'),
                                        computed=False,
                                        readonly=False,
                                        has_default=False,
                                        properties=None,
                                    ),
                                }
                                return (
                                    my_ptrs
                                    | CallableObject.__links__.params.__lprops__.__gel_reflection__.pointers
                                )


                        index: OptionalProperty[std.int64, ___builtins_3__.int]
                        value: OptionalProperty[std.str, ___builtins_1__.str]
                    __linkprops__: __lprops__

                    def __init__(self, obj, /, **link_props) -> None:
                        ProxyModel.__init__(self, obj)
                        lprops = self.__class__.__lprops__(**link_props)
                        object.__setattr__(self, "__linkprops__", lprops)

                    @classmethod
                    def link(cls, obj, /, **link_props) -> Self:
                        return cls(obj, **link_props)

                Constraint__params.__name__ = 'params'
                Constraint__params.__qualname__ = 'Constraint.params'
                return Constraint__params
    class __links_partial__(
        CallableObject.__links_partial__,
        InheritingObject.__links_partial__,
    ):
        if TYPE_CHECKING:
            class params(  # type: ignore [misc]
                CallableObject.__links_partial__.params,
                schema.Parameter.__variants__.Partial,
                ProxyModel[schema.Parameter.__variants__.Partial],
            ):
                """link schema::Constraint.params: schema::Parameter"""
                class __lprops__(
                    CallableObject.__links_partial__.params.__lprops__,
                ):
                    class __gel_reflection__(
                        CallableObject.__links_partial__.params.__lprops__.__gel_reflection__,
                    ):
                        id = UUID(int=262009166219392732690753003575503864799)
                        name = SchemaPath('params')
                        @LazyClassProperty["dict[str, GelPointerReflection]"]
                        @classmethod
                        def pointers(cls) -> dict[str, GelPointerReflection]:
                            my_ptrs: dict[str, GelPointerReflection] = {
                                'index': GelPointerReflection(
                                    name='index',
                                    type=SchemaPath('std', 'int64'),
                                    typexpr='std::int64',
                                    kind=PointerKind('Property'),
                                    cardinality=pydantic.Cardinality('AtMostOne'),
                                    computed=False,
                                    readonly=False,
                                    has_default=False,
                                    properties=None,
                                ),
                                'value': GelPointerReflection(
                                    name='value',
                                    type=SchemaPath('std', 'str'),
                                    typexpr='std::str',
                                    kind=PointerKind('Property'),
                                    cardinality=pydantic.Cardinality('AtMostOne'),
                                    computed=False,
                                    readonly=False,
                                    has_default=False,
                                    properties=None,
                                ),
                            }
                            return (
                                my_ptrs
                                | CallableObject.__links_partial__.params.__lprops__.__gel_reflection__.pointers
                            )


                    index: OptionalProperty[___std__.int64, ___builtins_3__.int]
                    value: OptionalProperty[___std__.str, ___builtins_1__.str]
                __linkprops__: __lprops__

                def __init__(
                    self,
                    obj: schema.Parameter.__variants__.Partial,
                    /,
                    *,
                    index: ___builtins_3__.int | None = None,
                    value: ___builtins_1__.str | None = None,
                ) -> None:
                    ...

                @classmethod
                def link(
                    cls,
                    obj: schema.Parameter.__variants__.Partial,
                    /,
                    *,
                    index: ___builtins_3__.int | None = None,
                    value: ___builtins_1__.str | None = None,
                ) -> Self:
                    ...

        if not TYPE_CHECKING:
            @LazyClassProperty[type]
            @classmethod
            def params(cls) -> type:
                class Constraint__params(  # type: ignore [misc]
                    CallableObject.__links_partial__.params,
                    ___schema__.Parameter.__variants__.Partial,
                    ProxyModel[___schema__.Parameter.__variants__.Partial],
                ):
                    """link schema::Constraint.params: schema::Parameter"""
                    class __lprops__(
                        CallableObject.__links_partial__.params.__lprops__,
                    ):
                        class __gel_reflection__(
                            CallableObject.__links_partial__.params.__lprops__.__gel_reflection__,
                        ):
                            id = UUID(int=262009166219392732690753003575503864799)
                            name = SchemaPath('params')
                            @LazyClassProperty["dict[str, GelPointerReflection]"]
                            @classmethod
                            def pointers(
                                cls,
                            ) -> dict[str, GelPointerReflection]:
                                my_ptrs: dict[str, GelPointerReflection] = {
                                    'index': GelPointerReflection(
                                        name='index',
                                        type=SchemaPath('std', 'int64'),
                                        typexpr='std::int64',
                                        kind=PointerKind('Property'),
                                        cardinality=pydantic.Cardinality('AtMostOne'),
                                        computed=False,
                                        readonly=False,
                                        has_default=False,
                                        properties=None,
                                    ),
                                    'value': GelPointerReflection(
                                        name='value',
                                        type=SchemaPath('std', 'str'),
                                        typexpr='std::str',
                                        kind=PointerKind('Property'),
                                        cardinality=pydantic.Cardinality('AtMostOne'),
                                        computed=False,
                                        readonly=False,
                                        has_default=False,
                                        properties=None,
                                    ),
                                }
                                return (
                                    my_ptrs
                                    | CallableObject.__links_partial__.params.__lprops__.__gel_reflection__.pointers
                                )


                        index: OptionalProperty[std.int64, ___builtins_3__.int]
                        value: OptionalProperty[std.str, ___builtins_1__.str]
                    __linkprops__: __lprops__

                    def __init__(self, obj, /, **link_props) -> None:
                        ProxyModel.__init__(self, obj)
                        lprops = self.__class__.__lprops__(**link_props)
                        object.__setattr__(self, "__linkprops__", lprops)

                    @classmethod
                    def link(cls, obj, /, **link_props) -> Self:
                        return cls(obj, **link_props)

                Constraint__params.__name__ = 'params'
                Constraint__params.__qualname__ = 'Constraint.params'
                return Constraint__params

if not TYPE_CHECKING:
    Constraint.__variants__.Base = Constraint



#
# type schema::Index
#
class __Index_typeof_base__(
    __InheritingObject_typeof_base__,
    __AnnotationSubject_typeof_base__,
):
    class __gel_reflection__(
        __InheritingObject_typeof_base__.__gel_reflection__,
        __AnnotationSubject_typeof_base__.__gel_reflection__,
    ):
        id = UUID(int=296166827572358402527332524133223664279)
        name = SchemaPath('schema', 'Index')
        @LazyClassProperty["dict[str, GelPointerReflection]"]
        @classmethod
        def pointers(cls) -> dict[str, GelPointerReflection]:
            my_ptrs: dict[str, GelPointerReflection] = {
                'expr': GelPointerReflection(
                    name='expr',
                    type=SchemaPath('std', 'str'),
                    typexpr='std::str',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
                'except_expr': GelPointerReflection(
                    name='except_expr',
                    type=SchemaPath('std', 'str'),
                    typexpr='std::str',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
                'deferrability': GelPointerReflection(
                    name='deferrability',
                    type=SchemaPath('schema', 'IndexDeferrability'),
                    typexpr='schema::IndexDeferrability',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
                'deferred': GelPointerReflection(
                    name='deferred',
                    type=SchemaPath('std', 'bool'),
                    typexpr='std::bool',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
                'kwargs': GelPointerReflection(
                    name='kwargs',
                    type=SchemaPath('array<tuple<name:std::str, expr:std::str>>'),
                    typexpr='array<tuple<name:std::str, expr:std::str>>',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
                'params': GelPointerReflection(
                    name='params',
                    type=SchemaPath('schema', 'Parameter'),
                    typexpr='schema::Parameter',
                    kind=PointerKind('Link'),
                    cardinality=pydantic.Cardinality('Many'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={
                    'index': GelPointerReflection(
                    name='index',
                    type=SchemaPath('std', 'int64'),
                    typexpr='std::int64',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties=None,
                ),
                },
                ),
            }
            return (
                my_ptrs
                | __InheritingObject_typeof_base__.__gel_reflection__.pointers
                | __AnnotationSubject_typeof_base__.__gel_reflection__.pointers
            )

        @LazyClassProperty["schema.ObjectType"]
        @classmethod
        def object(cls) -> schema.ObjectType:
            from ... import schema as ___schema_1__
            return ___schema_1__.ObjectType(
                id=UUID(int=296166827572358402527332524133223664279),
                name='schema::Index',
                builtin=True,
                internal=False,
                abstract=False,
                final=False,
                compound_type=False,
            )

class __Index_typeof__(
    __InheritingObject_typeof__,
    __AnnotationSubject_typeof__,
    __Index_typeof_base__,
):
    class __typeof__(
        __InheritingObject_typeof__.__typeof__,
        __AnnotationSubject_typeof__.__typeof__,
    ):
        expr = TypeAliasType('expr', 'OptionalProperty[std.str, builtins.str]')
        except_expr = TypeAliasType('except_expr', 'OptionalProperty[std.str, builtins.str]')
        deferrability = TypeAliasType('deferrability', 'OptionalProperty[IndexDeferrability, ___builtins_1__.str]')
        deferred = TypeAliasType('deferred', 'OptionalProperty[std.bool, bool]')
        kwargs = TypeAliasType('kwargs', 'OptionalProperty[___pydantic__.Array[NameExpr_Tuple_9eMVFg], list[tuple[builtins.str, builtins.str]]]')
        params = TypeAliasType('params', 'MultiLinkWithProps[Index.__links__.params, Parameter]')


class __Index_typeof_partial__(
    __InheritingObject_typeof_partial__,
    __AnnotationSubject_typeof_partial__,
    __Index_typeof_base__,
):
    class __typeof__(
        __InheritingObject_typeof_partial__.__typeof__,
        __AnnotationSubject_typeof_partial__.__typeof__,
    ):
        expr = TypeAliasType('expr', 'OptionalProperty[std.str, builtins.str]')
        except_expr = TypeAliasType('except_expr', 'OptionalProperty[std.str, builtins.str]')
        deferrability = TypeAliasType('deferrability', 'OptionalProperty[IndexDeferrability, ___builtins_1__.str]')
        deferred = TypeAliasType('deferred', 'OptionalProperty[std.bool, bool]')
        kwargs = TypeAliasType('kwargs', 'OptionalProperty[___pydantic__.Array[NameExpr_Tuple_9eMVFg], list[tuple[builtins.str, builtins.str]]]')
        params = TypeAliasType('params', 'MultiLinkWithProps[Index.__links__.params | Index.__links_partial__.params, Parameter]')


class Index(
    __Index_typeof__,
    InheritingObject,
    AnnotationSubject,
    __gel_type_id__=UUID(int=296166827572358402527332524133223664279),
):
    if TYPE_CHECKING:
        def __init__(
            self,
            /,
            *,
            id: UUID | DefaultValue = DEFAULT_VALUE,
            name: builtins.str,
            internal: bool | DefaultValue = DEFAULT_VALUE,
            builtin: bool | DefaultValue = DEFAULT_VALUE,
            computed_fields: list[builtins.str] | None = None,
            annotations: Iterable[Annotation] = [],
            abstract: bool | None | DefaultValue = DEFAULT_VALUE,
            final: bool,
            inherited_fields: list[builtins.str] | None = None,
            bases: Iterable[InheritingObject] = [],
            ancestors: Iterable[InheritingObject] = [],
            expr: builtins.str | None = None,
            except_expr: builtins.str | None = None,
            deferrability: ___builtins_1__.str | None = None,
            deferred: bool | None = None,
            kwargs: list[tuple[builtins.str, builtins.str]] | None = None,
            params: Iterable[Parameter] = [],
        ) -> None:
            """Create a new schema::Index instance from keyword arguments.

            Call db.save() on the returned object to persist it in the database.
            """
            ...

    if TYPE_CHECKING:
        @classmethod
        def update(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
            abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            inherited_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            bases: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            ancestors: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            except_expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            deferrability: type[IndexDeferrability] | UnspecifiedType = Unspecified,
            deferred: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            kwargs: type[___pydantic__.Array[std___types__.NameExpr_Tuple_9eMVFg]] | UnspecifiedType = Unspecified,
            params: type[schema.Parameter] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Update schema::Index instances in the database.
            """
            ...

        @classmethod
        def select(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: PathAlias | Literal["*"],
            id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Annotation] | UnspecifiedType = Unspecified,
            abstract: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            final: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            inherited_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            bases: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            ancestors: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            expr: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            except_expr: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            deferrability: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[IndexDeferrability] | UnspecifiedType = Unspecified,
            deferred: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            kwargs: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[std___types__.NameExpr_Tuple_9eMVFg]] | UnspecifiedType = Unspecified,
            params: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Parameter] | UnspecifiedType = Unspecified,
            **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
        ) -> type[Self]:
            """Fetch schema::Index instances from the database.
            """
            ...

        @classmethod
        def filter(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], type[___std__.bool]],
            id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
            abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            final: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            inherited_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            bases: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            ancestors: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            except_expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            deferrability: type[IndexDeferrability] | UnspecifiedType = Unspecified,
            deferred: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            kwargs: type[___pydantic__.Array[std___types__.NameExpr_Tuple_9eMVFg]] | UnspecifiedType = Unspecified,
            params: type[schema.Parameter] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Fetch schema::Index instances from the database.
            """
            ...

        @classmethod
        def order_by(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
            id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            abstract: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            final: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            expr: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            except_expr: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            deferred: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Specify the sort order for the selection"""
            ...


    class __variants__(
        InheritingObject.__variants__,
        AnnotationSubject.__variants__,
    ):
        class Base(
            __Index_typeof__,
            InheritingObject.__variants__.Base,
            AnnotationSubject.__variants__.Base,
            __gel_variant__="Base",
        ):
            if TYPE_CHECKING:
                def __init__(
                    self,
                    /,
                    *,
                    id: UUID | DefaultValue = DEFAULT_VALUE,
                    name: builtins.str,
                    internal: bool | DefaultValue = DEFAULT_VALUE,
                    builtin: bool | DefaultValue = DEFAULT_VALUE,
                    computed_fields: list[builtins.str] | None = None,
                    annotations: Iterable[Annotation] = [],
                    abstract: bool | None | DefaultValue = DEFAULT_VALUE,
                    final: bool,
                    inherited_fields: list[builtins.str] | None = None,
                    bases: Iterable[InheritingObject] = [],
                    ancestors: Iterable[InheritingObject] = [],
                    expr: builtins.str | None = None,
                    except_expr: builtins.str | None = None,
                    deferrability: ___builtins_1__.str | None = None,
                    deferred: bool | None = None,
                    kwargs: list[tuple[builtins.str, builtins.str]] | None = None,
                    params: Iterable[Parameter] = [],
                ) -> None:
                    """Create a new schema::Index instance from keyword arguments.

                    Call db.save() on the returned object to persist it in the database.
                    """
                    ...

            if TYPE_CHECKING:
                @classmethod
                def update(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
                    abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    inherited_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    bases: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    ancestors: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    except_expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    deferrability: type[IndexDeferrability] | UnspecifiedType = Unspecified,
                    deferred: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    kwargs: type[___pydantic__.Array[std___types__.NameExpr_Tuple_9eMVFg]] | UnspecifiedType = Unspecified,
                    params: type[schema.Parameter] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Update schema::Index instances in the database.
                    """
                    ...

                @classmethod
                def select(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: PathAlias | Literal["*"],
                    id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Annotation] | UnspecifiedType = Unspecified,
                    abstract: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    final: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    inherited_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    bases: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    ancestors: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    expr: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    except_expr: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    deferrability: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[IndexDeferrability] | UnspecifiedType = Unspecified,
                    deferred: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    kwargs: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[std___types__.NameExpr_Tuple_9eMVFg]] | UnspecifiedType = Unspecified,
                    params: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Parameter] | UnspecifiedType = Unspecified,
                    **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
                ) -> type[Self]:
                    """Fetch schema::Index instances from the database.
                    """
                    ...

                @classmethod
                def filter(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], type[___std__.bool]],
                    id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
                    abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    final: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    inherited_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    bases: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    ancestors: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    except_expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    deferrability: type[IndexDeferrability] | UnspecifiedType = Unspecified,
                    deferred: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    kwargs: type[___pydantic__.Array[std___types__.NameExpr_Tuple_9eMVFg]] | UnspecifiedType = Unspecified,
                    params: type[schema.Parameter] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Fetch schema::Index instances from the database.
                    """
                    ...

                @classmethod
                def order_by(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
                    id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    abstract: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    final: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    expr: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    except_expr: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    deferred: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Specify the sort order for the selection"""
                    ...

        class Required(
            Base,
            InheritingObject.__variants__.Required,
            AnnotationSubject.__variants__.Required,
            __gel_variant__="Required",
        ):
            pass

        class PartialBase(  # type: ignore [misc, unused-ignore]
            __Index_typeof_partial__,
            Base,
            InheritingObject.__variants__.PartialBase,
            AnnotationSubject.__variants__.PartialBase,
            __gel_variant__="PartialBase",
        ):
            pass

        class Partial(  # type: ignore [misc, unused-ignore]
            PartialBase,
            InheritingObject.__variants__.Partial,
            AnnotationSubject.__variants__.Partial,
            __gel_variant__="Partial",
        ):
            expr: OptionalProperty[std.str, builtins.str]
            except_expr: OptionalProperty[std.str, builtins.str]
            deferrability: OptionalProperty[IndexDeferrability, ___builtins_1__.str]
            deferred: OptionalProperty[std.bool, bool]
            kwargs: OptionalProperty[___pydantic__.Array[NameExpr_Tuple_9eMVFg], list[tuple[builtins.str, builtins.str]]]
            params: MultiLinkWithProps[Index.__links__.params | Index.__links_partial__.params, ___schema__.Parameter]


        Any = TypeVar("Any", bound="Index | Base | Required | Partial")
    class __links__(InheritingObject.__links__, AnnotationSubject.__links__):
        if TYPE_CHECKING:
            class params(schema.Parameter, ProxyModel[schema.Parameter]):
                """link schema::Index.params: schema::Parameter"""
                class __lprops__(GelLinkModel):
                    class __gel_reflection__(GelLinkModel.__gel_reflection__):
                        id = UUID(int=162762697189557726191169390933175400992)
                        name = SchemaPath('params')
                        @LazyClassProperty["dict[str, GelPointerReflection]"]
                        @classmethod
                        def pointers(cls) -> dict[str, GelPointerReflection]:
                            my_ptrs: dict[str, GelPointerReflection] = {
                                'index': GelPointerReflection(
                                    name='index',
                                    type=SchemaPath('std', 'int64'),
                                    typexpr='std::int64',
                                    kind=PointerKind('Property'),
                                    cardinality=pydantic.Cardinality('AtMostOne'),
                                    computed=False,
                                    readonly=False,
                                    has_default=False,
                                    properties=None,
                                ),
                            }
                            return my_ptrs


                    index: OptionalProperty[___std__.int64, ___builtins_3__.int]
                __linkprops__: __lprops__

                def __init__(
                    self,
                    obj: schema.Parameter,
                    /,
                    *,
                    index: ___builtins_3__.int | None = None,
                ) -> None:
                    ...

                @classmethod
                def link(
                    cls,
                    obj: schema.Parameter,
                    /,
                    *,
                    index: ___builtins_3__.int | None = None,
                ) -> Self:
                    ...

        if not TYPE_CHECKING:
            @LazyClassProperty[type]
            @classmethod
            def params(cls) -> type:
                class Index__params(
                    ___schema__.Parameter,
                    ProxyModel[___schema__.Parameter],
                ):
                    """link schema::Index.params: schema::Parameter"""
                    class __lprops__(GelLinkModel):
                        class __gel_reflection__(
                            GelLinkModel.__gel_reflection__,
                        ):
                            id = UUID(int=162762697189557726191169390933175400992)
                            name = SchemaPath('params')
                            @LazyClassProperty["dict[str, GelPointerReflection]"]
                            @classmethod
                            def pointers(
                                cls,
                            ) -> dict[str, GelPointerReflection]:
                                my_ptrs: dict[str, GelPointerReflection] = {
                                    'index': GelPointerReflection(
                                        name='index',
                                        type=SchemaPath('std', 'int64'),
                                        typexpr='std::int64',
                                        kind=PointerKind('Property'),
                                        cardinality=pydantic.Cardinality('AtMostOne'),
                                        computed=False,
                                        readonly=False,
                                        has_default=False,
                                        properties=None,
                                    ),
                                }
                                return my_ptrs


                        index: OptionalProperty[std.int64, ___builtins_3__.int]
                    __linkprops__: __lprops__

                    def __init__(self, obj, /, **link_props) -> None:
                        ProxyModel.__init__(self, obj)
                        lprops = self.__class__.__lprops__(**link_props)
                        object.__setattr__(self, "__linkprops__", lprops)

                    @classmethod
                    def link(cls, obj, /, **link_props) -> Self:
                        return cls(obj, **link_props)

                Index__params.__name__ = 'params'
                Index__params.__qualname__ = 'Index.params'
                return Index__params
    class __links_partial__(
        InheritingObject.__links_partial__,
        AnnotationSubject.__links_partial__,
    ):
        if TYPE_CHECKING:
            class params(  # type: ignore [misc]
                schema.Parameter.__variants__.Partial,
                ProxyModel[schema.Parameter.__variants__.Partial],
            ):
                """link schema::Index.params: schema::Parameter"""
                class __lprops__(GelLinkModel):
                    class __gel_reflection__(GelLinkModel.__gel_reflection__):
                        id = UUID(int=162762697189557726191169390933175400992)
                        name = SchemaPath('params')
                        @LazyClassProperty["dict[str, GelPointerReflection]"]
                        @classmethod
                        def pointers(cls) -> dict[str, GelPointerReflection]:
                            my_ptrs: dict[str, GelPointerReflection] = {
                                'index': GelPointerReflection(
                                    name='index',
                                    type=SchemaPath('std', 'int64'),
                                    typexpr='std::int64',
                                    kind=PointerKind('Property'),
                                    cardinality=pydantic.Cardinality('AtMostOne'),
                                    computed=False,
                                    readonly=False,
                                    has_default=False,
                                    properties=None,
                                ),
                            }
                            return my_ptrs


                    index: OptionalProperty[___std__.int64, ___builtins_3__.int]
                __linkprops__: __lprops__

                def __init__(
                    self,
                    obj: schema.Parameter.__variants__.Partial,
                    /,
                    *,
                    index: ___builtins_3__.int | None = None,
                ) -> None:
                    ...

                @classmethod
                def link(
                    cls,
                    obj: schema.Parameter.__variants__.Partial,
                    /,
                    *,
                    index: ___builtins_3__.int | None = None,
                ) -> Self:
                    ...

        if not TYPE_CHECKING:
            @LazyClassProperty[type]
            @classmethod
            def params(cls) -> type:
                class Index__params(  # type: ignore [misc]
                    ___schema__.Parameter.__variants__.Partial,
                    ProxyModel[___schema__.Parameter.__variants__.Partial],
                ):
                    """link schema::Index.params: schema::Parameter"""
                    class __lprops__(GelLinkModel):
                        class __gel_reflection__(
                            GelLinkModel.__gel_reflection__,
                        ):
                            id = UUID(int=162762697189557726191169390933175400992)
                            name = SchemaPath('params')
                            @LazyClassProperty["dict[str, GelPointerReflection]"]
                            @classmethod
                            def pointers(
                                cls,
                            ) -> dict[str, GelPointerReflection]:
                                my_ptrs: dict[str, GelPointerReflection] = {
                                    'index': GelPointerReflection(
                                        name='index',
                                        type=SchemaPath('std', 'int64'),
                                        typexpr='std::int64',
                                        kind=PointerKind('Property'),
                                        cardinality=pydantic.Cardinality('AtMostOne'),
                                        computed=False,
                                        readonly=False,
                                        has_default=False,
                                        properties=None,
                                    ),
                                }
                                return my_ptrs


                        index: OptionalProperty[std.int64, ___builtins_3__.int]
                    __linkprops__: __lprops__

                    def __init__(self, obj, /, **link_props) -> None:
                        ProxyModel.__init__(self, obj)
                        lprops = self.__class__.__lprops__(**link_props)
                        object.__setattr__(self, "__linkprops__", lprops)

                    @classmethod
                    def link(cls, obj, /, **link_props) -> Self:
                        return cls(obj, **link_props)

                Index__params.__name__ = 'params'
                Index__params.__qualname__ = 'Index.params'
                return Index__params

if not TYPE_CHECKING:
    Index.__variants__.Base = Index



#
# type schema::Rewrite
#
class __Rewrite_typeof_base__(
    __InheritingObject_typeof_base__,
    __AnnotationSubject_typeof_base__,
):
    class __gel_reflection__(
        __InheritingObject_typeof_base__.__gel_reflection__,
        __AnnotationSubject_typeof_base__.__gel_reflection__,
    ):
        id = UUID(int=284463082220370517579652730068569906415)
        name = SchemaPath('schema', 'Rewrite')
        @LazyClassProperty["dict[str, GelPointerReflection]"]
        @classmethod
        def pointers(cls) -> dict[str, GelPointerReflection]:
            my_ptrs: dict[str, GelPointerReflection] = {
                'kind': GelPointerReflection(
                    name='kind',
                    type=SchemaPath('schema', 'TriggerKind'),
                    typexpr='schema::TriggerKind',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('One'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
                'expr': GelPointerReflection(
                    name='expr',
                    type=SchemaPath('std', 'str'),
                    typexpr='std::str',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('One'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
                'subject': GelPointerReflection(
                    name='subject',
                    type=SchemaPath('schema', 'Pointer'),
                    typexpr='schema::Pointer',
                    kind=PointerKind('Link'),
                    cardinality=pydantic.Cardinality('One'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
            }
            return (
                my_ptrs
                | __InheritingObject_typeof_base__.__gel_reflection__.pointers
                | __AnnotationSubject_typeof_base__.__gel_reflection__.pointers
            )

        @LazyClassProperty["schema.ObjectType"]
        @classmethod
        def object(cls) -> schema.ObjectType:
            from ... import schema as ___schema_1__
            return ___schema_1__.ObjectType(
                id=UUID(int=284463082220370517579652730068569906415),
                name='schema::Rewrite',
                builtin=True,
                internal=False,
                abstract=False,
                final=False,
                compound_type=False,
            )

class __Rewrite_typeof__(
    __InheritingObject_typeof__,
    __AnnotationSubject_typeof__,
    __Rewrite_typeof_base__,
):
    class __typeof__(
        __InheritingObject_typeof__.__typeof__,
        __AnnotationSubject_typeof__.__typeof__,
    ):
        kind = TypeAliasType('kind', 'TriggerKind')
        expr = TypeAliasType('expr', 'std.str')
        subject = TypeAliasType('subject', 'Pointer')


class __Rewrite_typeof_partial__(
    __InheritingObject_typeof_partial__,
    __AnnotationSubject_typeof_partial__,
    __Rewrite_typeof_base__,
):
    class __typeof__(
        __InheritingObject_typeof_partial__.__typeof__,
        __AnnotationSubject_typeof_partial__.__typeof__,
    ):
        kind = TypeAliasType('kind', 'OptionalProperty[TriggerKind, ___builtins_1__.str]')
        expr = TypeAliasType('expr', 'OptionalProperty[std.str, builtins.str]')
        subject = TypeAliasType('subject', 'Pointer | Pointer.__variants__.Partial')


class Rewrite(
    __Rewrite_typeof__,
    InheritingObject,
    AnnotationSubject,
    __gel_type_id__=UUID(int=284463082220370517579652730068569906415),
):
    if TYPE_CHECKING:
        def __init__(
            self,
            /,
            *,
            id: UUID | DefaultValue = DEFAULT_VALUE,
            name: builtins.str,
            internal: bool | DefaultValue = DEFAULT_VALUE,
            builtin: bool | DefaultValue = DEFAULT_VALUE,
            computed_fields: list[builtins.str] | None = None,
            annotations: Iterable[Annotation] = [],
            abstract: bool | None | DefaultValue = DEFAULT_VALUE,
            final: bool,
            inherited_fields: list[builtins.str] | None = None,
            bases: Iterable[InheritingObject] = [],
            ancestors: Iterable[InheritingObject] = [],
            kind: ___builtins_1__.str,
            expr: builtins.str,
            subject: Pointer | None = None,
        ) -> None:
            """Create a new schema::Rewrite instance from keyword arguments.

            Call db.save() on the returned object to persist it in the database.
            """
            ...

    if TYPE_CHECKING:
        @classmethod
        def update(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
            abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            inherited_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            bases: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            ancestors: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            kind: type[TriggerKind] | UnspecifiedType = Unspecified,
            expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            subject: type[schema.Pointer] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Update schema::Rewrite instances in the database.
            """
            ...

        @classmethod
        def select(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: PathAlias | Literal["*"],
            id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Annotation] | UnspecifiedType = Unspecified,
            abstract: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            final: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            inherited_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            bases: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            ancestors: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            kind: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[TriggerKind] | UnspecifiedType = Unspecified,
            expr: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            subject: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Pointer] | UnspecifiedType = Unspecified,
            **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
        ) -> type[Self]:
            """Fetch schema::Rewrite instances from the database.
            """
            ...

        @classmethod
        def filter(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], type[___std__.bool]],
            id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
            abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            final: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            inherited_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            bases: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            ancestors: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            kind: type[TriggerKind] | UnspecifiedType = Unspecified,
            expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            subject: type[schema.Pointer] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Fetch schema::Rewrite instances from the database.
            """
            ...

        @classmethod
        def order_by(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
            id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            abstract: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            final: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            expr: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Specify the sort order for the selection"""
            ...


    class __variants__(
        InheritingObject.__variants__,
        AnnotationSubject.__variants__,
    ):
        class Base(
            __Rewrite_typeof__,
            InheritingObject.__variants__.Base,
            AnnotationSubject.__variants__.Base,
            __gel_variant__="Base",
        ):
            if TYPE_CHECKING:
                def __init__(
                    self,
                    /,
                    *,
                    id: UUID | DefaultValue = DEFAULT_VALUE,
                    name: builtins.str,
                    internal: bool | DefaultValue = DEFAULT_VALUE,
                    builtin: bool | DefaultValue = DEFAULT_VALUE,
                    computed_fields: list[builtins.str] | None = None,
                    annotations: Iterable[Annotation] = [],
                    abstract: bool | None | DefaultValue = DEFAULT_VALUE,
                    final: bool,
                    inherited_fields: list[builtins.str] | None = None,
                    bases: Iterable[InheritingObject] = [],
                    ancestors: Iterable[InheritingObject] = [],
                    kind: ___builtins_1__.str,
                    expr: builtins.str,
                    subject: Pointer | None = None,
                ) -> None:
                    """Create a new schema::Rewrite instance from keyword arguments.

                    Call db.save() on the returned object to persist it in the database.
                    """
                    ...

            if TYPE_CHECKING:
                @classmethod
                def update(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
                    abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    inherited_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    bases: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    ancestors: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    kind: type[TriggerKind] | UnspecifiedType = Unspecified,
                    expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    subject: type[schema.Pointer] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Update schema::Rewrite instances in the database.
                    """
                    ...

                @classmethod
                def select(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: PathAlias | Literal["*"],
                    id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Annotation] | UnspecifiedType = Unspecified,
                    abstract: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    final: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    inherited_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    bases: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    ancestors: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    kind: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[TriggerKind] | UnspecifiedType = Unspecified,
                    expr: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    subject: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Pointer] | UnspecifiedType = Unspecified,
                    **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
                ) -> type[Self]:
                    """Fetch schema::Rewrite instances from the database.
                    """
                    ...

                @classmethod
                def filter(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], type[___std__.bool]],
                    id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
                    abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    final: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    inherited_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    bases: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    ancestors: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    kind: type[TriggerKind] | UnspecifiedType = Unspecified,
                    expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    subject: type[schema.Pointer] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Fetch schema::Rewrite instances from the database.
                    """
                    ...

                @classmethod
                def order_by(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
                    id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    abstract: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    final: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    expr: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Specify the sort order for the selection"""
                    ...

        class Required(
            Base,
            InheritingObject.__variants__.Required,
            AnnotationSubject.__variants__.Required,
            __gel_variant__="Required",
        ):
            kind: TriggerKind
            expr: std.str
            subject: ___schema__.Pointer

        class PartialBase(  # type: ignore [misc, unused-ignore]
            __Rewrite_typeof_partial__,
            Base,
            InheritingObject.__variants__.PartialBase,
            AnnotationSubject.__variants__.PartialBase,
            __gel_variant__="PartialBase",
        ):
            pass

        class Partial(  # type: ignore [misc, unused-ignore]
            PartialBase,
            InheritingObject.__variants__.Partial,
            AnnotationSubject.__variants__.Partial,
            __gel_variant__="Partial",
        ):
            kind: OptionalProperty[TriggerKind, ___builtins_1__.str]
            expr: OptionalProperty[std.str, builtins.str]
            subject: ___schema__.Pointer | ___schema__.Pointer.__variants__.Partial


        Any = TypeVar("Any", bound="Rewrite | Base | Required | Partial")
    class __links__(InheritingObject.__links__, AnnotationSubject.__links__):
        pass
    class __links_partial__(
        InheritingObject.__links_partial__,
        AnnotationSubject.__links_partial__,
    ):
        pass

if not TYPE_CHECKING:
    Rewrite.__variants__.Base = Rewrite



#
# type schema::Trigger
#
class __Trigger_typeof_base__(
    __InheritingObject_typeof_base__,
    __AnnotationSubject_typeof_base__,
):
    class __gel_reflection__(
        __InheritingObject_typeof_base__.__gel_reflection__,
        __AnnotationSubject_typeof_base__.__gel_reflection__,
    ):
        id = UUID(int=57756558562494904739428121894352067074)
        name = SchemaPath('schema', 'Trigger')
        @LazyClassProperty["dict[str, GelPointerReflection]"]
        @classmethod
        def pointers(cls) -> dict[str, GelPointerReflection]:
            my_ptrs: dict[str, GelPointerReflection] = {
                'timing': GelPointerReflection(
                    name='timing',
                    type=SchemaPath('schema', 'TriggerTiming'),
                    typexpr='schema::TriggerTiming',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('One'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
                'kinds': GelPointerReflection(
                    name='kinds',
                    type=SchemaPath('schema', 'TriggerKind'),
                    typexpr='schema::TriggerKind',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('Many'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
                'scope': GelPointerReflection(
                    name='scope',
                    type=SchemaPath('schema', 'TriggerScope'),
                    typexpr='schema::TriggerScope',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('One'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
                'expr': GelPointerReflection(
                    name='expr',
                    type=SchemaPath('std', 'str'),
                    typexpr='std::str',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
                'condition': GelPointerReflection(
                    name='condition',
                    type=SchemaPath('std', 'str'),
                    typexpr='std::str',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
                'subject': GelPointerReflection(
                    name='subject',
                    type=SchemaPath('schema', 'ObjectType'),
                    typexpr='schema::ObjectType',
                    kind=PointerKind('Link'),
                    cardinality=pydantic.Cardinality('One'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
            }
            return (
                my_ptrs
                | __InheritingObject_typeof_base__.__gel_reflection__.pointers
                | __AnnotationSubject_typeof_base__.__gel_reflection__.pointers
            )

        @LazyClassProperty["schema.ObjectType"]
        @classmethod
        def object(cls) -> schema.ObjectType:
            from ... import schema as ___schema_1__
            return ___schema_1__.ObjectType(
                id=UUID(int=57756558562494904739428121894352067074),
                name='schema::Trigger',
                builtin=True,
                internal=False,
                abstract=False,
                final=False,
                compound_type=False,
            )

class __Trigger_typeof__(
    __InheritingObject_typeof__,
    __AnnotationSubject_typeof__,
    __Trigger_typeof_base__,
):
    class __typeof__(
        __InheritingObject_typeof__.__typeof__,
        __AnnotationSubject_typeof__.__typeof__,
    ):
        timing = TypeAliasType('timing', 'TriggerTiming')
        kinds = TypeAliasType('kinds', 'MultiProperty[TriggerKind, ___builtins_1__.str]')
        scope = TypeAliasType('scope', 'TriggerScope')
        expr = TypeAliasType('expr', 'OptionalProperty[std.str, builtins.str]')
        condition = TypeAliasType('condition', 'OptionalProperty[std.str, builtins.str]')
        subject = TypeAliasType('subject', 'ObjectType')


class __Trigger_typeof_partial__(
    __InheritingObject_typeof_partial__,
    __AnnotationSubject_typeof_partial__,
    __Trigger_typeof_base__,
):
    class __typeof__(
        __InheritingObject_typeof_partial__.__typeof__,
        __AnnotationSubject_typeof_partial__.__typeof__,
    ):
        timing = TypeAliasType('timing', 'OptionalProperty[TriggerTiming, ___builtins_1__.str]')
        kinds = TypeAliasType('kinds', 'MultiProperty[TriggerKind, ___builtins_1__.str]')
        scope = TypeAliasType('scope', 'OptionalProperty[TriggerScope, ___builtins_1__.str]')
        expr = TypeAliasType('expr', 'OptionalProperty[std.str, builtins.str]')
        condition = TypeAliasType('condition', 'OptionalProperty[std.str, builtins.str]')
        subject = TypeAliasType('subject', 'ObjectType | ObjectType.__variants__.Partial')


class Trigger(
    __Trigger_typeof__,
    InheritingObject,
    AnnotationSubject,
    __gel_type_id__=UUID(int=57756558562494904739428121894352067074),
):
    if TYPE_CHECKING:
        def __init__(
            self,
            /,
            *,
            id: UUID | DefaultValue = DEFAULT_VALUE,
            name: builtins.str,
            internal: bool | DefaultValue = DEFAULT_VALUE,
            builtin: bool | DefaultValue = DEFAULT_VALUE,
            computed_fields: list[builtins.str] | None = None,
            annotations: Iterable[Annotation] = [],
            abstract: bool | None | DefaultValue = DEFAULT_VALUE,
            final: bool,
            inherited_fields: list[builtins.str] | None = None,
            bases: Iterable[InheritingObject] = [],
            ancestors: Iterable[InheritingObject] = [],
            timing: ___builtins_1__.str,
            kinds: Iterable[___builtins_1__.str] = [],
            scope: ___builtins_1__.str,
            expr: builtins.str | None = None,
            condition: builtins.str | None = None,
            subject: ObjectType | None = None,
        ) -> None:
            """Create a new schema::Trigger instance from keyword arguments.

            Call db.save() on the returned object to persist it in the database.
            """
            ...

    if TYPE_CHECKING:
        @classmethod
        def update(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
            abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            inherited_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            bases: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            ancestors: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            timing: type[TriggerTiming] | UnspecifiedType = Unspecified,
            kinds: type[TriggerKind] | UnspecifiedType = Unspecified,
            scope: type[TriggerScope] | UnspecifiedType = Unspecified,
            expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            condition: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            subject: type[schema.ObjectType] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Update schema::Trigger instances in the database.
            """
            ...

        @classmethod
        def select(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: PathAlias | Literal["*"],
            id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Annotation] | UnspecifiedType = Unspecified,
            abstract: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            final: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            inherited_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            bases: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            ancestors: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            timing: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[TriggerTiming] | UnspecifiedType = Unspecified,
            kinds: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[TriggerKind] | UnspecifiedType = Unspecified,
            scope: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[TriggerScope] | UnspecifiedType = Unspecified,
            expr: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            condition: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            subject: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.ObjectType] | UnspecifiedType = Unspecified,
            **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
        ) -> type[Self]:
            """Fetch schema::Trigger instances from the database.
            """
            ...

        @classmethod
        def filter(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], type[___std__.bool]],
            id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
            abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            final: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            inherited_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            bases: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            ancestors: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            timing: type[TriggerTiming] | UnspecifiedType = Unspecified,
            kinds: type[TriggerKind] | UnspecifiedType = Unspecified,
            scope: type[TriggerScope] | UnspecifiedType = Unspecified,
            expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            condition: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            subject: type[schema.ObjectType] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Fetch schema::Trigger instances from the database.
            """
            ...

        @classmethod
        def order_by(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
            id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            abstract: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            final: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            expr: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            condition: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Specify the sort order for the selection"""
            ...


    class __variants__(
        InheritingObject.__variants__,
        AnnotationSubject.__variants__,
    ):
        class Base(
            __Trigger_typeof__,
            InheritingObject.__variants__.Base,
            AnnotationSubject.__variants__.Base,
            __gel_variant__="Base",
        ):
            if TYPE_CHECKING:
                def __init__(
                    self,
                    /,
                    *,
                    id: UUID | DefaultValue = DEFAULT_VALUE,
                    name: builtins.str,
                    internal: bool | DefaultValue = DEFAULT_VALUE,
                    builtin: bool | DefaultValue = DEFAULT_VALUE,
                    computed_fields: list[builtins.str] | None = None,
                    annotations: Iterable[Annotation] = [],
                    abstract: bool | None | DefaultValue = DEFAULT_VALUE,
                    final: bool,
                    inherited_fields: list[builtins.str] | None = None,
                    bases: Iterable[InheritingObject] = [],
                    ancestors: Iterable[InheritingObject] = [],
                    timing: ___builtins_1__.str,
                    kinds: Iterable[___builtins_1__.str] = [],
                    scope: ___builtins_1__.str,
                    expr: builtins.str | None = None,
                    condition: builtins.str | None = None,
                    subject: ObjectType | None = None,
                ) -> None:
                    """Create a new schema::Trigger instance from keyword arguments.

                    Call db.save() on the returned object to persist it in the database.
                    """
                    ...

            if TYPE_CHECKING:
                @classmethod
                def update(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
                    abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    inherited_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    bases: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    ancestors: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    timing: type[TriggerTiming] | UnspecifiedType = Unspecified,
                    kinds: type[TriggerKind] | UnspecifiedType = Unspecified,
                    scope: type[TriggerScope] | UnspecifiedType = Unspecified,
                    expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    condition: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    subject: type[schema.ObjectType] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Update schema::Trigger instances in the database.
                    """
                    ...

                @classmethod
                def select(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: PathAlias | Literal["*"],
                    id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Annotation] | UnspecifiedType = Unspecified,
                    abstract: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    final: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    inherited_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    bases: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    ancestors: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    timing: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[TriggerTiming] | UnspecifiedType = Unspecified,
                    kinds: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[TriggerKind] | UnspecifiedType = Unspecified,
                    scope: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[TriggerScope] | UnspecifiedType = Unspecified,
                    expr: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    condition: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    subject: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.ObjectType] | UnspecifiedType = Unspecified,
                    **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
                ) -> type[Self]:
                    """Fetch schema::Trigger instances from the database.
                    """
                    ...

                @classmethod
                def filter(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], type[___std__.bool]],
                    id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
                    abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    final: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    inherited_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    bases: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    ancestors: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    timing: type[TriggerTiming] | UnspecifiedType = Unspecified,
                    kinds: type[TriggerKind] | UnspecifiedType = Unspecified,
                    scope: type[TriggerScope] | UnspecifiedType = Unspecified,
                    expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    condition: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    subject: type[schema.ObjectType] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Fetch schema::Trigger instances from the database.
                    """
                    ...

                @classmethod
                def order_by(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
                    id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    abstract: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    final: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    expr: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    condition: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Specify the sort order for the selection"""
                    ...

        class Required(
            Base,
            InheritingObject.__variants__.Required,
            AnnotationSubject.__variants__.Required,
            __gel_variant__="Required",
        ):
            timing: TriggerTiming
            scope: TriggerScope
            subject: ___schema__.ObjectType

        class PartialBase(  # type: ignore [misc, unused-ignore]
            __Trigger_typeof_partial__,
            Base,
            InheritingObject.__variants__.PartialBase,
            AnnotationSubject.__variants__.PartialBase,
            __gel_variant__="PartialBase",
        ):
            pass

        class Partial(  # type: ignore [misc, unused-ignore]
            PartialBase,
            InheritingObject.__variants__.Partial,
            AnnotationSubject.__variants__.Partial,
            __gel_variant__="Partial",
        ):
            timing: OptionalProperty[TriggerTiming, ___builtins_1__.str]
            kinds: MultiProperty[TriggerKind, ___builtins_1__.str]
            scope: OptionalProperty[TriggerScope, ___builtins_1__.str]
            expr: OptionalProperty[std.str, builtins.str]
            condition: OptionalProperty[std.str, builtins.str]
            subject: ___schema__.ObjectType | ___schema__.ObjectType.__variants__.Partial


        Any = TypeVar("Any", bound="Trigger | Base | Required | Partial")
    class __links__(InheritingObject.__links__, AnnotationSubject.__links__):
        pass
    class __links_partial__(
        InheritingObject.__links_partial__,
        AnnotationSubject.__links_partial__,
    ):
        pass

if not TYPE_CHECKING:
    Trigger.__variants__.Base = Trigger



#
# type schema::PrimitiveType
#
class __PrimitiveType_typeof_base__(__Type_typeof_base__):
    class __gel_reflection__(__Type_typeof_base__.__gel_reflection__):
        id = UUID(int=289974081693672082889864807229328348553)
        name = SchemaPath('schema', 'PrimitiveType')
        @LazyClassProperty["dict[str, ___pydantic_1__.GelPointerReflection]"]
        @classmethod
        def pointers(cls) -> dict[str, ___pydantic_1__.GelPointerReflection]:
            my_ptrs: dict[str, ___pydantic_1__.GelPointerReflection] = {}
            return (my_ptrs | __Type_typeof_base__.__gel_reflection__.pointers)

        @LazyClassProperty["schema.ObjectType"]
        @classmethod
        def object(cls) -> schema.ObjectType:
            from ... import schema as ___schema_1__
            return ___schema_1__.ObjectType(
                id=UUID(int=289974081693672082889864807229328348553),
                name='schema::PrimitiveType',
                builtin=True,
                internal=False,
                abstract=True,
                final=False,
                compound_type=False,
            )

class __PrimitiveType_typeof__(__Type_typeof__, __PrimitiveType_typeof_base__):
    class __typeof__(__Type_typeof__.__typeof__):
        pass


class __PrimitiveType_typeof_partial__(
    __Type_typeof_partial__,
    __PrimitiveType_typeof_base__,
):
    class __typeof__(__Type_typeof_partial__.__typeof__):
        pass


class PrimitiveType(
    __PrimitiveType_typeof__,
    Type,
    __gel_type_id__=UUID(int=289974081693672082889864807229328348553),
):
    if TYPE_CHECKING:
        def __init__(
            self,
            /,
            *,
            id: UUID | DefaultValue = DEFAULT_VALUE,
            name: builtins.str,
            internal: bool | DefaultValue = DEFAULT_VALUE,
            builtin: bool | DefaultValue = DEFAULT_VALUE,
            computed_fields: list[builtins.str] | None = None,
            annotations: Iterable[Annotation] = [],
            abstract: bool | None | DefaultValue = DEFAULT_VALUE,
            final: bool,
            expr: builtins.str | None = None,
            from_alias: bool | None = None,
        ) -> None:
            """Create a new schema::PrimitiveType instance from keyword arguments.

            Call db.save() on the returned object to persist it in the database.
            """
            ...

    if TYPE_CHECKING:
        @classmethod
        def update(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
            abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            from_alias: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Update schema::PrimitiveType instances in the database.
            """
            ...

        @classmethod
        def select(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: PathAlias | Literal["*"],
            id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Annotation] | UnspecifiedType = Unspecified,
            abstract: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            final: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            expr: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            from_alias: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
        ) -> type[Self]:
            """Fetch schema::PrimitiveType instances from the database.
            """
            ...

        @classmethod
        def filter(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], type[___std__.bool]],
            id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
            abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            final: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            from_alias: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Fetch schema::PrimitiveType instances from the database.
            """
            ...

        @classmethod
        def order_by(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
            id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            abstract: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            final: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            expr: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            from_alias: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Specify the sort order for the selection"""
            ...


    class __variants__(Type.__variants__):
        class Base(
            __PrimitiveType_typeof__,
            Type.__variants__.Base,
            __gel_variant__="Base",
        ):
            if TYPE_CHECKING:
                def __init__(
                    self,
                    /,
                    *,
                    id: UUID | DefaultValue = DEFAULT_VALUE,
                    name: builtins.str,
                    internal: bool | DefaultValue = DEFAULT_VALUE,
                    builtin: bool | DefaultValue = DEFAULT_VALUE,
                    computed_fields: list[builtins.str] | None = None,
                    annotations: Iterable[Annotation] = [],
                    abstract: bool | None | DefaultValue = DEFAULT_VALUE,
                    final: bool,
                    expr: builtins.str | None = None,
                    from_alias: bool | None = None,
                ) -> None:
                    """Create a new schema::PrimitiveType instance from keyword arguments.

                    Call db.save() on the returned object to persist it in the database.
                    """
                    ...

            if TYPE_CHECKING:
                @classmethod
                def update(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
                    abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    from_alias: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Update schema::PrimitiveType instances in the database.
                    """
                    ...

                @classmethod
                def select(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: PathAlias | Literal["*"],
                    id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Annotation] | UnspecifiedType = Unspecified,
                    abstract: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    final: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    expr: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    from_alias: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
                ) -> type[Self]:
                    """Fetch schema::PrimitiveType instances from the database.
                    """
                    ...

                @classmethod
                def filter(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], type[___std__.bool]],
                    id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
                    abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    final: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    from_alias: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Fetch schema::PrimitiveType instances from the database.
                    """
                    ...

                @classmethod
                def order_by(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
                    id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    abstract: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    final: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    expr: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    from_alias: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Specify the sort order for the selection"""
                    ...

        class Required(
            Base,
            Type.__variants__.Required,
            __gel_variant__="Required",
        ):
            pass

        class PartialBase(  # type: ignore [misc, unused-ignore]
            __PrimitiveType_typeof_partial__,
            Base,
            Type.__variants__.PartialBase,
            __gel_variant__="PartialBase",
        ):
            pass

        class Partial(  # type: ignore [misc, unused-ignore]
            PartialBase,
            Type.__variants__.Partial,
            __gel_variant__="Partial",
        ):
            pass


        Any = TypeVar("Any", bound="PrimitiveType | Base | Required | Partial")
    class __links__(Type.__links__):
        pass
    class __links_partial__(Type.__links_partial__):
        pass

if not TYPE_CHECKING:
    PrimitiveType.__variants__.Base = PrimitiveType



#
# type schema::PseudoType
#
class __PseudoType_typeof_base__(
    __InheritingObject_typeof_base__,
    __Type_typeof_base__,
):
    class __gel_reflection__(
        __InheritingObject_typeof_base__.__gel_reflection__,
        __Type_typeof_base__.__gel_reflection__,
    ):
        id = UUID(int=11246368220525712114260003057526016480)
        name = SchemaPath('schema', 'PseudoType')
        @LazyClassProperty["dict[str, ___pydantic_1__.GelPointerReflection]"]
        @classmethod
        def pointers(cls) -> dict[str, ___pydantic_1__.GelPointerReflection]:
            my_ptrs: dict[str, ___pydantic_1__.GelPointerReflection] = {}
            return (
                my_ptrs
                | __InheritingObject_typeof_base__.__gel_reflection__.pointers
                | __Type_typeof_base__.__gel_reflection__.pointers
            )

        @LazyClassProperty["schema.ObjectType"]
        @classmethod
        def object(cls) -> schema.ObjectType:
            from ... import schema as ___schema_1__
            return ___schema_1__.ObjectType(
                id=UUID(int=11246368220525712114260003057526016480),
                name='schema::PseudoType',
                builtin=True,
                internal=False,
                abstract=False,
                final=False,
                compound_type=False,
            )

class __PseudoType_typeof__(
    __InheritingObject_typeof__,
    __Type_typeof__,
    __PseudoType_typeof_base__,
):
    class __typeof__(
        __InheritingObject_typeof__.__typeof__,
        __Type_typeof__.__typeof__,
    ):
        pass


class __PseudoType_typeof_partial__(
    __InheritingObject_typeof_partial__,
    __Type_typeof_partial__,
    __PseudoType_typeof_base__,
):
    class __typeof__(
        __InheritingObject_typeof_partial__.__typeof__,
        __Type_typeof_partial__.__typeof__,
    ):
        pass


class PseudoType(
    __PseudoType_typeof__,
    InheritingObject,
    Type,
    __gel_type_id__=UUID(int=11246368220525712114260003057526016480),
):
    if TYPE_CHECKING:
        def __init__(
            self,
            /,
            *,
            id: UUID | DefaultValue = DEFAULT_VALUE,
            name: builtins.str,
            internal: bool | DefaultValue = DEFAULT_VALUE,
            builtin: bool | DefaultValue = DEFAULT_VALUE,
            computed_fields: list[builtins.str] | None = None,
            annotations: Iterable[Annotation] = [],
            abstract: bool | None | DefaultValue = DEFAULT_VALUE,
            final: bool,
            expr: builtins.str | None = None,
            from_alias: bool | None = None,
            inherited_fields: list[builtins.str] | None = None,
            bases: Iterable[InheritingObject] = [],
            ancestors: Iterable[InheritingObject] = [],
        ) -> None:
            """Create a new schema::PseudoType instance from keyword arguments.

            Call db.save() on the returned object to persist it in the database.
            """
            ...

    if TYPE_CHECKING:
        @classmethod
        def update(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
            abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            from_alias: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            inherited_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            bases: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            ancestors: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Update schema::PseudoType instances in the database.
            """
            ...

        @classmethod
        def select(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: PathAlias | Literal["*"],
            id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Annotation] | UnspecifiedType = Unspecified,
            abstract: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            final: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            expr: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            from_alias: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            inherited_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            bases: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            ancestors: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
        ) -> type[Self]:
            """Fetch schema::PseudoType instances from the database.
            """
            ...

        @classmethod
        def filter(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], type[___std__.bool]],
            id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
            abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            final: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            from_alias: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            inherited_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            bases: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            ancestors: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Fetch schema::PseudoType instances from the database.
            """
            ...

        @classmethod
        def order_by(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
            id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            abstract: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            final: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            expr: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            from_alias: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Specify the sort order for the selection"""
            ...


    class __variants__(InheritingObject.__variants__, Type.__variants__):
        class Base(
            __PseudoType_typeof__,
            InheritingObject.__variants__.Base,
            Type.__variants__.Base,
            __gel_variant__="Base",
        ):
            if TYPE_CHECKING:
                def __init__(
                    self,
                    /,
                    *,
                    id: UUID | DefaultValue = DEFAULT_VALUE,
                    name: builtins.str,
                    internal: bool | DefaultValue = DEFAULT_VALUE,
                    builtin: bool | DefaultValue = DEFAULT_VALUE,
                    computed_fields: list[builtins.str] | None = None,
                    annotations: Iterable[Annotation] = [],
                    abstract: bool | None | DefaultValue = DEFAULT_VALUE,
                    final: bool,
                    expr: builtins.str | None = None,
                    from_alias: bool | None = None,
                    inherited_fields: list[builtins.str] | None = None,
                    bases: Iterable[InheritingObject] = [],
                    ancestors: Iterable[InheritingObject] = [],
                ) -> None:
                    """Create a new schema::PseudoType instance from keyword arguments.

                    Call db.save() on the returned object to persist it in the database.
                    """
                    ...

            if TYPE_CHECKING:
                @classmethod
                def update(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
                    abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    from_alias: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    inherited_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    bases: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    ancestors: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Update schema::PseudoType instances in the database.
                    """
                    ...

                @classmethod
                def select(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: PathAlias | Literal["*"],
                    id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Annotation] | UnspecifiedType = Unspecified,
                    abstract: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    final: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    expr: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    from_alias: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    inherited_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    bases: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    ancestors: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
                ) -> type[Self]:
                    """Fetch schema::PseudoType instances from the database.
                    """
                    ...

                @classmethod
                def filter(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], type[___std__.bool]],
                    id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
                    abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    final: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    from_alias: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    inherited_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    bases: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    ancestors: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Fetch schema::PseudoType instances from the database.
                    """
                    ...

                @classmethod
                def order_by(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
                    id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    abstract: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    final: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    expr: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    from_alias: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Specify the sort order for the selection"""
                    ...

        class Required(
            Base,
            InheritingObject.__variants__.Required,
            Type.__variants__.Required,
            __gel_variant__="Required",
        ):
            pass

        class PartialBase(  # type: ignore [misc, unused-ignore]
            __PseudoType_typeof_partial__,
            Base,
            InheritingObject.__variants__.PartialBase,
            Type.__variants__.PartialBase,
            __gel_variant__="PartialBase",
        ):
            pass

        class Partial(  # type: ignore [misc, unused-ignore]
            PartialBase,
            InheritingObject.__variants__.Partial,
            Type.__variants__.Partial,
            __gel_variant__="Partial",
        ):
            pass


        Any = TypeVar("Any", bound="PseudoType | Base | Required | Partial")
    class __links__(InheritingObject.__links__, Type.__links__):
        pass
    class __links_partial__(
        InheritingObject.__links_partial__,
        Type.__links_partial__,
    ):
        pass

if not TYPE_CHECKING:
    PseudoType.__variants__.Base = PseudoType



#
# type schema::ObjectType
#
class __ObjectType_typeof_base__(
    __Source_typeof_base__,
    __ConsistencySubject_typeof_base__,
    __InheritingObject_typeof_base__,
    __Type_typeof_base__,
    __AnnotationSubject_typeof_base__,
):
    class __gel_reflection__(
        __Source_typeof_base__.__gel_reflection__,
        __ConsistencySubject_typeof_base__.__gel_reflection__,
        __InheritingObject_typeof_base__.__gel_reflection__,
        __Type_typeof_base__.__gel_reflection__,
        __AnnotationSubject_typeof_base__.__gel_reflection__,
    ):
        id = UUID(int=51022788685504552606682066082628014243)
        name = SchemaPath('schema', 'ObjectType')
        @LazyClassProperty["dict[str, GelPointerReflection]"]
        @classmethod
        def pointers(cls) -> dict[str, GelPointerReflection]:
            my_ptrs: dict[str, GelPointerReflection] = {
                'compound_type': GelPointerReflection(
                    name='compound_type',
                    type=SchemaPath('std', 'bool'),
                    typexpr='std::bool',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('One'),
                    computed=True,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
                'is_compound_type': GelPointerReflection(
                    name='is_compound_type',
                    type=SchemaPath('std', 'bool'),
                    typexpr='std::bool',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('One'),
                    computed=True,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
                'union_of': GelPointerReflection(
                    name='union_of',
                    type=SchemaPath('schema', 'ObjectType'),
                    typexpr='schema::ObjectType',
                    kind=PointerKind('Link'),
                    cardinality=pydantic.Cardinality('Many'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
                'intersection_of': GelPointerReflection(
                    name='intersection_of',
                    type=SchemaPath('schema', 'ObjectType'),
                    typexpr='schema::ObjectType',
                    kind=PointerKind('Link'),
                    cardinality=pydantic.Cardinality('Many'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
                'links': GelPointerReflection(
                    name='links',
                    type=SchemaPath('schema', 'Link'),
                    typexpr='schema::Link',
                    kind=PointerKind('Link'),
                    cardinality=pydantic.Cardinality('Many'),
                    computed=True,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
                'properties': GelPointerReflection(
                    name='properties',
                    type=SchemaPath('schema', 'Property'),
                    typexpr='schema::Property',
                    kind=PointerKind('Link'),
                    cardinality=pydantic.Cardinality('Many'),
                    computed=True,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
                'access_policies': GelPointerReflection(
                    name='access_policies',
                    type=SchemaPath('schema', 'AccessPolicy'),
                    typexpr='schema::AccessPolicy',
                    kind=PointerKind('Link'),
                    cardinality=pydantic.Cardinality('Many'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={
                    'owned': GelPointerReflection(
                    name='owned',
                    type=SchemaPath('std', 'bool'),
                    typexpr='std::bool',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties=None,
                ),
                    'is_owned': GelPointerReflection(
                    name='is_owned',
                    type=SchemaPath('std', 'bool'),
                    typexpr='std::bool',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties=None,
                ),
                },
                ),
                'triggers': GelPointerReflection(
                    name='triggers',
                    type=SchemaPath('schema', 'Trigger'),
                    typexpr='schema::Trigger',
                    kind=PointerKind('Link'),
                    cardinality=pydantic.Cardinality('Many'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={
                    'owned': GelPointerReflection(
                    name='owned',
                    type=SchemaPath('std', 'bool'),
                    typexpr='std::bool',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties=None,
                ),
                    'is_owned': GelPointerReflection(
                    name='is_owned',
                    type=SchemaPath('std', 'bool'),
                    typexpr='std::bool',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties=None,
                ),
                },
                ),
            }
            return (
                my_ptrs
                | __Source_typeof_base__.__gel_reflection__.pointers
                | __ConsistencySubject_typeof_base__.__gel_reflection__.pointers
                | __InheritingObject_typeof_base__.__gel_reflection__.pointers
                | __Type_typeof_base__.__gel_reflection__.pointers
                | __AnnotationSubject_typeof_base__.__gel_reflection__.pointers
            )

        @LazyClassProperty["schema.ObjectType"]
        @classmethod
        def object(cls) -> schema.ObjectType:
            from ... import schema as ___schema_1__
            return ___schema_1__.ObjectType(
                id=UUID(int=51022788685504552606682066082628014243),
                name='schema::ObjectType',
                builtin=True,
                internal=False,
                abstract=False,
                final=False,
                compound_type=False,
            )

class __ObjectType_typeof__(
    __Source_typeof__,
    __ConsistencySubject_typeof__,
    __InheritingObject_typeof__,
    __Type_typeof__,
    __AnnotationSubject_typeof__,
    __ObjectType_typeof_base__,
):
    class __typeof__(
        __Source_typeof__.__typeof__,
        __ConsistencySubject_typeof__.__typeof__,
        __InheritingObject_typeof__.__typeof__,
        __Type_typeof__.__typeof__,
        __AnnotationSubject_typeof__.__typeof__,
    ):
        compound_type = TypeAliasType('compound_type', 'ComputedProperty[std.bool, bool]')
        is_compound_type = TypeAliasType('is_compound_type', 'ComputedProperty[std.bool, bool]')
        union_of = TypeAliasType('union_of', 'MultiLink[ObjectType]')
        intersection_of = TypeAliasType('intersection_of', 'MultiLink[ObjectType]')
        links = TypeAliasType('links', 'ComputedMultiLink[Link]')
        properties = TypeAliasType('properties', 'ComputedMultiLink[Property]')
        access_policies = TypeAliasType('access_policies', 'MultiLinkWithProps[ObjectType.__links__.access_policies, AccessPolicy]')
        triggers = TypeAliasType('triggers', 'MultiLinkWithProps[ObjectType.__links__.triggers, Trigger]')


class __ObjectType_typeof_partial__(
    __Source_typeof_partial__,
    __ConsistencySubject_typeof_partial__,
    __InheritingObject_typeof_partial__,
    __Type_typeof_partial__,
    __AnnotationSubject_typeof_partial__,
    __ObjectType_typeof_base__,
):
    class __typeof__(
        __Source_typeof_partial__.__typeof__,
        __ConsistencySubject_typeof_partial__.__typeof__,
        __InheritingObject_typeof_partial__.__typeof__,
        __Type_typeof_partial__.__typeof__,
        __AnnotationSubject_typeof_partial__.__typeof__,
    ):
        compound_type = TypeAliasType('compound_type', 'OptionalComputedProperty[std.bool, bool]')
        is_compound_type = TypeAliasType('is_compound_type', 'OptionalComputedProperty[std.bool, bool]')
        union_of = TypeAliasType('union_of', 'MultiLink[ObjectType | ObjectType.__variants__.Partial]')
        intersection_of = TypeAliasType('intersection_of', 'MultiLink[ObjectType | ObjectType.__variants__.Partial]')
        links = TypeAliasType('links', 'ComputedMultiLink[Link | Link.__variants__.Partial]')
        properties = TypeAliasType('properties', 'ComputedMultiLink[Property | Property.__variants__.Partial]')
        access_policies = TypeAliasType('access_policies', 'MultiLinkWithProps[ObjectType.__links__.access_policies | ObjectType.__links_partial__.access_policies, AccessPolicy]')
        triggers = TypeAliasType('triggers', 'MultiLinkWithProps[ObjectType.__links__.triggers | ObjectType.__links_partial__.triggers, Trigger]')


class ObjectType(
    __ObjectType_typeof__,
    Source,
    ConsistencySubject,
    InheritingObject,
    Type,
    AnnotationSubject,
    __gel_type_id__=UUID(int=51022788685504552606682066082628014243),
):
    if TYPE_CHECKING:
        def __init__(
            self,
            /,
            *,
            id: UUID | DefaultValue = DEFAULT_VALUE,
            name: builtins.str,
            internal: bool | DefaultValue = DEFAULT_VALUE,
            builtin: bool | DefaultValue = DEFAULT_VALUE,
            computed_fields: list[builtins.str] | None = None,
            annotations: Iterable[Annotation] = [],
            abstract: bool | None | DefaultValue = DEFAULT_VALUE,
            final: bool,
            expr: builtins.str | None = None,
            from_alias: bool | None = None,
            inherited_fields: list[builtins.str] | None = None,
            bases: Iterable[InheritingObject] = [],
            ancestors: Iterable[InheritingObject] = [],
            constraints: Iterable[Constraint] = [],
            pointers: Iterable[Pointer] = [],
            indexes: Iterable[Index] = [],
            compound_type: bool,
            union_of: Iterable[ObjectType] = [],
            intersection_of: Iterable[ObjectType] = [],
            links: Iterable[Link] = [],
            properties: Iterable[Property] = [],
            access_policies: Iterable[AccessPolicy] = [],
            triggers: Iterable[Trigger] = [],
        ) -> None:
            """Create a new schema::ObjectType instance from keyword arguments.

            Call db.save() on the returned object to persist it in the database.
            """
            ...

    if not TYPE_CHECKING:
        def __init__(self, /, **kwargs: Any) -> None:
            _id = kwargs.pop("id", None)
            super().__init__(**kwargs)
            object.__setattr__(self, "id", _id)

    if TYPE_CHECKING:
        @classmethod
        def update(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
            abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            from_alias: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            inherited_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            bases: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            ancestors: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            constraints: type[schema.Constraint] | UnspecifiedType = Unspecified,
            pointers: type[schema.Pointer] | UnspecifiedType = Unspecified,
            indexes: type[schema.Index] | UnspecifiedType = Unspecified,
            union_of: type[schema.ObjectType] | UnspecifiedType = Unspecified,
            intersection_of: type[schema.ObjectType] | UnspecifiedType = Unspecified,
            access_policies: type[schema.AccessPolicy] | UnspecifiedType = Unspecified,
            triggers: type[schema.Trigger] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Update schema::ObjectType instances in the database.
            """
            ...

        @classmethod
        def select(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: PathAlias | Literal["*"],
            id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Annotation] | UnspecifiedType = Unspecified,
            abstract: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            final: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            expr: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            from_alias: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            inherited_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            bases: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            ancestors: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            constraints: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Constraint] | UnspecifiedType = Unspecified,
            pointers: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Pointer] | UnspecifiedType = Unspecified,
            indexes: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Index] | UnspecifiedType = Unspecified,
            compound_type: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            union_of: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.ObjectType] | UnspecifiedType = Unspecified,
            intersection_of: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.ObjectType] | UnspecifiedType = Unspecified,
            links: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Link] | UnspecifiedType = Unspecified,
            properties: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Property] | UnspecifiedType = Unspecified,
            access_policies: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.AccessPolicy] | UnspecifiedType = Unspecified,
            triggers: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Trigger] | UnspecifiedType = Unspecified,
            **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
        ) -> type[Self]:
            """Fetch schema::ObjectType instances from the database.
            """
            ...

        @classmethod
        def filter(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], type[___std__.bool]],
            id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
            abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            final: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            from_alias: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            inherited_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            bases: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            ancestors: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            constraints: type[schema.Constraint] | UnspecifiedType = Unspecified,
            pointers: type[schema.Pointer] | UnspecifiedType = Unspecified,
            indexes: type[schema.Index] | UnspecifiedType = Unspecified,
            compound_type: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            union_of: type[schema.ObjectType] | UnspecifiedType = Unspecified,
            intersection_of: type[schema.ObjectType] | UnspecifiedType = Unspecified,
            links: type[schema.Link] | UnspecifiedType = Unspecified,
            properties: type[schema.Property] | UnspecifiedType = Unspecified,
            access_policies: type[schema.AccessPolicy] | UnspecifiedType = Unspecified,
            triggers: type[schema.Trigger] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Fetch schema::ObjectType instances from the database.
            """
            ...

        @classmethod
        def order_by(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
            id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            abstract: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            final: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            expr: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            from_alias: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            compound_type: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Specify the sort order for the selection"""
            ...


    class __variants__(
        Source.__variants__,
        ConsistencySubject.__variants__,
        InheritingObject.__variants__,
        Type.__variants__,
        AnnotationSubject.__variants__,
    ):
        class Base(
            __ObjectType_typeof__,
            Source.__variants__.Base,
            ConsistencySubject.__variants__.Base,
            InheritingObject.__variants__.Base,
            Type.__variants__.Base,
            AnnotationSubject.__variants__.Base,
            __gel_variant__="Base",
        ):
            if TYPE_CHECKING:
                def __init__(
                    self,
                    /,
                    *,
                    id: UUID | DefaultValue = DEFAULT_VALUE,
                    name: builtins.str,
                    internal: bool | DefaultValue = DEFAULT_VALUE,
                    builtin: bool | DefaultValue = DEFAULT_VALUE,
                    computed_fields: list[builtins.str] | None = None,
                    annotations: Iterable[Annotation] = [],
                    abstract: bool | None | DefaultValue = DEFAULT_VALUE,
                    final: bool,
                    expr: builtins.str | None = None,
                    from_alias: bool | None = None,
                    inherited_fields: list[builtins.str] | None = None,
                    bases: Iterable[InheritingObject] = [],
                    ancestors: Iterable[InheritingObject] = [],
                    constraints: Iterable[Constraint] = [],
                    pointers: Iterable[Pointer] = [],
                    indexes: Iterable[Index] = [],
                    compound_type: bool,
                    union_of: Iterable[ObjectType] = [],
                    intersection_of: Iterable[ObjectType] = [],
                    links: Iterable[Link] = [],
                    properties: Iterable[Property] = [],
                    access_policies: Iterable[AccessPolicy] = [],
                    triggers: Iterable[Trigger] = [],
                ) -> None:
                    """Create a new schema::ObjectType instance from keyword arguments.

                    Call db.save() on the returned object to persist it in the database.
                    """
                    ...

            if not TYPE_CHECKING:
                def __init__(self, /, **kwargs: Any) -> None:
                    _id = kwargs.pop("id", None)
                    super().__init__(**kwargs)
                    object.__setattr__(self, "id", _id)

            if TYPE_CHECKING:
                @classmethod
                def update(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
                    abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    from_alias: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    inherited_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    bases: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    ancestors: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    constraints: type[schema.Constraint] | UnspecifiedType = Unspecified,
                    pointers: type[schema.Pointer] | UnspecifiedType = Unspecified,
                    indexes: type[schema.Index] | UnspecifiedType = Unspecified,
                    union_of: type[schema.ObjectType] | UnspecifiedType = Unspecified,
                    intersection_of: type[schema.ObjectType] | UnspecifiedType = Unspecified,
                    access_policies: type[schema.AccessPolicy] | UnspecifiedType = Unspecified,
                    triggers: type[schema.Trigger] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Update schema::ObjectType instances in the database.
                    """
                    ...

                @classmethod
                def select(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: PathAlias | Literal["*"],
                    id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Annotation] | UnspecifiedType = Unspecified,
                    abstract: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    final: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    expr: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    from_alias: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    inherited_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    bases: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    ancestors: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    constraints: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Constraint] | UnspecifiedType = Unspecified,
                    pointers: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Pointer] | UnspecifiedType = Unspecified,
                    indexes: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Index] | UnspecifiedType = Unspecified,
                    compound_type: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    union_of: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.ObjectType] | UnspecifiedType = Unspecified,
                    intersection_of: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.ObjectType] | UnspecifiedType = Unspecified,
                    links: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Link] | UnspecifiedType = Unspecified,
                    properties: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Property] | UnspecifiedType = Unspecified,
                    access_policies: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.AccessPolicy] | UnspecifiedType = Unspecified,
                    triggers: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Trigger] | UnspecifiedType = Unspecified,
                    **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
                ) -> type[Self]:
                    """Fetch schema::ObjectType instances from the database.
                    """
                    ...

                @classmethod
                def filter(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], type[___std__.bool]],
                    id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
                    abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    final: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    from_alias: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    inherited_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    bases: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    ancestors: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    constraints: type[schema.Constraint] | UnspecifiedType = Unspecified,
                    pointers: type[schema.Pointer] | UnspecifiedType = Unspecified,
                    indexes: type[schema.Index] | UnspecifiedType = Unspecified,
                    compound_type: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    union_of: type[schema.ObjectType] | UnspecifiedType = Unspecified,
                    intersection_of: type[schema.ObjectType] | UnspecifiedType = Unspecified,
                    links: type[schema.Link] | UnspecifiedType = Unspecified,
                    properties: type[schema.Property] | UnspecifiedType = Unspecified,
                    access_policies: type[schema.AccessPolicy] | UnspecifiedType = Unspecified,
                    triggers: type[schema.Trigger] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Fetch schema::ObjectType instances from the database.
                    """
                    ...

                @classmethod
                def order_by(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
                    id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    abstract: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    final: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    expr: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    from_alias: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    compound_type: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Specify the sort order for the selection"""
                    ...

        class Required(
            Base,
            Source.__variants__.Required,
            ConsistencySubject.__variants__.Required,
            InheritingObject.__variants__.Required,
            Type.__variants__.Required,
            AnnotationSubject.__variants__.Required,
            __gel_variant__="Required",
        ):
            compound_type: ComputedProperty[std.bool, bool]

        class PartialBase(  # type: ignore [misc, unused-ignore]
            __ObjectType_typeof_partial__,
            Base,
            Source.__variants__.PartialBase,
            ConsistencySubject.__variants__.PartialBase,
            InheritingObject.__variants__.PartialBase,
            Type.__variants__.PartialBase,
            AnnotationSubject.__variants__.PartialBase,
            __gel_variant__="PartialBase",
        ):
            pass

        class Partial(  # type: ignore [misc, unused-ignore]
            PartialBase,
            Source.__variants__.Partial,
            ConsistencySubject.__variants__.Partial,
            InheritingObject.__variants__.Partial,
            Type.__variants__.Partial,
            AnnotationSubject.__variants__.Partial,
            __gel_variant__="Partial",
        ):
            compound_type: OptionalComputedProperty[std.bool, bool]
            union_of: MultiLink[___schema__.ObjectType | ___schema__.ObjectType.__variants__.Partial]
            intersection_of: MultiLink[___schema__.ObjectType | ___schema__.ObjectType.__variants__.Partial]
            links: ComputedMultiLink[___schema__.Link | ___schema__.Link.__variants__.Partial]
            properties: ComputedMultiLink[___schema__.Property | ___schema__.Property.__variants__.Partial]
            access_policies: MultiLinkWithProps[ObjectType.__links__.access_policies | ObjectType.__links_partial__.access_policies, ___schema__.AccessPolicy]
            triggers: MultiLinkWithProps[ObjectType.__links__.triggers | ObjectType.__links_partial__.triggers, ___schema__.Trigger]


        Any = TypeVar("Any", bound="ObjectType | Base | Required | Partial")
    class __links__(
        Source.__links__,
        ConsistencySubject.__links__,
        InheritingObject.__links__,
        Type.__links__,
        AnnotationSubject.__links__,
    ):
        if TYPE_CHECKING:
            class access_policies(
                schema.AccessPolicy,
                ProxyModel[schema.AccessPolicy],
            ):
                """link schema::ObjectType.access_policies: schema::AccessPolicy"""
                class __lprops__(GelLinkModel):
                    class __gel_reflection__(GelLinkModel.__gel_reflection__):
                        id = UUID(int=241710065453170928780740306043696468799)
                        name = SchemaPath('access_policies')
                        @LazyClassProperty["dict[str, GelPointerReflection]"]
                        @classmethod
                        def pointers(cls) -> dict[str, GelPointerReflection]:
                            my_ptrs: dict[str, GelPointerReflection] = {
                                'owned': GelPointerReflection(
                                    name='owned',
                                    type=SchemaPath('std', 'bool'),
                                    typexpr='std::bool',
                                    kind=PointerKind('Property'),
                                    cardinality=pydantic.Cardinality('AtMostOne'),
                                    computed=False,
                                    readonly=False,
                                    has_default=False,
                                    properties=None,
                                ),
                                'is_owned': GelPointerReflection(
                                    name='is_owned',
                                    type=SchemaPath('std', 'bool'),
                                    typexpr='std::bool',
                                    kind=PointerKind('Property'),
                                    cardinality=pydantic.Cardinality('AtMostOne'),
                                    computed=False,
                                    readonly=False,
                                    has_default=False,
                                    properties=None,
                                ),
                            }
                            return my_ptrs


                    owned: OptionalProperty[___std__.bool, ___builtins_2__.bool]
                    is_owned: OptionalProperty[___std__.bool, ___builtins_2__.bool]
                __linkprops__: __lprops__

                def __init__(
                    self,
                    obj: schema.AccessPolicy,
                    /,
                    *,
                    owned: ___builtins_2__.bool | None = None,
                    is_owned: ___builtins_2__.bool | None = None,
                ) -> None:
                    ...

                @classmethod
                def link(
                    cls,
                    obj: schema.AccessPolicy,
                    /,
                    *,
                    owned: ___builtins_2__.bool | None = None,
                    is_owned: ___builtins_2__.bool | None = None,
                ) -> Self:
                    ...

            class triggers(schema.Trigger, ProxyModel[schema.Trigger]):
                """link schema::ObjectType.triggers: schema::Trigger"""
                class __lprops__(GelLinkModel):
                    class __gel_reflection__(GelLinkModel.__gel_reflection__):
                        id = UUID(int=143803314563040240975383601462681200688)
                        name = SchemaPath('triggers')
                        @LazyClassProperty["dict[str, GelPointerReflection]"]
                        @classmethod
                        def pointers(cls) -> dict[str, GelPointerReflection]:
                            my_ptrs: dict[str, GelPointerReflection] = {
                                'owned': GelPointerReflection(
                                    name='owned',
                                    type=SchemaPath('std', 'bool'),
                                    typexpr='std::bool',
                                    kind=PointerKind('Property'),
                                    cardinality=pydantic.Cardinality('AtMostOne'),
                                    computed=False,
                                    readonly=False,
                                    has_default=False,
                                    properties=None,
                                ),
                                'is_owned': GelPointerReflection(
                                    name='is_owned',
                                    type=SchemaPath('std', 'bool'),
                                    typexpr='std::bool',
                                    kind=PointerKind('Property'),
                                    cardinality=pydantic.Cardinality('AtMostOne'),
                                    computed=False,
                                    readonly=False,
                                    has_default=False,
                                    properties=None,
                                ),
                            }
                            return my_ptrs


                    owned: OptionalProperty[___std__.bool, ___builtins_2__.bool]
                    is_owned: OptionalProperty[___std__.bool, ___builtins_2__.bool]
                __linkprops__: __lprops__

                def __init__(
                    self,
                    obj: schema.Trigger,
                    /,
                    *,
                    owned: ___builtins_2__.bool | None = None,
                    is_owned: ___builtins_2__.bool | None = None,
                ) -> None:
                    ...

                @classmethod
                def link(
                    cls,
                    obj: schema.Trigger,
                    /,
                    *,
                    owned: ___builtins_2__.bool | None = None,
                    is_owned: ___builtins_2__.bool | None = None,
                ) -> Self:
                    ...

        if not TYPE_CHECKING:
            @LazyClassProperty[type]
            @classmethod
            def access_policies(cls) -> type:
                class ObjectType__access_policies(
                    ___schema__.AccessPolicy,
                    ProxyModel[___schema__.AccessPolicy],
                ):
                    """link schema::ObjectType.access_policies: schema::AccessPolicy"""
                    class __lprops__(GelLinkModel):
                        class __gel_reflection__(
                            GelLinkModel.__gel_reflection__,
                        ):
                            id = UUID(int=241710065453170928780740306043696468799)
                            name = SchemaPath('access_policies')
                            @LazyClassProperty["dict[str, GelPointerReflection]"]
                            @classmethod
                            def pointers(
                                cls,
                            ) -> dict[str, GelPointerReflection]:
                                my_ptrs: dict[str, GelPointerReflection] = {
                                    'owned': GelPointerReflection(
                                        name='owned',
                                        type=SchemaPath('std', 'bool'),
                                        typexpr='std::bool',
                                        kind=PointerKind('Property'),
                                        cardinality=pydantic.Cardinality('AtMostOne'),
                                        computed=False,
                                        readonly=False,
                                        has_default=False,
                                        properties=None,
                                    ),
                                    'is_owned': GelPointerReflection(
                                        name='is_owned',
                                        type=SchemaPath('std', 'bool'),
                                        typexpr='std::bool',
                                        kind=PointerKind('Property'),
                                        cardinality=pydantic.Cardinality('AtMostOne'),
                                        computed=False,
                                        readonly=False,
                                        has_default=False,
                                        properties=None,
                                    ),
                                }
                                return my_ptrs


                        owned: OptionalProperty[std.bool, ___builtins_2__.bool]
                        is_owned: OptionalProperty[std.bool, ___builtins_2__.bool]
                    __linkprops__: __lprops__

                    def __init__(self, obj, /, **link_props) -> None:
                        ProxyModel.__init__(self, obj)
                        lprops = self.__class__.__lprops__(**link_props)
                        object.__setattr__(self, "__linkprops__", lprops)

                    @classmethod
                    def link(cls, obj, /, **link_props) -> Self:
                        return cls(obj, **link_props)

                ObjectType__access_policies.__name__ = 'access_policies'
                ObjectType__access_policies.__qualname__ = 'ObjectType.access_policies'
                return ObjectType__access_policies
            @LazyClassProperty[type]
            @classmethod
            def triggers(cls) -> type:
                class ObjectType__triggers(
                    ___schema__.Trigger,
                    ProxyModel[___schema__.Trigger],
                ):
                    """link schema::ObjectType.triggers: schema::Trigger"""
                    class __lprops__(GelLinkModel):
                        class __gel_reflection__(
                            GelLinkModel.__gel_reflection__,
                        ):
                            id = UUID(int=143803314563040240975383601462681200688)
                            name = SchemaPath('triggers')
                            @LazyClassProperty["dict[str, GelPointerReflection]"]
                            @classmethod
                            def pointers(
                                cls,
                            ) -> dict[str, GelPointerReflection]:
                                my_ptrs: dict[str, GelPointerReflection] = {
                                    'owned': GelPointerReflection(
                                        name='owned',
                                        type=SchemaPath('std', 'bool'),
                                        typexpr='std::bool',
                                        kind=PointerKind('Property'),
                                        cardinality=pydantic.Cardinality('AtMostOne'),
                                        computed=False,
                                        readonly=False,
                                        has_default=False,
                                        properties=None,
                                    ),
                                    'is_owned': GelPointerReflection(
                                        name='is_owned',
                                        type=SchemaPath('std', 'bool'),
                                        typexpr='std::bool',
                                        kind=PointerKind('Property'),
                                        cardinality=pydantic.Cardinality('AtMostOne'),
                                        computed=False,
                                        readonly=False,
                                        has_default=False,
                                        properties=None,
                                    ),
                                }
                                return my_ptrs


                        owned: OptionalProperty[std.bool, ___builtins_2__.bool]
                        is_owned: OptionalProperty[std.bool, ___builtins_2__.bool]
                    __linkprops__: __lprops__

                    def __init__(self, obj, /, **link_props) -> None:
                        ProxyModel.__init__(self, obj)
                        lprops = self.__class__.__lprops__(**link_props)
                        object.__setattr__(self, "__linkprops__", lprops)

                    @classmethod
                    def link(cls, obj, /, **link_props) -> Self:
                        return cls(obj, **link_props)

                ObjectType__triggers.__name__ = 'triggers'
                ObjectType__triggers.__qualname__ = 'ObjectType.triggers'
                return ObjectType__triggers
    class __links_partial__(
        Source.__links_partial__,
        ConsistencySubject.__links_partial__,
        InheritingObject.__links_partial__,
        Type.__links_partial__,
        AnnotationSubject.__links_partial__,
    ):
        if TYPE_CHECKING:
            class access_policies(  # type: ignore [misc]
                schema.AccessPolicy.__variants__.Partial,
                ProxyModel[schema.AccessPolicy.__variants__.Partial],
            ):
                """link schema::ObjectType.access_policies: schema::AccessPolicy"""
                class __lprops__(GelLinkModel):
                    class __gel_reflection__(GelLinkModel.__gel_reflection__):
                        id = UUID(int=241710065453170928780740306043696468799)
                        name = SchemaPath('access_policies')
                        @LazyClassProperty["dict[str, GelPointerReflection]"]
                        @classmethod
                        def pointers(cls) -> dict[str, GelPointerReflection]:
                            my_ptrs: dict[str, GelPointerReflection] = {
                                'owned': GelPointerReflection(
                                    name='owned',
                                    type=SchemaPath('std', 'bool'),
                                    typexpr='std::bool',
                                    kind=PointerKind('Property'),
                                    cardinality=pydantic.Cardinality('AtMostOne'),
                                    computed=False,
                                    readonly=False,
                                    has_default=False,
                                    properties=None,
                                ),
                                'is_owned': GelPointerReflection(
                                    name='is_owned',
                                    type=SchemaPath('std', 'bool'),
                                    typexpr='std::bool',
                                    kind=PointerKind('Property'),
                                    cardinality=pydantic.Cardinality('AtMostOne'),
                                    computed=False,
                                    readonly=False,
                                    has_default=False,
                                    properties=None,
                                ),
                            }
                            return my_ptrs


                    owned: OptionalProperty[___std__.bool, ___builtins_2__.bool]
                    is_owned: OptionalProperty[___std__.bool, ___builtins_2__.bool]
                __linkprops__: __lprops__

                def __init__(
                    self,
                    obj: schema.AccessPolicy.__variants__.Partial,
                    /,
                    *,
                    owned: ___builtins_2__.bool | None = None,
                    is_owned: ___builtins_2__.bool | None = None,
                ) -> None:
                    ...

                @classmethod
                def link(
                    cls,
                    obj: schema.AccessPolicy.__variants__.Partial,
                    /,
                    *,
                    owned: ___builtins_2__.bool | None = None,
                    is_owned: ___builtins_2__.bool | None = None,
                ) -> Self:
                    ...

            class triggers(  # type: ignore [misc]
                schema.Trigger.__variants__.Partial,
                ProxyModel[schema.Trigger.__variants__.Partial],
            ):
                """link schema::ObjectType.triggers: schema::Trigger"""
                class __lprops__(GelLinkModel):
                    class __gel_reflection__(GelLinkModel.__gel_reflection__):
                        id = UUID(int=143803314563040240975383601462681200688)
                        name = SchemaPath('triggers')
                        @LazyClassProperty["dict[str, GelPointerReflection]"]
                        @classmethod
                        def pointers(cls) -> dict[str, GelPointerReflection]:
                            my_ptrs: dict[str, GelPointerReflection] = {
                                'owned': GelPointerReflection(
                                    name='owned',
                                    type=SchemaPath('std', 'bool'),
                                    typexpr='std::bool',
                                    kind=PointerKind('Property'),
                                    cardinality=pydantic.Cardinality('AtMostOne'),
                                    computed=False,
                                    readonly=False,
                                    has_default=False,
                                    properties=None,
                                ),
                                'is_owned': GelPointerReflection(
                                    name='is_owned',
                                    type=SchemaPath('std', 'bool'),
                                    typexpr='std::bool',
                                    kind=PointerKind('Property'),
                                    cardinality=pydantic.Cardinality('AtMostOne'),
                                    computed=False,
                                    readonly=False,
                                    has_default=False,
                                    properties=None,
                                ),
                            }
                            return my_ptrs


                    owned: OptionalProperty[___std__.bool, ___builtins_2__.bool]
                    is_owned: OptionalProperty[___std__.bool, ___builtins_2__.bool]
                __linkprops__: __lprops__

                def __init__(
                    self,
                    obj: schema.Trigger.__variants__.Partial,
                    /,
                    *,
                    owned: ___builtins_2__.bool | None = None,
                    is_owned: ___builtins_2__.bool | None = None,
                ) -> None:
                    ...

                @classmethod
                def link(
                    cls,
                    obj: schema.Trigger.__variants__.Partial,
                    /,
                    *,
                    owned: ___builtins_2__.bool | None = None,
                    is_owned: ___builtins_2__.bool | None = None,
                ) -> Self:
                    ...

        if not TYPE_CHECKING:
            @LazyClassProperty[type]
            @classmethod
            def access_policies(cls) -> type:
                class ObjectType__access_policies(  # type: ignore [misc]
                    ___schema__.AccessPolicy.__variants__.Partial,
                    ProxyModel[___schema__.AccessPolicy.__variants__.Partial],
                ):
                    """link schema::ObjectType.access_policies: schema::AccessPolicy"""
                    class __lprops__(GelLinkModel):
                        class __gel_reflection__(
                            GelLinkModel.__gel_reflection__,
                        ):
                            id = UUID(int=241710065453170928780740306043696468799)
                            name = SchemaPath('access_policies')
                            @LazyClassProperty["dict[str, GelPointerReflection]"]
                            @classmethod
                            def pointers(
                                cls,
                            ) -> dict[str, GelPointerReflection]:
                                my_ptrs: dict[str, GelPointerReflection] = {
                                    'owned': GelPointerReflection(
                                        name='owned',
                                        type=SchemaPath('std', 'bool'),
                                        typexpr='std::bool',
                                        kind=PointerKind('Property'),
                                        cardinality=pydantic.Cardinality('AtMostOne'),
                                        computed=False,
                                        readonly=False,
                                        has_default=False,
                                        properties=None,
                                    ),
                                    'is_owned': GelPointerReflection(
                                        name='is_owned',
                                        type=SchemaPath('std', 'bool'),
                                        typexpr='std::bool',
                                        kind=PointerKind('Property'),
                                        cardinality=pydantic.Cardinality('AtMostOne'),
                                        computed=False,
                                        readonly=False,
                                        has_default=False,
                                        properties=None,
                                    ),
                                }
                                return my_ptrs


                        owned: OptionalProperty[std.bool, ___builtins_2__.bool]
                        is_owned: OptionalProperty[std.bool, ___builtins_2__.bool]
                    __linkprops__: __lprops__

                    def __init__(self, obj, /, **link_props) -> None:
                        ProxyModel.__init__(self, obj)
                        lprops = self.__class__.__lprops__(**link_props)
                        object.__setattr__(self, "__linkprops__", lprops)

                    @classmethod
                    def link(cls, obj, /, **link_props) -> Self:
                        return cls(obj, **link_props)

                ObjectType__access_policies.__name__ = 'access_policies'
                ObjectType__access_policies.__qualname__ = 'ObjectType.access_policies'
                return ObjectType__access_policies
            @LazyClassProperty[type]
            @classmethod
            def triggers(cls) -> type:
                class ObjectType__triggers(  # type: ignore [misc]
                    ___schema__.Trigger.__variants__.Partial,
                    ProxyModel[___schema__.Trigger.__variants__.Partial],
                ):
                    """link schema::ObjectType.triggers: schema::Trigger"""
                    class __lprops__(GelLinkModel):
                        class __gel_reflection__(
                            GelLinkModel.__gel_reflection__,
                        ):
                            id = UUID(int=143803314563040240975383601462681200688)
                            name = SchemaPath('triggers')
                            @LazyClassProperty["dict[str, GelPointerReflection]"]
                            @classmethod
                            def pointers(
                                cls,
                            ) -> dict[str, GelPointerReflection]:
                                my_ptrs: dict[str, GelPointerReflection] = {
                                    'owned': GelPointerReflection(
                                        name='owned',
                                        type=SchemaPath('std', 'bool'),
                                        typexpr='std::bool',
                                        kind=PointerKind('Property'),
                                        cardinality=pydantic.Cardinality('AtMostOne'),
                                        computed=False,
                                        readonly=False,
                                        has_default=False,
                                        properties=None,
                                    ),
                                    'is_owned': GelPointerReflection(
                                        name='is_owned',
                                        type=SchemaPath('std', 'bool'),
                                        typexpr='std::bool',
                                        kind=PointerKind('Property'),
                                        cardinality=pydantic.Cardinality('AtMostOne'),
                                        computed=False,
                                        readonly=False,
                                        has_default=False,
                                        properties=None,
                                    ),
                                }
                                return my_ptrs


                        owned: OptionalProperty[std.bool, ___builtins_2__.bool]
                        is_owned: OptionalProperty[std.bool, ___builtins_2__.bool]
                    __linkprops__: __lprops__

                    def __init__(self, obj, /, **link_props) -> None:
                        ProxyModel.__init__(self, obj)
                        lprops = self.__class__.__lprops__(**link_props)
                        object.__setattr__(self, "__linkprops__", lprops)

                    @classmethod
                    def link(cls, obj, /, **link_props) -> Self:
                        return cls(obj, **link_props)

                ObjectType__triggers.__name__ = 'triggers'
                ObjectType__triggers.__qualname__ = 'ObjectType.triggers'
                return ObjectType__triggers

if not TYPE_CHECKING:
    ObjectType.__variants__.Base = ObjectType



#
# type schema::Pointer
#
class __Pointer_typeof_base__(
    __ConsistencySubject_typeof_base__,
    __AnnotationSubject_typeof_base__,
):
    class __gel_reflection__(
        __ConsistencySubject_typeof_base__.__gel_reflection__,
        __AnnotationSubject_typeof_base__.__gel_reflection__,
    ):
        id = UUID(int=116815132430841301909180054634293237411)
        name = SchemaPath('schema', 'Pointer')
        @LazyClassProperty["dict[str, GelPointerReflection]"]
        @classmethod
        def pointers(cls) -> dict[str, GelPointerReflection]:
            my_ptrs: dict[str, GelPointerReflection] = {
                'cardinality': GelPointerReflection(
                    name='cardinality',
                    type=SchemaPath('schema', 'Cardinality'),
                    typexpr='schema::Cardinality',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
                'required': GelPointerReflection(
                    name='required',
                    type=SchemaPath('std', 'bool'),
                    typexpr='std::bool',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
                'readonly': GelPointerReflection(
                    name='readonly',
                    type=SchemaPath('std', 'bool'),
                    typexpr='std::bool',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
                'default': GelPointerReflection(
                    name='default',
                    type=SchemaPath('std', 'str'),
                    typexpr='std::str',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
                'expr': GelPointerReflection(
                    name='expr',
                    type=SchemaPath('std', 'str'),
                    typexpr='std::str',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
                'secret': GelPointerReflection(
                    name='secret',
                    type=SchemaPath('std', 'bool'),
                    typexpr='std::bool',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
                'source': GelPointerReflection(
                    name='source',
                    type=SchemaPath('schema', 'Source'),
                    typexpr='schema::Source',
                    kind=PointerKind('Link'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
                'target': GelPointerReflection(
                    name='target',
                    type=SchemaPath('schema', 'Type'),
                    typexpr='schema::Type',
                    kind=PointerKind('Link'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
                'rewrites': GelPointerReflection(
                    name='rewrites',
                    type=SchemaPath('schema', 'Rewrite'),
                    typexpr='schema::Rewrite',
                    kind=PointerKind('Link'),
                    cardinality=pydantic.Cardinality('Many'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={
                    'owned': GelPointerReflection(
                    name='owned',
                    type=SchemaPath('std', 'bool'),
                    typexpr='std::bool',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties=None,
                ),
                    'is_owned': GelPointerReflection(
                    name='is_owned',
                    type=SchemaPath('std', 'bool'),
                    typexpr='std::bool',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties=None,
                ),
                },
                ),
            }
            return (
                my_ptrs
                | __ConsistencySubject_typeof_base__.__gel_reflection__.pointers
                | __AnnotationSubject_typeof_base__.__gel_reflection__.pointers
            )

        @LazyClassProperty["schema.ObjectType"]
        @classmethod
        def object(cls) -> schema.ObjectType:
            from ... import schema as ___schema_1__
            return ___schema_1__.ObjectType(
                id=UUID(int=116815132430841301909180054634293237411),
                name='schema::Pointer',
                builtin=True,
                internal=False,
                abstract=True,
                final=False,
                compound_type=False,
            )

class __Pointer_typeof__(
    __ConsistencySubject_typeof__,
    __AnnotationSubject_typeof__,
    __Pointer_typeof_base__,
):
    class __typeof__(
        __ConsistencySubject_typeof__.__typeof__,
        __AnnotationSubject_typeof__.__typeof__,
    ):
        cardinality = TypeAliasType('cardinality', 'OptionalProperty[Cardinality, ___builtins_1__.str]')
        required = TypeAliasType('required', 'OptionalProperty[std.bool, bool]')
        readonly = TypeAliasType('readonly', 'OptionalProperty[std.bool, bool]')
        default = TypeAliasType('default', 'OptionalProperty[std.str, builtins.str]')
        expr = TypeAliasType('expr', 'OptionalProperty[std.str, builtins.str]')
        secret = TypeAliasType('secret', 'OptionalProperty[std.bool, bool]')
        source = TypeAliasType('source', 'OptionalLink[Source]')
        target = TypeAliasType('target', 'OptionalLink[Type]')
        rewrites = TypeAliasType('rewrites', 'MultiLinkWithProps[Pointer.__links__.rewrites, Rewrite]')


class __Pointer_typeof_partial__(
    __ConsistencySubject_typeof_partial__,
    __AnnotationSubject_typeof_partial__,
    __Pointer_typeof_base__,
):
    class __typeof__(
        __ConsistencySubject_typeof_partial__.__typeof__,
        __AnnotationSubject_typeof_partial__.__typeof__,
    ):
        cardinality = TypeAliasType('cardinality', 'OptionalProperty[Cardinality, ___builtins_1__.str]')
        required = TypeAliasType('required', 'OptionalProperty[std.bool, bool]')
        readonly = TypeAliasType('readonly', 'OptionalProperty[std.bool, bool]')
        default = TypeAliasType('default', 'OptionalProperty[std.str, builtins.str]')
        expr = TypeAliasType('expr', 'OptionalProperty[std.str, builtins.str]')
        secret = TypeAliasType('secret', 'OptionalProperty[std.bool, bool]')
        source = TypeAliasType('source', 'OptionalLink[Source | Source.__variants__.Partial]')
        target = TypeAliasType('target', 'OptionalLink[Type | Type.__variants__.Partial]')
        rewrites = TypeAliasType('rewrites', 'MultiLinkWithProps[Pointer.__links__.rewrites | Pointer.__links_partial__.rewrites, Rewrite]')


class Pointer(
    __Pointer_typeof__,
    ConsistencySubject,
    AnnotationSubject,
    __gel_type_id__=UUID(int=116815132430841301909180054634293237411),
):
    if TYPE_CHECKING:
        def __init__(
            self,
            /,
            *,
            id: UUID | DefaultValue = DEFAULT_VALUE,
            name: builtins.str,
            internal: bool | DefaultValue = DEFAULT_VALUE,
            builtin: bool | DefaultValue = DEFAULT_VALUE,
            computed_fields: list[builtins.str] | None = None,
            annotations: Iterable[Annotation] = [],
            abstract: bool | None | DefaultValue = DEFAULT_VALUE,
            final: bool,
            inherited_fields: list[builtins.str] | None = None,
            bases: Iterable[InheritingObject] = [],
            ancestors: Iterable[InheritingObject] = [],
            constraints: Iterable[Constraint] = [],
            cardinality: ___builtins_1__.str | None = None,
            required: bool | None = None,
            readonly: bool | None = None,
            default: builtins.str | None = None,
            expr: builtins.str | None = None,
            secret: bool | None = None,
            source: Source | None = None,
            target: Type | None = None,
            rewrites: Iterable[Rewrite] = [],
        ) -> None:
            """Create a new schema::Pointer instance from keyword arguments.

            Call db.save() on the returned object to persist it in the database.
            """
            ...

    if TYPE_CHECKING:
        @classmethod
        def update(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
            abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            inherited_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            bases: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            ancestors: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            constraints: type[schema.Constraint] | UnspecifiedType = Unspecified,
            cardinality: type[Cardinality] | UnspecifiedType = Unspecified,
            required: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            readonly: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            default: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            secret: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            source: type[schema.Source] | UnspecifiedType = Unspecified,
            target: type[schema.Type] | UnspecifiedType = Unspecified,
            rewrites: type[schema.Rewrite] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Update schema::Pointer instances in the database.
            """
            ...

        @classmethod
        def select(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: PathAlias | Literal["*"],
            id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Annotation] | UnspecifiedType = Unspecified,
            abstract: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            final: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            inherited_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            bases: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            ancestors: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            constraints: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Constraint] | UnspecifiedType = Unspecified,
            cardinality: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[Cardinality] | UnspecifiedType = Unspecified,
            required: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            readonly: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            default: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            expr: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            secret: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            source: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Source] | UnspecifiedType = Unspecified,
            target: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Type] | UnspecifiedType = Unspecified,
            rewrites: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Rewrite] | UnspecifiedType = Unspecified,
            **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
        ) -> type[Self]:
            """Fetch schema::Pointer instances from the database.
            """
            ...

        @classmethod
        def filter(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], type[___std__.bool]],
            id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
            abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            final: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            inherited_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            bases: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            ancestors: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            constraints: type[schema.Constraint] | UnspecifiedType = Unspecified,
            cardinality: type[Cardinality] | UnspecifiedType = Unspecified,
            required: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            readonly: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            default: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            secret: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            source: type[schema.Source] | UnspecifiedType = Unspecified,
            target: type[schema.Type] | UnspecifiedType = Unspecified,
            rewrites: type[schema.Rewrite] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Fetch schema::Pointer instances from the database.
            """
            ...

        @classmethod
        def order_by(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
            id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            abstract: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            final: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            required: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            readonly: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            default: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            expr: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            secret: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Specify the sort order for the selection"""
            ...


    class __variants__(
        ConsistencySubject.__variants__,
        AnnotationSubject.__variants__,
    ):
        class Base(
            __Pointer_typeof__,
            ConsistencySubject.__variants__.Base,
            AnnotationSubject.__variants__.Base,
            __gel_variant__="Base",
        ):
            if TYPE_CHECKING:
                def __init__(
                    self,
                    /,
                    *,
                    id: UUID | DefaultValue = DEFAULT_VALUE,
                    name: builtins.str,
                    internal: bool | DefaultValue = DEFAULT_VALUE,
                    builtin: bool | DefaultValue = DEFAULT_VALUE,
                    computed_fields: list[builtins.str] | None = None,
                    annotations: Iterable[Annotation] = [],
                    abstract: bool | None | DefaultValue = DEFAULT_VALUE,
                    final: bool,
                    inherited_fields: list[builtins.str] | None = None,
                    bases: Iterable[InheritingObject] = [],
                    ancestors: Iterable[InheritingObject] = [],
                    constraints: Iterable[Constraint] = [],
                    cardinality: ___builtins_1__.str | None = None,
                    required: bool | None = None,
                    readonly: bool | None = None,
                    default: builtins.str | None = None,
                    expr: builtins.str | None = None,
                    secret: bool | None = None,
                    source: Source | None = None,
                    target: Type | None = None,
                    rewrites: Iterable[Rewrite] = [],
                ) -> None:
                    """Create a new schema::Pointer instance from keyword arguments.

                    Call db.save() on the returned object to persist it in the database.
                    """
                    ...

            if TYPE_CHECKING:
                @classmethod
                def update(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
                    abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    inherited_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    bases: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    ancestors: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    constraints: type[schema.Constraint] | UnspecifiedType = Unspecified,
                    cardinality: type[Cardinality] | UnspecifiedType = Unspecified,
                    required: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    readonly: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    default: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    secret: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    source: type[schema.Source] | UnspecifiedType = Unspecified,
                    target: type[schema.Type] | UnspecifiedType = Unspecified,
                    rewrites: type[schema.Rewrite] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Update schema::Pointer instances in the database.
                    """
                    ...

                @classmethod
                def select(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: PathAlias | Literal["*"],
                    id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Annotation] | UnspecifiedType = Unspecified,
                    abstract: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    final: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    inherited_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    bases: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    ancestors: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    constraints: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Constraint] | UnspecifiedType = Unspecified,
                    cardinality: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[Cardinality] | UnspecifiedType = Unspecified,
                    required: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    readonly: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    default: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    expr: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    secret: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    source: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Source] | UnspecifiedType = Unspecified,
                    target: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Type] | UnspecifiedType = Unspecified,
                    rewrites: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Rewrite] | UnspecifiedType = Unspecified,
                    **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
                ) -> type[Self]:
                    """Fetch schema::Pointer instances from the database.
                    """
                    ...

                @classmethod
                def filter(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], type[___std__.bool]],
                    id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
                    abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    final: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    inherited_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    bases: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    ancestors: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    constraints: type[schema.Constraint] | UnspecifiedType = Unspecified,
                    cardinality: type[Cardinality] | UnspecifiedType = Unspecified,
                    required: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    readonly: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    default: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    secret: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    source: type[schema.Source] | UnspecifiedType = Unspecified,
                    target: type[schema.Type] | UnspecifiedType = Unspecified,
                    rewrites: type[schema.Rewrite] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Fetch schema::Pointer instances from the database.
                    """
                    ...

                @classmethod
                def order_by(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
                    id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    abstract: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    final: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    required: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    readonly: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    default: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    expr: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    secret: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Specify the sort order for the selection"""
                    ...

        class Required(
            Base,
            ConsistencySubject.__variants__.Required,
            AnnotationSubject.__variants__.Required,
            __gel_variant__="Required",
        ):
            pass

        class PartialBase(  # type: ignore [misc, unused-ignore]
            __Pointer_typeof_partial__,
            Base,
            ConsistencySubject.__variants__.PartialBase,
            AnnotationSubject.__variants__.PartialBase,
            __gel_variant__="PartialBase",
        ):
            pass

        class Partial(  # type: ignore [misc, unused-ignore]
            PartialBase,
            ConsistencySubject.__variants__.Partial,
            AnnotationSubject.__variants__.Partial,
            __gel_variant__="Partial",
        ):
            cardinality: OptionalProperty[Cardinality, ___builtins_1__.str]
            required: OptionalProperty[std.bool, bool]
            readonly: OptionalProperty[std.bool, bool]
            default: OptionalProperty[std.str, builtins.str]
            expr: OptionalProperty[std.str, builtins.str]
            secret: OptionalProperty[std.bool, bool]
            source: OptionalLink[___schema__.Source | ___schema__.Source.__variants__.Partial]
            target: OptionalLink[___schema__.Type | ___schema__.Type.__variants__.Partial]
            rewrites: MultiLinkWithProps[Pointer.__links__.rewrites | Pointer.__links_partial__.rewrites, ___schema__.Rewrite]


        Any = TypeVar("Any", bound="Pointer | Base | Required | Partial")
    class __links__(ConsistencySubject.__links__, AnnotationSubject.__links__):
        if TYPE_CHECKING:
            class rewrites(schema.Rewrite, ProxyModel[schema.Rewrite]):
                """link schema::Pointer.rewrites: schema::Rewrite"""
                class __lprops__(GelLinkModel):
                    class __gel_reflection__(GelLinkModel.__gel_reflection__):
                        id = UUID(int=218586751138303810113144406297311418768)
                        name = SchemaPath('rewrites')
                        @LazyClassProperty["dict[str, GelPointerReflection]"]
                        @classmethod
                        def pointers(cls) -> dict[str, GelPointerReflection]:
                            my_ptrs: dict[str, GelPointerReflection] = {
                                'owned': GelPointerReflection(
                                    name='owned',
                                    type=SchemaPath('std', 'bool'),
                                    typexpr='std::bool',
                                    kind=PointerKind('Property'),
                                    cardinality=pydantic.Cardinality('AtMostOne'),
                                    computed=False,
                                    readonly=False,
                                    has_default=False,
                                    properties=None,
                                ),
                                'is_owned': GelPointerReflection(
                                    name='is_owned',
                                    type=SchemaPath('std', 'bool'),
                                    typexpr='std::bool',
                                    kind=PointerKind('Property'),
                                    cardinality=pydantic.Cardinality('AtMostOne'),
                                    computed=False,
                                    readonly=False,
                                    has_default=False,
                                    properties=None,
                                ),
                            }
                            return my_ptrs


                    owned: OptionalProperty[___std__.bool, ___builtins_2__.bool]
                    is_owned: OptionalProperty[___std__.bool, ___builtins_2__.bool]
                __linkprops__: __lprops__

                def __init__(
                    self,
                    obj: schema.Rewrite,
                    /,
                    *,
                    owned: ___builtins_2__.bool | None = None,
                    is_owned: ___builtins_2__.bool | None = None,
                ) -> None:
                    ...

                @classmethod
                def link(
                    cls,
                    obj: schema.Rewrite,
                    /,
                    *,
                    owned: ___builtins_2__.bool | None = None,
                    is_owned: ___builtins_2__.bool | None = None,
                ) -> Self:
                    ...

        if not TYPE_CHECKING:
            @LazyClassProperty[type]
            @classmethod
            def rewrites(cls) -> type:
                class Pointer__rewrites(
                    ___schema__.Rewrite,
                    ProxyModel[___schema__.Rewrite],
                ):
                    """link schema::Pointer.rewrites: schema::Rewrite"""
                    class __lprops__(GelLinkModel):
                        class __gel_reflection__(
                            GelLinkModel.__gel_reflection__,
                        ):
                            id = UUID(int=218586751138303810113144406297311418768)
                            name = SchemaPath('rewrites')
                            @LazyClassProperty["dict[str, GelPointerReflection]"]
                            @classmethod
                            def pointers(
                                cls,
                            ) -> dict[str, GelPointerReflection]:
                                my_ptrs: dict[str, GelPointerReflection] = {
                                    'owned': GelPointerReflection(
                                        name='owned',
                                        type=SchemaPath('std', 'bool'),
                                        typexpr='std::bool',
                                        kind=PointerKind('Property'),
                                        cardinality=pydantic.Cardinality('AtMostOne'),
                                        computed=False,
                                        readonly=False,
                                        has_default=False,
                                        properties=None,
                                    ),
                                    'is_owned': GelPointerReflection(
                                        name='is_owned',
                                        type=SchemaPath('std', 'bool'),
                                        typexpr='std::bool',
                                        kind=PointerKind('Property'),
                                        cardinality=pydantic.Cardinality('AtMostOne'),
                                        computed=False,
                                        readonly=False,
                                        has_default=False,
                                        properties=None,
                                    ),
                                }
                                return my_ptrs


                        owned: OptionalProperty[std.bool, ___builtins_2__.bool]
                        is_owned: OptionalProperty[std.bool, ___builtins_2__.bool]
                    __linkprops__: __lprops__

                    def __init__(self, obj, /, **link_props) -> None:
                        ProxyModel.__init__(self, obj)
                        lprops = self.__class__.__lprops__(**link_props)
                        object.__setattr__(self, "__linkprops__", lprops)

                    @classmethod
                    def link(cls, obj, /, **link_props) -> Self:
                        return cls(obj, **link_props)

                Pointer__rewrites.__name__ = 'rewrites'
                Pointer__rewrites.__qualname__ = 'Pointer.rewrites'
                return Pointer__rewrites
    class __links_partial__(
        ConsistencySubject.__links_partial__,
        AnnotationSubject.__links_partial__,
    ):
        if TYPE_CHECKING:
            class rewrites(  # type: ignore [misc]
                schema.Rewrite.__variants__.Partial,
                ProxyModel[schema.Rewrite.__variants__.Partial],
            ):
                """link schema::Pointer.rewrites: schema::Rewrite"""
                class __lprops__(GelLinkModel):
                    class __gel_reflection__(GelLinkModel.__gel_reflection__):
                        id = UUID(int=218586751138303810113144406297311418768)
                        name = SchemaPath('rewrites')
                        @LazyClassProperty["dict[str, GelPointerReflection]"]
                        @classmethod
                        def pointers(cls) -> dict[str, GelPointerReflection]:
                            my_ptrs: dict[str, GelPointerReflection] = {
                                'owned': GelPointerReflection(
                                    name='owned',
                                    type=SchemaPath('std', 'bool'),
                                    typexpr='std::bool',
                                    kind=PointerKind('Property'),
                                    cardinality=pydantic.Cardinality('AtMostOne'),
                                    computed=False,
                                    readonly=False,
                                    has_default=False,
                                    properties=None,
                                ),
                                'is_owned': GelPointerReflection(
                                    name='is_owned',
                                    type=SchemaPath('std', 'bool'),
                                    typexpr='std::bool',
                                    kind=PointerKind('Property'),
                                    cardinality=pydantic.Cardinality('AtMostOne'),
                                    computed=False,
                                    readonly=False,
                                    has_default=False,
                                    properties=None,
                                ),
                            }
                            return my_ptrs


                    owned: OptionalProperty[___std__.bool, ___builtins_2__.bool]
                    is_owned: OptionalProperty[___std__.bool, ___builtins_2__.bool]
                __linkprops__: __lprops__

                def __init__(
                    self,
                    obj: schema.Rewrite.__variants__.Partial,
                    /,
                    *,
                    owned: ___builtins_2__.bool | None = None,
                    is_owned: ___builtins_2__.bool | None = None,
                ) -> None:
                    ...

                @classmethod
                def link(
                    cls,
                    obj: schema.Rewrite.__variants__.Partial,
                    /,
                    *,
                    owned: ___builtins_2__.bool | None = None,
                    is_owned: ___builtins_2__.bool | None = None,
                ) -> Self:
                    ...

        if not TYPE_CHECKING:
            @LazyClassProperty[type]
            @classmethod
            def rewrites(cls) -> type:
                class Pointer__rewrites(  # type: ignore [misc]
                    ___schema__.Rewrite.__variants__.Partial,
                    ProxyModel[___schema__.Rewrite.__variants__.Partial],
                ):
                    """link schema::Pointer.rewrites: schema::Rewrite"""
                    class __lprops__(GelLinkModel):
                        class __gel_reflection__(
                            GelLinkModel.__gel_reflection__,
                        ):
                            id = UUID(int=218586751138303810113144406297311418768)
                            name = SchemaPath('rewrites')
                            @LazyClassProperty["dict[str, GelPointerReflection]"]
                            @classmethod
                            def pointers(
                                cls,
                            ) -> dict[str, GelPointerReflection]:
                                my_ptrs: dict[str, GelPointerReflection] = {
                                    'owned': GelPointerReflection(
                                        name='owned',
                                        type=SchemaPath('std', 'bool'),
                                        typexpr='std::bool',
                                        kind=PointerKind('Property'),
                                        cardinality=pydantic.Cardinality('AtMostOne'),
                                        computed=False,
                                        readonly=False,
                                        has_default=False,
                                        properties=None,
                                    ),
                                    'is_owned': GelPointerReflection(
                                        name='is_owned',
                                        type=SchemaPath('std', 'bool'),
                                        typexpr='std::bool',
                                        kind=PointerKind('Property'),
                                        cardinality=pydantic.Cardinality('AtMostOne'),
                                        computed=False,
                                        readonly=False,
                                        has_default=False,
                                        properties=None,
                                    ),
                                }
                                return my_ptrs


                        owned: OptionalProperty[std.bool, ___builtins_2__.bool]
                        is_owned: OptionalProperty[std.bool, ___builtins_2__.bool]
                    __linkprops__: __lprops__

                    def __init__(self, obj, /, **link_props) -> None:
                        ProxyModel.__init__(self, obj)
                        lprops = self.__class__.__lprops__(**link_props)
                        object.__setattr__(self, "__linkprops__", lprops)

                    @classmethod
                    def link(cls, obj, /, **link_props) -> Self:
                        return cls(obj, **link_props)

                Pointer__rewrites.__name__ = 'rewrites'
                Pointer__rewrites.__qualname__ = 'Pointer.rewrites'
                return Pointer__rewrites

if not TYPE_CHECKING:
    Pointer.__variants__.Base = Pointer



#
# type schema::CollectionType
#
class __CollectionType_typeof_base__(__PrimitiveType_typeof_base__):
    class __gel_reflection__(__PrimitiveType_typeof_base__.__gel_reflection__):
        id = UUID(int=302606025822407465695339097537067301001)
        name = SchemaPath('schema', 'CollectionType')
        @LazyClassProperty["dict[str, ___pydantic_1__.GelPointerReflection]"]
        @classmethod
        def pointers(cls) -> dict[str, ___pydantic_1__.GelPointerReflection]:
            my_ptrs: dict[str, ___pydantic_1__.GelPointerReflection] = {}
            return (
                my_ptrs
                | __PrimitiveType_typeof_base__.__gel_reflection__.pointers
            )

        @LazyClassProperty["schema.ObjectType"]
        @classmethod
        def object(cls) -> schema.ObjectType:
            from ... import schema as ___schema_1__
            return ___schema_1__.ObjectType(
                id=UUID(int=302606025822407465695339097537067301001),
                name='schema::CollectionType',
                builtin=True,
                internal=False,
                abstract=True,
                final=False,
                compound_type=False,
            )

class __CollectionType_typeof__(
    __PrimitiveType_typeof__,
    __CollectionType_typeof_base__,
):
    class __typeof__(__PrimitiveType_typeof__.__typeof__):
        pass


class __CollectionType_typeof_partial__(
    __PrimitiveType_typeof_partial__,
    __CollectionType_typeof_base__,
):
    class __typeof__(__PrimitiveType_typeof_partial__.__typeof__):
        pass


class CollectionType(
    __CollectionType_typeof__,
    PrimitiveType,
    __gel_type_id__=UUID(int=302606025822407465695339097537067301001),
):
    if TYPE_CHECKING:
        def __init__(
            self,
            /,
            *,
            id: UUID | DefaultValue = DEFAULT_VALUE,
            name: builtins.str,
            internal: bool | DefaultValue = DEFAULT_VALUE,
            builtin: bool | DefaultValue = DEFAULT_VALUE,
            computed_fields: list[builtins.str] | None = None,
            annotations: Iterable[Annotation] = [],
            abstract: bool | None | DefaultValue = DEFAULT_VALUE,
            final: bool,
            expr: builtins.str | None = None,
            from_alias: bool | None = None,
        ) -> None:
            """Create a new schema::CollectionType instance from keyword arguments.

            Call db.save() on the returned object to persist it in the database.
            """
            ...

    if TYPE_CHECKING:
        @classmethod
        def update(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
            abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            from_alias: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Update schema::CollectionType instances in the database.
            """
            ...

        @classmethod
        def select(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: PathAlias | Literal["*"],
            id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Annotation] | UnspecifiedType = Unspecified,
            abstract: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            final: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            expr: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            from_alias: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
        ) -> type[Self]:
            """Fetch schema::CollectionType instances from the database.
            """
            ...

        @classmethod
        def filter(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], type[___std__.bool]],
            id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
            abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            final: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            from_alias: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Fetch schema::CollectionType instances from the database.
            """
            ...

        @classmethod
        def order_by(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
            id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            abstract: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            final: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            expr: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            from_alias: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Specify the sort order for the selection"""
            ...


    class __variants__(PrimitiveType.__variants__):
        class Base(
            __CollectionType_typeof__,
            PrimitiveType.__variants__.Base,
            __gel_variant__="Base",
        ):
            if TYPE_CHECKING:
                def __init__(
                    self,
                    /,
                    *,
                    id: UUID | DefaultValue = DEFAULT_VALUE,
                    name: builtins.str,
                    internal: bool | DefaultValue = DEFAULT_VALUE,
                    builtin: bool | DefaultValue = DEFAULT_VALUE,
                    computed_fields: list[builtins.str] | None = None,
                    annotations: Iterable[Annotation] = [],
                    abstract: bool | None | DefaultValue = DEFAULT_VALUE,
                    final: bool,
                    expr: builtins.str | None = None,
                    from_alias: bool | None = None,
                ) -> None:
                    """Create a new schema::CollectionType instance from keyword arguments.

                    Call db.save() on the returned object to persist it in the database.
                    """
                    ...

            if TYPE_CHECKING:
                @classmethod
                def update(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
                    abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    from_alias: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Update schema::CollectionType instances in the database.
                    """
                    ...

                @classmethod
                def select(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: PathAlias | Literal["*"],
                    id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Annotation] | UnspecifiedType = Unspecified,
                    abstract: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    final: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    expr: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    from_alias: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
                ) -> type[Self]:
                    """Fetch schema::CollectionType instances from the database.
                    """
                    ...

                @classmethod
                def filter(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], type[___std__.bool]],
                    id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
                    abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    final: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    from_alias: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Fetch schema::CollectionType instances from the database.
                    """
                    ...

                @classmethod
                def order_by(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
                    id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    abstract: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    final: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    expr: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    from_alias: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Specify the sort order for the selection"""
                    ...

        class Required(
            Base,
            PrimitiveType.__variants__.Required,
            __gel_variant__="Required",
        ):
            pass

        class PartialBase(  # type: ignore [misc, unused-ignore]
            __CollectionType_typeof_partial__,
            Base,
            PrimitiveType.__variants__.PartialBase,
            __gel_variant__="PartialBase",
        ):
            pass

        class Partial(  # type: ignore [misc, unused-ignore]
            PartialBase,
            PrimitiveType.__variants__.Partial,
            __gel_variant__="Partial",
        ):
            pass


        Any = TypeVar("Any", bound="CollectionType | Base | Required | Partial")
    class __links__(PrimitiveType.__links__):
        pass
    class __links_partial__(PrimitiveType.__links_partial__):
        pass

if not TYPE_CHECKING:
    CollectionType.__variants__.Base = CollectionType



#
# type schema::ScalarType
#
class __ScalarType_typeof_base__(
    __PrimitiveType_typeof_base__,
    __ConsistencySubject_typeof_base__,
    __AnnotationSubject_typeof_base__,
):
    class __gel_reflection__(
        __PrimitiveType_typeof_base__.__gel_reflection__,
        __ConsistencySubject_typeof_base__.__gel_reflection__,
        __AnnotationSubject_typeof_base__.__gel_reflection__,
    ):
        id = UUID(int=276925256413372055258128037770702872862)
        name = SchemaPath('schema', 'ScalarType')
        @LazyClassProperty["dict[str, GelPointerReflection]"]
        @classmethod
        def pointers(cls) -> dict[str, GelPointerReflection]:
            my_ptrs: dict[str, GelPointerReflection] = {
                'default': GelPointerReflection(
                    name='default',
                    type=SchemaPath('std', 'str'),
                    typexpr='std::str',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
                'enum_values': GelPointerReflection(
                    name='enum_values',
                    type=SchemaPath('array<std::str>'),
                    typexpr='array<std::str>',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
                'arg_values': GelPointerReflection(
                    name='arg_values',
                    type=SchemaPath('array<std::str>'),
                    typexpr='array<std::str>',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
            }
            return (
                my_ptrs
                | __PrimitiveType_typeof_base__.__gel_reflection__.pointers
                | __ConsistencySubject_typeof_base__.__gel_reflection__.pointers
                | __AnnotationSubject_typeof_base__.__gel_reflection__.pointers
            )

        @LazyClassProperty["schema.ObjectType"]
        @classmethod
        def object(cls) -> schema.ObjectType:
            from ... import schema as ___schema_1__
            return ___schema_1__.ObjectType(
                id=UUID(int=276925256413372055258128037770702872862),
                name='schema::ScalarType',
                builtin=True,
                internal=False,
                abstract=False,
                final=False,
                compound_type=False,
            )

class __ScalarType_typeof__(
    __PrimitiveType_typeof__,
    __ConsistencySubject_typeof__,
    __AnnotationSubject_typeof__,
    __ScalarType_typeof_base__,
):
    class __typeof__(
        __PrimitiveType_typeof__.__typeof__,
        __ConsistencySubject_typeof__.__typeof__,
        __AnnotationSubject_typeof__.__typeof__,
    ):
        default = TypeAliasType('default', 'OptionalProperty[std.str, builtins.str]')
        enum_values = TypeAliasType('enum_values', 'OptionalProperty[___pydantic__.Array[std.str], list[builtins.str]]')
        arg_values = TypeAliasType('arg_values', 'OptionalProperty[___pydantic__.Array[std.str], list[builtins.str]]')


class __ScalarType_typeof_partial__(
    __PrimitiveType_typeof_partial__,
    __ConsistencySubject_typeof_partial__,
    __AnnotationSubject_typeof_partial__,
    __ScalarType_typeof_base__,
):
    class __typeof__(
        __PrimitiveType_typeof_partial__.__typeof__,
        __ConsistencySubject_typeof_partial__.__typeof__,
        __AnnotationSubject_typeof_partial__.__typeof__,
    ):
        default = TypeAliasType('default', 'OptionalProperty[std.str, builtins.str]')
        enum_values = TypeAliasType('enum_values', 'OptionalProperty[___pydantic__.Array[std.str], list[builtins.str]]')
        arg_values = TypeAliasType('arg_values', 'OptionalProperty[___pydantic__.Array[std.str], list[builtins.str]]')


class ScalarType(
    __ScalarType_typeof__,
    PrimitiveType,
    ConsistencySubject,
    AnnotationSubject,
    __gel_type_id__=UUID(int=276925256413372055258128037770702872862),
):
    if TYPE_CHECKING:
        def __init__(
            self,
            /,
            *,
            id: UUID | DefaultValue = DEFAULT_VALUE,
            name: builtins.str,
            internal: bool | DefaultValue = DEFAULT_VALUE,
            builtin: bool | DefaultValue = DEFAULT_VALUE,
            computed_fields: list[builtins.str] | None = None,
            annotations: Iterable[Annotation] = [],
            abstract: bool | None | DefaultValue = DEFAULT_VALUE,
            final: bool,
            expr: builtins.str | None = None,
            from_alias: bool | None = None,
            inherited_fields: list[builtins.str] | None = None,
            bases: Iterable[InheritingObject] = [],
            ancestors: Iterable[InheritingObject] = [],
            constraints: Iterable[Constraint] = [],
            default: builtins.str | None = None,
            enum_values: list[builtins.str] | None = None,
            arg_values: list[builtins.str] | None = None,
        ) -> None:
            """Create a new schema::ScalarType instance from keyword arguments.

            Call db.save() on the returned object to persist it in the database.
            """
            ...

    if TYPE_CHECKING:
        @classmethod
        def update(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
            abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            from_alias: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            inherited_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            bases: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            ancestors: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            constraints: type[schema.Constraint] | UnspecifiedType = Unspecified,
            default: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            enum_values: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            arg_values: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Update schema::ScalarType instances in the database.
            """
            ...

        @classmethod
        def select(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: PathAlias | Literal["*"],
            id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Annotation] | UnspecifiedType = Unspecified,
            abstract: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            final: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            expr: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            from_alias: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            inherited_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            bases: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            ancestors: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            constraints: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Constraint] | UnspecifiedType = Unspecified,
            default: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            enum_values: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            arg_values: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
        ) -> type[Self]:
            """Fetch schema::ScalarType instances from the database.
            """
            ...

        @classmethod
        def filter(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], type[___std__.bool]],
            id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
            abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            final: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            from_alias: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            inherited_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            bases: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            ancestors: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            constraints: type[schema.Constraint] | UnspecifiedType = Unspecified,
            default: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            enum_values: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            arg_values: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Fetch schema::ScalarType instances from the database.
            """
            ...

        @classmethod
        def order_by(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
            id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            abstract: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            final: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            expr: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            from_alias: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            default: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Specify the sort order for the selection"""
            ...


    class __variants__(
        PrimitiveType.__variants__,
        ConsistencySubject.__variants__,
        AnnotationSubject.__variants__,
    ):
        class Base(
            __ScalarType_typeof__,
            PrimitiveType.__variants__.Base,
            ConsistencySubject.__variants__.Base,
            AnnotationSubject.__variants__.Base,
            __gel_variant__="Base",
        ):
            if TYPE_CHECKING:
                def __init__(
                    self,
                    /,
                    *,
                    id: UUID | DefaultValue = DEFAULT_VALUE,
                    name: builtins.str,
                    internal: bool | DefaultValue = DEFAULT_VALUE,
                    builtin: bool | DefaultValue = DEFAULT_VALUE,
                    computed_fields: list[builtins.str] | None = None,
                    annotations: Iterable[Annotation] = [],
                    abstract: bool | None | DefaultValue = DEFAULT_VALUE,
                    final: bool,
                    expr: builtins.str | None = None,
                    from_alias: bool | None = None,
                    inherited_fields: list[builtins.str] | None = None,
                    bases: Iterable[InheritingObject] = [],
                    ancestors: Iterable[InheritingObject] = [],
                    constraints: Iterable[Constraint] = [],
                    default: builtins.str | None = None,
                    enum_values: list[builtins.str] | None = None,
                    arg_values: list[builtins.str] | None = None,
                ) -> None:
                    """Create a new schema::ScalarType instance from keyword arguments.

                    Call db.save() on the returned object to persist it in the database.
                    """
                    ...

            if TYPE_CHECKING:
                @classmethod
                def update(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
                    abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    from_alias: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    inherited_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    bases: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    ancestors: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    constraints: type[schema.Constraint] | UnspecifiedType = Unspecified,
                    default: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    enum_values: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    arg_values: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Update schema::ScalarType instances in the database.
                    """
                    ...

                @classmethod
                def select(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: PathAlias | Literal["*"],
                    id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Annotation] | UnspecifiedType = Unspecified,
                    abstract: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    final: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    expr: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    from_alias: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    inherited_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    bases: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    ancestors: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    constraints: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Constraint] | UnspecifiedType = Unspecified,
                    default: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    enum_values: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    arg_values: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
                ) -> type[Self]:
                    """Fetch schema::ScalarType instances from the database.
                    """
                    ...

                @classmethod
                def filter(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], type[___std__.bool]],
                    id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
                    abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    final: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    from_alias: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    inherited_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    bases: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    ancestors: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    constraints: type[schema.Constraint] | UnspecifiedType = Unspecified,
                    default: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    enum_values: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    arg_values: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Fetch schema::ScalarType instances from the database.
                    """
                    ...

                @classmethod
                def order_by(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
                    id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    abstract: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    final: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    expr: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    from_alias: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    default: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Specify the sort order for the selection"""
                    ...

        class Required(
            Base,
            PrimitiveType.__variants__.Required,
            ConsistencySubject.__variants__.Required,
            AnnotationSubject.__variants__.Required,
            __gel_variant__="Required",
        ):
            pass

        class PartialBase(  # type: ignore [misc, unused-ignore]
            __ScalarType_typeof_partial__,
            Base,
            PrimitiveType.__variants__.PartialBase,
            ConsistencySubject.__variants__.PartialBase,
            AnnotationSubject.__variants__.PartialBase,
            __gel_variant__="PartialBase",
        ):
            pass

        class Partial(  # type: ignore [misc, unused-ignore]
            PartialBase,
            PrimitiveType.__variants__.Partial,
            ConsistencySubject.__variants__.Partial,
            AnnotationSubject.__variants__.Partial,
            __gel_variant__="Partial",
        ):
            default: OptionalProperty[std.str, builtins.str]
            enum_values: OptionalProperty[___pydantic__.Array[std.str], list[builtins.str]]
            arg_values: OptionalProperty[___pydantic__.Array[std.str], list[builtins.str]]


        Any = TypeVar("Any", bound="ScalarType | Base | Required | Partial")
    class __links__(
        PrimitiveType.__links__,
        ConsistencySubject.__links__,
        AnnotationSubject.__links__,
    ):
        pass
    class __links_partial__(
        PrimitiveType.__links_partial__,
        ConsistencySubject.__links_partial__,
        AnnotationSubject.__links_partial__,
    ):
        pass

if not TYPE_CHECKING:
    ScalarType.__variants__.Base = ScalarType



#
# type schema::Link
#
class __Link_typeof_base__(__Pointer_typeof_base__, __Source_typeof_base__):
    class __gel_reflection__(
        __Pointer_typeof_base__.__gel_reflection__,
        __Source_typeof_base__.__gel_reflection__,
    ):
        id = UUID(int=203363928536405864267916671259475739976)
        name = SchemaPath('schema', 'Link')
        @LazyClassProperty["dict[str, GelPointerReflection]"]
        @classmethod
        def pointers(cls) -> dict[str, GelPointerReflection]:
            my_ptrs: dict[str, GelPointerReflection] = {
                'on_target_delete': GelPointerReflection(
                    name='on_target_delete',
                    type=SchemaPath('schema', 'TargetDeleteAction'),
                    typexpr='schema::TargetDeleteAction',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
                'on_source_delete': GelPointerReflection(
                    name='on_source_delete',
                    type=SchemaPath('schema', 'SourceDeleteAction'),
                    typexpr='schema::SourceDeleteAction',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
                'target': GelPointerReflection(
                    name='target',
                    type=SchemaPath('schema', 'ObjectType'),
                    typexpr='schema::ObjectType',
                    kind=PointerKind('Link'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
                'properties': GelPointerReflection(
                    name='properties',
                    type=SchemaPath('schema', 'Property'),
                    typexpr='schema::Property',
                    kind=PointerKind('Link'),
                    cardinality=pydantic.Cardinality('Many'),
                    computed=True,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
            }
            return (
                my_ptrs
                | __Pointer_typeof_base__.__gel_reflection__.pointers
                | __Source_typeof_base__.__gel_reflection__.pointers
            )

        @LazyClassProperty["schema.ObjectType"]
        @classmethod
        def object(cls) -> schema.ObjectType:
            from ... import schema as ___schema_1__
            return ___schema_1__.ObjectType(
                id=UUID(int=203363928536405864267916671259475739976),
                name='schema::Link',
                builtin=True,
                internal=False,
                abstract=False,
                final=False,
                compound_type=False,
            )

class __Link_typeof__(
    __Pointer_typeof__,
    __Source_typeof__,
    __Link_typeof_base__,
):
    class __typeof__(
        __Pointer_typeof__.__typeof__,
        __Source_typeof__.__typeof__,
    ):
        on_target_delete = TypeAliasType('on_target_delete', 'OptionalProperty[TargetDeleteAction, ___builtins_1__.str]')
        on_source_delete = TypeAliasType('on_source_delete', 'OptionalProperty[SourceDeleteAction, ___builtins_1__.str]')
        target = TypeAliasType('target', 'OptionalLink[ObjectType]')
        properties = TypeAliasType('properties', 'ComputedMultiLink[Property]')


class __Link_typeof_partial__(
    __Pointer_typeof_partial__,
    __Source_typeof_partial__,
    __Link_typeof_base__,
):
    class __typeof__(
        __Pointer_typeof_partial__.__typeof__,
        __Source_typeof_partial__.__typeof__,
    ):
        on_target_delete = TypeAliasType('on_target_delete', 'OptionalProperty[TargetDeleteAction, ___builtins_1__.str]')
        on_source_delete = TypeAliasType('on_source_delete', 'OptionalProperty[SourceDeleteAction, ___builtins_1__.str]')
        target = TypeAliasType('target', 'OptionalLink[ObjectType | ObjectType.__variants__.Partial]')
        properties = TypeAliasType('properties', 'ComputedMultiLink[Property | Property.__variants__.Partial]')


class Link(
    __Link_typeof__,
    Pointer,
    Source,
    __gel_type_id__=UUID(int=203363928536405864267916671259475739976),
):
    if TYPE_CHECKING:
        def __init__(
            self,
            /,
            *,
            id: UUID | DefaultValue = DEFAULT_VALUE,
            name: builtins.str,
            internal: bool | DefaultValue = DEFAULT_VALUE,
            builtin: bool | DefaultValue = DEFAULT_VALUE,
            computed_fields: list[builtins.str] | None = None,
            annotations: Iterable[Annotation] = [],
            abstract: bool | None | DefaultValue = DEFAULT_VALUE,
            final: bool,
            inherited_fields: list[builtins.str] | None = None,
            bases: Iterable[InheritingObject] = [],
            ancestors: Iterable[InheritingObject] = [],
            pointers: Iterable[Pointer] = [],
            indexes: Iterable[Index] = [],
            constraints: Iterable[Constraint] = [],
            cardinality: ___builtins_1__.str | None = None,
            required: bool | None = None,
            readonly: bool | None = None,
            default: builtins.str | None = None,
            expr: builtins.str | None = None,
            secret: bool | None = None,
            source: Source | None = None,
            target: ObjectType | None = None,
            rewrites: Iterable[Rewrite] = [],
            on_target_delete: ___builtins_1__.str | None = None,
            on_source_delete: ___builtins_1__.str | None = None,
            properties: Iterable[Property] = [],
        ) -> None:
            """Create a new schema::Link instance from keyword arguments.

            Call db.save() on the returned object to persist it in the database.
            """
            ...

    if TYPE_CHECKING:
        @classmethod
        def update(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
            abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            inherited_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            bases: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            ancestors: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            pointers: type[schema.Pointer] | UnspecifiedType = Unspecified,
            indexes: type[schema.Index] | UnspecifiedType = Unspecified,
            constraints: type[schema.Constraint] | UnspecifiedType = Unspecified,
            cardinality: type[Cardinality] | UnspecifiedType = Unspecified,
            required: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            readonly: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            default: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            secret: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            source: type[schema.Source] | UnspecifiedType = Unspecified,
            target: type[schema.ObjectType] | UnspecifiedType = Unspecified,
            rewrites: type[schema.Rewrite] | UnspecifiedType = Unspecified,
            on_target_delete: type[TargetDeleteAction] | UnspecifiedType = Unspecified,
            on_source_delete: type[SourceDeleteAction] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Update schema::Link instances in the database.
            """
            ...

        @classmethod
        def select(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: PathAlias | Literal["*"],
            id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Annotation] | UnspecifiedType = Unspecified,
            abstract: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            final: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            inherited_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            bases: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            ancestors: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            pointers: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Pointer] | UnspecifiedType = Unspecified,
            indexes: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Index] | UnspecifiedType = Unspecified,
            constraints: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Constraint] | UnspecifiedType = Unspecified,
            cardinality: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[Cardinality] | UnspecifiedType = Unspecified,
            required: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            readonly: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            default: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            expr: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            secret: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            source: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Source] | UnspecifiedType = Unspecified,
            target: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.ObjectType] | UnspecifiedType = Unspecified,
            rewrites: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Rewrite] | UnspecifiedType = Unspecified,
            on_target_delete: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[TargetDeleteAction] | UnspecifiedType = Unspecified,
            on_source_delete: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[SourceDeleteAction] | UnspecifiedType = Unspecified,
            properties: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Property] | UnspecifiedType = Unspecified,
            **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
        ) -> type[Self]:
            """Fetch schema::Link instances from the database.
            """
            ...

        @classmethod
        def filter(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], type[___std__.bool]],
            id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
            abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            final: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            inherited_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            bases: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            ancestors: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            pointers: type[schema.Pointer] | UnspecifiedType = Unspecified,
            indexes: type[schema.Index] | UnspecifiedType = Unspecified,
            constraints: type[schema.Constraint] | UnspecifiedType = Unspecified,
            cardinality: type[Cardinality] | UnspecifiedType = Unspecified,
            required: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            readonly: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            default: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            secret: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            source: type[schema.Source] | UnspecifiedType = Unspecified,
            target: type[schema.ObjectType] | UnspecifiedType = Unspecified,
            rewrites: type[schema.Rewrite] | UnspecifiedType = Unspecified,
            on_target_delete: type[TargetDeleteAction] | UnspecifiedType = Unspecified,
            on_source_delete: type[SourceDeleteAction] | UnspecifiedType = Unspecified,
            properties: type[schema.Property] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Fetch schema::Link instances from the database.
            """
            ...

        @classmethod
        def order_by(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
            id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            abstract: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            final: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            required: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            readonly: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            default: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            expr: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            secret: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Specify the sort order for the selection"""
            ...


    class __variants__(Pointer.__variants__, Source.__variants__):
        class Base(
            __Link_typeof__,
            Pointer.__variants__.Base,
            Source.__variants__.Base,
            __gel_variant__="Base",
        ):
            if TYPE_CHECKING:
                def __init__(
                    self,
                    /,
                    *,
                    id: UUID | DefaultValue = DEFAULT_VALUE,
                    name: builtins.str,
                    internal: bool | DefaultValue = DEFAULT_VALUE,
                    builtin: bool | DefaultValue = DEFAULT_VALUE,
                    computed_fields: list[builtins.str] | None = None,
                    annotations: Iterable[Annotation] = [],
                    abstract: bool | None | DefaultValue = DEFAULT_VALUE,
                    final: bool,
                    inherited_fields: list[builtins.str] | None = None,
                    bases: Iterable[InheritingObject] = [],
                    ancestors: Iterable[InheritingObject] = [],
                    pointers: Iterable[Pointer] = [],
                    indexes: Iterable[Index] = [],
                    constraints: Iterable[Constraint] = [],
                    cardinality: ___builtins_1__.str | None = None,
                    required: bool | None = None,
                    readonly: bool | None = None,
                    default: builtins.str | None = None,
                    expr: builtins.str | None = None,
                    secret: bool | None = None,
                    source: Source | None = None,
                    target: ObjectType | None = None,
                    rewrites: Iterable[Rewrite] = [],
                    on_target_delete: ___builtins_1__.str | None = None,
                    on_source_delete: ___builtins_1__.str | None = None,
                    properties: Iterable[Property] = [],
                ) -> None:
                    """Create a new schema::Link instance from keyword arguments.

                    Call db.save() on the returned object to persist it in the database.
                    """
                    ...

            if TYPE_CHECKING:
                @classmethod
                def update(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
                    abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    inherited_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    bases: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    ancestors: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    pointers: type[schema.Pointer] | UnspecifiedType = Unspecified,
                    indexes: type[schema.Index] | UnspecifiedType = Unspecified,
                    constraints: type[schema.Constraint] | UnspecifiedType = Unspecified,
                    cardinality: type[Cardinality] | UnspecifiedType = Unspecified,
                    required: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    readonly: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    default: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    secret: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    source: type[schema.Source] | UnspecifiedType = Unspecified,
                    target: type[schema.ObjectType] | UnspecifiedType = Unspecified,
                    rewrites: type[schema.Rewrite] | UnspecifiedType = Unspecified,
                    on_target_delete: type[TargetDeleteAction] | UnspecifiedType = Unspecified,
                    on_source_delete: type[SourceDeleteAction] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Update schema::Link instances in the database.
                    """
                    ...

                @classmethod
                def select(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: PathAlias | Literal["*"],
                    id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Annotation] | UnspecifiedType = Unspecified,
                    abstract: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    final: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    inherited_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    bases: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    ancestors: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    pointers: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Pointer] | UnspecifiedType = Unspecified,
                    indexes: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Index] | UnspecifiedType = Unspecified,
                    constraints: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Constraint] | UnspecifiedType = Unspecified,
                    cardinality: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[Cardinality] | UnspecifiedType = Unspecified,
                    required: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    readonly: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    default: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    expr: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    secret: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    source: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Source] | UnspecifiedType = Unspecified,
                    target: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.ObjectType] | UnspecifiedType = Unspecified,
                    rewrites: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Rewrite] | UnspecifiedType = Unspecified,
                    on_target_delete: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[TargetDeleteAction] | UnspecifiedType = Unspecified,
                    on_source_delete: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[SourceDeleteAction] | UnspecifiedType = Unspecified,
                    properties: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Property] | UnspecifiedType = Unspecified,
                    **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
                ) -> type[Self]:
                    """Fetch schema::Link instances from the database.
                    """
                    ...

                @classmethod
                def filter(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], type[___std__.bool]],
                    id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
                    abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    final: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    inherited_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    bases: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    ancestors: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    pointers: type[schema.Pointer] | UnspecifiedType = Unspecified,
                    indexes: type[schema.Index] | UnspecifiedType = Unspecified,
                    constraints: type[schema.Constraint] | UnspecifiedType = Unspecified,
                    cardinality: type[Cardinality] | UnspecifiedType = Unspecified,
                    required: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    readonly: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    default: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    secret: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    source: type[schema.Source] | UnspecifiedType = Unspecified,
                    target: type[schema.ObjectType] | UnspecifiedType = Unspecified,
                    rewrites: type[schema.Rewrite] | UnspecifiedType = Unspecified,
                    on_target_delete: type[TargetDeleteAction] | UnspecifiedType = Unspecified,
                    on_source_delete: type[SourceDeleteAction] | UnspecifiedType = Unspecified,
                    properties: type[schema.Property] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Fetch schema::Link instances from the database.
                    """
                    ...

                @classmethod
                def order_by(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
                    id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    abstract: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    final: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    required: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    readonly: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    default: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    expr: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    secret: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Specify the sort order for the selection"""
                    ...

        class Required(
            Base,
            Pointer.__variants__.Required,
            Source.__variants__.Required,
            __gel_variant__="Required",
        ):
            pass

        class PartialBase(  # type: ignore [misc, unused-ignore]
            __Link_typeof_partial__,
            Base,
            Pointer.__variants__.PartialBase,
            Source.__variants__.PartialBase,
            __gel_variant__="PartialBase",
        ):
            pass

        class Partial(  # type: ignore [misc, unused-ignore]
            PartialBase,
            Pointer.__variants__.Partial,
            Source.__variants__.Partial,
            __gel_variant__="Partial",
        ):
            on_target_delete: OptionalProperty[TargetDeleteAction, ___builtins_1__.str]
            on_source_delete: OptionalProperty[SourceDeleteAction, ___builtins_1__.str]
            target: OptionalLink[___schema__.ObjectType | ___schema__.ObjectType.__variants__.Partial]
            properties: ComputedMultiLink[___schema__.Property | ___schema__.Property.__variants__.Partial]


        Any = TypeVar("Any", bound="Link | Base | Required | Partial")
    class __links__(Pointer.__links__, Source.__links__):
        pass
    class __links_partial__(
        Pointer.__links_partial__,
        Source.__links_partial__,
    ):
        pass

if not TYPE_CHECKING:
    Link.__variants__.Base = Link



#
# type schema::Property
#
class __Property_typeof_base__(__Pointer_typeof_base__):
    class __gel_reflection__(__Pointer_typeof_base__.__gel_reflection__):
        id = UUID(int=219983521560701621898641991940434680828)
        name = SchemaPath('schema', 'Property')
        @LazyClassProperty["dict[str, ___pydantic_1__.GelPointerReflection]"]
        @classmethod
        def pointers(cls) -> dict[str, ___pydantic_1__.GelPointerReflection]:
            my_ptrs: dict[str, ___pydantic_1__.GelPointerReflection] = {}
            return (
                my_ptrs
                | __Pointer_typeof_base__.__gel_reflection__.pointers
            )

        @LazyClassProperty["schema.ObjectType"]
        @classmethod
        def object(cls) -> schema.ObjectType:
            from ... import schema as ___schema_1__
            return ___schema_1__.ObjectType(
                id=UUID(int=219983521560701621898641991940434680828),
                name='schema::Property',
                builtin=True,
                internal=False,
                abstract=False,
                final=False,
                compound_type=False,
            )

class __Property_typeof__(__Pointer_typeof__, __Property_typeof_base__):
    class __typeof__(__Pointer_typeof__.__typeof__):
        pass


class __Property_typeof_partial__(
    __Pointer_typeof_partial__,
    __Property_typeof_base__,
):
    class __typeof__(__Pointer_typeof_partial__.__typeof__):
        pass


class Property(
    __Property_typeof__,
    Pointer,
    __gel_type_id__=UUID(int=219983521560701621898641991940434680828),
):
    if TYPE_CHECKING:
        def __init__(
            self,
            /,
            *,
            id: UUID | DefaultValue = DEFAULT_VALUE,
            name: builtins.str,
            internal: bool | DefaultValue = DEFAULT_VALUE,
            builtin: bool | DefaultValue = DEFAULT_VALUE,
            computed_fields: list[builtins.str] | None = None,
            annotations: Iterable[Annotation] = [],
            abstract: bool | None | DefaultValue = DEFAULT_VALUE,
            final: bool,
            inherited_fields: list[builtins.str] | None = None,
            bases: Iterable[InheritingObject] = [],
            ancestors: Iterable[InheritingObject] = [],
            constraints: Iterable[Constraint] = [],
            cardinality: ___builtins_1__.str | None = None,
            required: bool | None = None,
            readonly: bool | None = None,
            default: builtins.str | None = None,
            expr: builtins.str | None = None,
            secret: bool | None = None,
            source: Source | None = None,
            target: Type | None = None,
            rewrites: Iterable[Rewrite] = [],
        ) -> None:
            """Create a new schema::Property instance from keyword arguments.

            Call db.save() on the returned object to persist it in the database.
            """
            ...

    if TYPE_CHECKING:
        @classmethod
        def update(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
            abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            inherited_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            bases: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            ancestors: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            constraints: type[schema.Constraint] | UnspecifiedType = Unspecified,
            cardinality: type[Cardinality] | UnspecifiedType = Unspecified,
            required: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            readonly: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            default: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            secret: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            source: type[schema.Source] | UnspecifiedType = Unspecified,
            target: type[schema.Type] | UnspecifiedType = Unspecified,
            rewrites: type[schema.Rewrite] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Update schema::Property instances in the database.
            """
            ...

        @classmethod
        def select(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: PathAlias | Literal["*"],
            id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Annotation] | UnspecifiedType = Unspecified,
            abstract: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            final: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            inherited_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            bases: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            ancestors: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            constraints: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Constraint] | UnspecifiedType = Unspecified,
            cardinality: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[Cardinality] | UnspecifiedType = Unspecified,
            required: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            readonly: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            default: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            expr: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            secret: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            source: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Source] | UnspecifiedType = Unspecified,
            target: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Type] | UnspecifiedType = Unspecified,
            rewrites: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Rewrite] | UnspecifiedType = Unspecified,
            **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
        ) -> type[Self]:
            """Fetch schema::Property instances from the database.
            """
            ...

        @classmethod
        def filter(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], type[___std__.bool]],
            id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
            abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            final: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            inherited_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            bases: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            ancestors: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
            constraints: type[schema.Constraint] | UnspecifiedType = Unspecified,
            cardinality: type[Cardinality] | UnspecifiedType = Unspecified,
            required: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            readonly: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            default: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            secret: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            source: type[schema.Source] | UnspecifiedType = Unspecified,
            target: type[schema.Type] | UnspecifiedType = Unspecified,
            rewrites: type[schema.Rewrite] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Fetch schema::Property instances from the database.
            """
            ...

        @classmethod
        def order_by(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
            id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            abstract: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            final: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            required: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            readonly: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            default: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            expr: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            secret: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Specify the sort order for the selection"""
            ...


    class __variants__(Pointer.__variants__):
        class Base(
            __Property_typeof__,
            Pointer.__variants__.Base,
            __gel_variant__="Base",
        ):
            if TYPE_CHECKING:
                def __init__(
                    self,
                    /,
                    *,
                    id: UUID | DefaultValue = DEFAULT_VALUE,
                    name: builtins.str,
                    internal: bool | DefaultValue = DEFAULT_VALUE,
                    builtin: bool | DefaultValue = DEFAULT_VALUE,
                    computed_fields: list[builtins.str] | None = None,
                    annotations: Iterable[Annotation] = [],
                    abstract: bool | None | DefaultValue = DEFAULT_VALUE,
                    final: bool,
                    inherited_fields: list[builtins.str] | None = None,
                    bases: Iterable[InheritingObject] = [],
                    ancestors: Iterable[InheritingObject] = [],
                    constraints: Iterable[Constraint] = [],
                    cardinality: ___builtins_1__.str | None = None,
                    required: bool | None = None,
                    readonly: bool | None = None,
                    default: builtins.str | None = None,
                    expr: builtins.str | None = None,
                    secret: bool | None = None,
                    source: Source | None = None,
                    target: Type | None = None,
                    rewrites: Iterable[Rewrite] = [],
                ) -> None:
                    """Create a new schema::Property instance from keyword arguments.

                    Call db.save() on the returned object to persist it in the database.
                    """
                    ...

            if TYPE_CHECKING:
                @classmethod
                def update(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
                    abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    inherited_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    bases: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    ancestors: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    constraints: type[schema.Constraint] | UnspecifiedType = Unspecified,
                    cardinality: type[Cardinality] | UnspecifiedType = Unspecified,
                    required: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    readonly: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    default: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    secret: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    source: type[schema.Source] | UnspecifiedType = Unspecified,
                    target: type[schema.Type] | UnspecifiedType = Unspecified,
                    rewrites: type[schema.Rewrite] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Update schema::Property instances in the database.
                    """
                    ...

                @classmethod
                def select(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: PathAlias | Literal["*"],
                    id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Annotation] | UnspecifiedType = Unspecified,
                    abstract: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    final: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    inherited_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    bases: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    ancestors: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    constraints: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Constraint] | UnspecifiedType = Unspecified,
                    cardinality: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[Cardinality] | UnspecifiedType = Unspecified,
                    required: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    readonly: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    default: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    expr: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    secret: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    source: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Source] | UnspecifiedType = Unspecified,
                    target: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Type] | UnspecifiedType = Unspecified,
                    rewrites: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Rewrite] | UnspecifiedType = Unspecified,
                    **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
                ) -> type[Self]:
                    """Fetch schema::Property instances from the database.
                    """
                    ...

                @classmethod
                def filter(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], type[___std__.bool]],
                    id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
                    abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    final: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    inherited_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    bases: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    ancestors: type[schema.InheritingObject] | UnspecifiedType = Unspecified,
                    constraints: type[schema.Constraint] | UnspecifiedType = Unspecified,
                    cardinality: type[Cardinality] | UnspecifiedType = Unspecified,
                    required: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    readonly: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    default: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    secret: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    source: type[schema.Source] | UnspecifiedType = Unspecified,
                    target: type[schema.Type] | UnspecifiedType = Unspecified,
                    rewrites: type[schema.Rewrite] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Fetch schema::Property instances from the database.
                    """
                    ...

                @classmethod
                def order_by(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
                    id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    abstract: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    final: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    required: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    readonly: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    default: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    expr: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    secret: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Specify the sort order for the selection"""
                    ...

        class Required(
            Base,
            Pointer.__variants__.Required,
            __gel_variant__="Required",
        ):
            pass

        class PartialBase(  # type: ignore [misc, unused-ignore]
            __Property_typeof_partial__,
            Base,
            Pointer.__variants__.PartialBase,
            __gel_variant__="PartialBase",
        ):
            pass

        class Partial(  # type: ignore [misc, unused-ignore]
            PartialBase,
            Pointer.__variants__.Partial,
            __gel_variant__="Partial",
        ):
            pass


        Any = TypeVar("Any", bound="Property | Base | Required | Partial")
    class __links__(Pointer.__links__):
        pass
    class __links_partial__(Pointer.__links_partial__):
        pass

if not TYPE_CHECKING:
    Property.__variants__.Base = Property



#
# type schema::Array
#
class __Array_typeof_base__(__CollectionType_typeof_base__):
    class __gel_reflection__(
        __CollectionType_typeof_base__.__gel_reflection__,
    ):
        id = UUID(int=53484707270343816062197209396756293927)
        name = SchemaPath('schema', 'Array')
        @LazyClassProperty["dict[str, GelPointerReflection]"]
        @classmethod
        def pointers(cls) -> dict[str, GelPointerReflection]:
            my_ptrs: dict[str, GelPointerReflection] = {
                'dimensions': GelPointerReflection(
                    name='dimensions',
                    type=SchemaPath('array<std::int16>'),
                    typexpr='array<std::int16>',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
                'element_type': GelPointerReflection(
                    name='element_type',
                    type=SchemaPath('schema', 'Type'),
                    typexpr='schema::Type',
                    kind=PointerKind('Link'),
                    cardinality=pydantic.Cardinality('One'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
            }
            return (
                my_ptrs
                | __CollectionType_typeof_base__.__gel_reflection__.pointers
            )

        @LazyClassProperty["schema.ObjectType"]
        @classmethod
        def object(cls) -> schema.ObjectType:
            from ... import schema as ___schema_1__
            return ___schema_1__.ObjectType(
                id=UUID(int=53484707270343816062197209396756293927),
                name='schema::Array',
                builtin=True,
                internal=False,
                abstract=False,
                final=False,
                compound_type=False,
            )

class __Array_typeof__(__CollectionType_typeof__, __Array_typeof_base__):
    class __typeof__(__CollectionType_typeof__.__typeof__):
        dimensions = TypeAliasType('dimensions', 'OptionalProperty[___pydantic__.Array[std.int16], list[int]]')
        element_type = TypeAliasType('element_type', 'Type')


class __Array_typeof_partial__(
    __CollectionType_typeof_partial__,
    __Array_typeof_base__,
):
    class __typeof__(__CollectionType_typeof_partial__.__typeof__):
        dimensions = TypeAliasType('dimensions', 'OptionalProperty[___pydantic__.Array[std.int16], list[int]]')
        element_type = TypeAliasType('element_type', 'Type | Type.__variants__.Partial')


class Array(
    __Array_typeof__,
    CollectionType,
    __gel_type_id__=UUID(int=53484707270343816062197209396756293927),
):
    if TYPE_CHECKING:
        def __init__(
            self,
            /,
            *,
            id: UUID | DefaultValue = DEFAULT_VALUE,
            name: builtins.str,
            internal: bool | DefaultValue = DEFAULT_VALUE,
            builtin: bool | DefaultValue = DEFAULT_VALUE,
            computed_fields: list[builtins.str] | None = None,
            annotations: Iterable[Annotation] = [],
            abstract: bool | None | DefaultValue = DEFAULT_VALUE,
            final: bool,
            expr: builtins.str | None = None,
            from_alias: bool | None = None,
            dimensions: list[int] | None = None,
            element_type: Type | None = None,
        ) -> None:
            """Create a new schema::Array instance from keyword arguments.

            Call db.save() on the returned object to persist it in the database.
            """
            ...

    if TYPE_CHECKING:
        @classmethod
        def update(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
            abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            from_alias: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            dimensions: type[___pydantic__.Array[___std__.int16]] | UnspecifiedType = Unspecified,
            element_type: type[schema.Type] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Update schema::Array instances in the database.
            """
            ...

        @classmethod
        def select(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: PathAlias | Literal["*"],
            id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Annotation] | UnspecifiedType = Unspecified,
            abstract: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            final: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            expr: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            from_alias: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            dimensions: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.int16]] | UnspecifiedType = Unspecified,
            element_type: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Type] | UnspecifiedType = Unspecified,
            **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
        ) -> type[Self]:
            """Fetch schema::Array instances from the database.
            """
            ...

        @classmethod
        def filter(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], type[___std__.bool]],
            id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
            abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            final: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            from_alias: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            dimensions: type[___pydantic__.Array[___std__.int16]] | UnspecifiedType = Unspecified,
            element_type: type[schema.Type] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Fetch schema::Array instances from the database.
            """
            ...

        @classmethod
        def order_by(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
            id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            abstract: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            final: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            expr: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            from_alias: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Specify the sort order for the selection"""
            ...


    class __variants__(CollectionType.__variants__):
        class Base(
            __Array_typeof__,
            CollectionType.__variants__.Base,
            __gel_variant__="Base",
        ):
            if TYPE_CHECKING:
                def __init__(
                    self,
                    /,
                    *,
                    id: UUID | DefaultValue = DEFAULT_VALUE,
                    name: builtins.str,
                    internal: bool | DefaultValue = DEFAULT_VALUE,
                    builtin: bool | DefaultValue = DEFAULT_VALUE,
                    computed_fields: list[builtins.str] | None = None,
                    annotations: Iterable[Annotation] = [],
                    abstract: bool | None | DefaultValue = DEFAULT_VALUE,
                    final: bool,
                    expr: builtins.str | None = None,
                    from_alias: bool | None = None,
                    dimensions: list[int] | None = None,
                    element_type: Type | None = None,
                ) -> None:
                    """Create a new schema::Array instance from keyword arguments.

                    Call db.save() on the returned object to persist it in the database.
                    """
                    ...

            if TYPE_CHECKING:
                @classmethod
                def update(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
                    abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    from_alias: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    dimensions: type[___pydantic__.Array[___std__.int16]] | UnspecifiedType = Unspecified,
                    element_type: type[schema.Type] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Update schema::Array instances in the database.
                    """
                    ...

                @classmethod
                def select(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: PathAlias | Literal["*"],
                    id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Annotation] | UnspecifiedType = Unspecified,
                    abstract: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    final: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    expr: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    from_alias: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    dimensions: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.int16]] | UnspecifiedType = Unspecified,
                    element_type: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Type] | UnspecifiedType = Unspecified,
                    **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
                ) -> type[Self]:
                    """Fetch schema::Array instances from the database.
                    """
                    ...

                @classmethod
                def filter(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], type[___std__.bool]],
                    id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
                    abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    final: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    from_alias: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    dimensions: type[___pydantic__.Array[___std__.int16]] | UnspecifiedType = Unspecified,
                    element_type: type[schema.Type] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Fetch schema::Array instances from the database.
                    """
                    ...

                @classmethod
                def order_by(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
                    id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    abstract: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    final: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    expr: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    from_alias: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Specify the sort order for the selection"""
                    ...

        class Required(
            Base,
            CollectionType.__variants__.Required,
            __gel_variant__="Required",
        ):
            element_type: ___schema__.Type

        class PartialBase(  # type: ignore [misc, unused-ignore]
            __Array_typeof_partial__,
            Base,
            CollectionType.__variants__.PartialBase,
            __gel_variant__="PartialBase",
        ):
            pass

        class Partial(  # type: ignore [misc, unused-ignore]
            PartialBase,
            CollectionType.__variants__.Partial,
            __gel_variant__="Partial",
        ):
            dimensions: OptionalProperty[___pydantic__.Array[std.int16], list[int]]
            element_type: ___schema__.Type | ___schema__.Type.__variants__.Partial


        Any = TypeVar("Any", bound="Array | Base | Required | Partial")
    class __links__(CollectionType.__links__):
        pass
    class __links_partial__(CollectionType.__links_partial__):
        pass

if not TYPE_CHECKING:
    Array.__variants__.Base = Array



#
# type schema::MultiRange
#
class __MultiRange_typeof_base__(__CollectionType_typeof_base__):
    class __gel_reflection__(
        __CollectionType_typeof_base__.__gel_reflection__,
    ):
        id = UUID(int=170204997772705628008448912071797868054)
        name = SchemaPath('schema', 'MultiRange')
        @LazyClassProperty["dict[str, GelPointerReflection]"]
        @classmethod
        def pointers(cls) -> dict[str, GelPointerReflection]:
            my_ptrs: dict[str, GelPointerReflection] = {
                'element_type': GelPointerReflection(
                    name='element_type',
                    type=SchemaPath('schema', 'Type'),
                    typexpr='schema::Type',
                    kind=PointerKind('Link'),
                    cardinality=pydantic.Cardinality('One'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
            }
            return (
                my_ptrs
                | __CollectionType_typeof_base__.__gel_reflection__.pointers
            )

        @LazyClassProperty["schema.ObjectType"]
        @classmethod
        def object(cls) -> schema.ObjectType:
            from ... import schema as ___schema_1__
            return ___schema_1__.ObjectType(
                id=UUID(int=170204997772705628008448912071797868054),
                name='schema::MultiRange',
                builtin=True,
                internal=False,
                abstract=False,
                final=False,
                compound_type=False,
            )

class __MultiRange_typeof__(
    __CollectionType_typeof__,
    __MultiRange_typeof_base__,
):
    class __typeof__(__CollectionType_typeof__.__typeof__):
        element_type = TypeAliasType('element_type', 'Type')


class __MultiRange_typeof_partial__(
    __CollectionType_typeof_partial__,
    __MultiRange_typeof_base__,
):
    class __typeof__(__CollectionType_typeof_partial__.__typeof__):
        element_type = TypeAliasType('element_type', 'Type | Type.__variants__.Partial')


class MultiRange(
    __MultiRange_typeof__,
    CollectionType,
    __gel_type_id__=UUID(int=170204997772705628008448912071797868054),
):
    if TYPE_CHECKING:
        def __init__(
            self,
            /,
            *,
            id: UUID | DefaultValue = DEFAULT_VALUE,
            name: builtins.str,
            internal: bool | DefaultValue = DEFAULT_VALUE,
            builtin: bool | DefaultValue = DEFAULT_VALUE,
            computed_fields: list[builtins.str] | None = None,
            annotations: Iterable[Annotation] = [],
            abstract: bool | None | DefaultValue = DEFAULT_VALUE,
            final: bool,
            expr: builtins.str | None = None,
            from_alias: bool | None = None,
            element_type: Type | None = None,
        ) -> None:
            """Create a new schema::MultiRange instance from keyword arguments.

            Call db.save() on the returned object to persist it in the database.
            """
            ...

    if TYPE_CHECKING:
        @classmethod
        def update(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
            abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            from_alias: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            element_type: type[schema.Type] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Update schema::MultiRange instances in the database.
            """
            ...

        @classmethod
        def select(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: PathAlias | Literal["*"],
            id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Annotation] | UnspecifiedType = Unspecified,
            abstract: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            final: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            expr: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            from_alias: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            element_type: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Type] | UnspecifiedType = Unspecified,
            **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
        ) -> type[Self]:
            """Fetch schema::MultiRange instances from the database.
            """
            ...

        @classmethod
        def filter(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], type[___std__.bool]],
            id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
            abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            final: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            from_alias: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            element_type: type[schema.Type] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Fetch schema::MultiRange instances from the database.
            """
            ...

        @classmethod
        def order_by(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
            id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            abstract: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            final: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            expr: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            from_alias: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Specify the sort order for the selection"""
            ...


    class __variants__(CollectionType.__variants__):
        class Base(
            __MultiRange_typeof__,
            CollectionType.__variants__.Base,
            __gel_variant__="Base",
        ):
            if TYPE_CHECKING:
                def __init__(
                    self,
                    /,
                    *,
                    id: UUID | DefaultValue = DEFAULT_VALUE,
                    name: builtins.str,
                    internal: bool | DefaultValue = DEFAULT_VALUE,
                    builtin: bool | DefaultValue = DEFAULT_VALUE,
                    computed_fields: list[builtins.str] | None = None,
                    annotations: Iterable[Annotation] = [],
                    abstract: bool | None | DefaultValue = DEFAULT_VALUE,
                    final: bool,
                    expr: builtins.str | None = None,
                    from_alias: bool | None = None,
                    element_type: Type | None = None,
                ) -> None:
                    """Create a new schema::MultiRange instance from keyword arguments.

                    Call db.save() on the returned object to persist it in the database.
                    """
                    ...

            if TYPE_CHECKING:
                @classmethod
                def update(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
                    abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    from_alias: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    element_type: type[schema.Type] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Update schema::MultiRange instances in the database.
                    """
                    ...

                @classmethod
                def select(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: PathAlias | Literal["*"],
                    id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Annotation] | UnspecifiedType = Unspecified,
                    abstract: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    final: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    expr: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    from_alias: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    element_type: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Type] | UnspecifiedType = Unspecified,
                    **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
                ) -> type[Self]:
                    """Fetch schema::MultiRange instances from the database.
                    """
                    ...

                @classmethod
                def filter(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], type[___std__.bool]],
                    id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
                    abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    final: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    from_alias: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    element_type: type[schema.Type] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Fetch schema::MultiRange instances from the database.
                    """
                    ...

                @classmethod
                def order_by(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
                    id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    abstract: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    final: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    expr: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    from_alias: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Specify the sort order for the selection"""
                    ...

        class Required(
            Base,
            CollectionType.__variants__.Required,
            __gel_variant__="Required",
        ):
            element_type: ___schema__.Type

        class PartialBase(  # type: ignore [misc, unused-ignore]
            __MultiRange_typeof_partial__,
            Base,
            CollectionType.__variants__.PartialBase,
            __gel_variant__="PartialBase",
        ):
            pass

        class Partial(  # type: ignore [misc, unused-ignore]
            PartialBase,
            CollectionType.__variants__.Partial,
            __gel_variant__="Partial",
        ):
            element_type: ___schema__.Type | ___schema__.Type.__variants__.Partial


        Any = TypeVar("Any", bound="MultiRange | Base | Required | Partial")
    class __links__(CollectionType.__links__):
        pass
    class __links_partial__(CollectionType.__links_partial__):
        pass

if not TYPE_CHECKING:
    MultiRange.__variants__.Base = MultiRange



#
# type schema::Range
#
class __Range_typeof_base__(__CollectionType_typeof_base__):
    class __gel_reflection__(
        __CollectionType_typeof_base__.__gel_reflection__,
    ):
        id = UUID(int=272394099022298984585641659238808423105)
        name = SchemaPath('schema', 'Range')
        @LazyClassProperty["dict[str, GelPointerReflection]"]
        @classmethod
        def pointers(cls) -> dict[str, GelPointerReflection]:
            my_ptrs: dict[str, GelPointerReflection] = {
                'element_type': GelPointerReflection(
                    name='element_type',
                    type=SchemaPath('schema', 'Type'),
                    typexpr='schema::Type',
                    kind=PointerKind('Link'),
                    cardinality=pydantic.Cardinality('One'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
            }
            return (
                my_ptrs
                | __CollectionType_typeof_base__.__gel_reflection__.pointers
            )

        @LazyClassProperty["schema.ObjectType"]
        @classmethod
        def object(cls) -> schema.ObjectType:
            from ... import schema as ___schema_1__
            return ___schema_1__.ObjectType(
                id=UUID(int=272394099022298984585641659238808423105),
                name='schema::Range',
                builtin=True,
                internal=False,
                abstract=False,
                final=False,
                compound_type=False,
            )

class __Range_typeof__(__CollectionType_typeof__, __Range_typeof_base__):
    class __typeof__(__CollectionType_typeof__.__typeof__):
        element_type = TypeAliasType('element_type', 'Type')


class __Range_typeof_partial__(
    __CollectionType_typeof_partial__,
    __Range_typeof_base__,
):
    class __typeof__(__CollectionType_typeof_partial__.__typeof__):
        element_type = TypeAliasType('element_type', 'Type | Type.__variants__.Partial')


class Range(
    __Range_typeof__,
    CollectionType,
    __gel_type_id__=UUID(int=272394099022298984585641659238808423105),
):
    if TYPE_CHECKING:
        def __init__(
            self,
            /,
            *,
            id: UUID | DefaultValue = DEFAULT_VALUE,
            name: builtins.str,
            internal: bool | DefaultValue = DEFAULT_VALUE,
            builtin: bool | DefaultValue = DEFAULT_VALUE,
            computed_fields: list[builtins.str] | None = None,
            annotations: Iterable[Annotation] = [],
            abstract: bool | None | DefaultValue = DEFAULT_VALUE,
            final: bool,
            expr: builtins.str | None = None,
            from_alias: bool | None = None,
            element_type: Type | None = None,
        ) -> None:
            """Create a new schema::Range instance from keyword arguments.

            Call db.save() on the returned object to persist it in the database.
            """
            ...

    if TYPE_CHECKING:
        @classmethod
        def update(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
            abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            from_alias: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            element_type: type[schema.Type] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Update schema::Range instances in the database.
            """
            ...

        @classmethod
        def select(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: PathAlias | Literal["*"],
            id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Annotation] | UnspecifiedType = Unspecified,
            abstract: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            final: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            expr: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            from_alias: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            element_type: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Type] | UnspecifiedType = Unspecified,
            **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
        ) -> type[Self]:
            """Fetch schema::Range instances from the database.
            """
            ...

        @classmethod
        def filter(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], type[___std__.bool]],
            id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
            abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            final: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            from_alias: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            element_type: type[schema.Type] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Fetch schema::Range instances from the database.
            """
            ...

        @classmethod
        def order_by(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
            id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            abstract: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            final: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            expr: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            from_alias: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Specify the sort order for the selection"""
            ...


    class __variants__(CollectionType.__variants__):
        class Base(
            __Range_typeof__,
            CollectionType.__variants__.Base,
            __gel_variant__="Base",
        ):
            if TYPE_CHECKING:
                def __init__(
                    self,
                    /,
                    *,
                    id: UUID | DefaultValue = DEFAULT_VALUE,
                    name: builtins.str,
                    internal: bool | DefaultValue = DEFAULT_VALUE,
                    builtin: bool | DefaultValue = DEFAULT_VALUE,
                    computed_fields: list[builtins.str] | None = None,
                    annotations: Iterable[Annotation] = [],
                    abstract: bool | None | DefaultValue = DEFAULT_VALUE,
                    final: bool,
                    expr: builtins.str | None = None,
                    from_alias: bool | None = None,
                    element_type: Type | None = None,
                ) -> None:
                    """Create a new schema::Range instance from keyword arguments.

                    Call db.save() on the returned object to persist it in the database.
                    """
                    ...

            if TYPE_CHECKING:
                @classmethod
                def update(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
                    abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    from_alias: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    element_type: type[schema.Type] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Update schema::Range instances in the database.
                    """
                    ...

                @classmethod
                def select(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: PathAlias | Literal["*"],
                    id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Annotation] | UnspecifiedType = Unspecified,
                    abstract: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    final: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    expr: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    from_alias: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    element_type: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Type] | UnspecifiedType = Unspecified,
                    **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
                ) -> type[Self]:
                    """Fetch schema::Range instances from the database.
                    """
                    ...

                @classmethod
                def filter(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], type[___std__.bool]],
                    id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
                    abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    final: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    from_alias: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    element_type: type[schema.Type] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Fetch schema::Range instances from the database.
                    """
                    ...

                @classmethod
                def order_by(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
                    id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    abstract: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    final: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    expr: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    from_alias: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Specify the sort order for the selection"""
                    ...

        class Required(
            Base,
            CollectionType.__variants__.Required,
            __gel_variant__="Required",
        ):
            element_type: ___schema__.Type

        class PartialBase(  # type: ignore [misc, unused-ignore]
            __Range_typeof_partial__,
            Base,
            CollectionType.__variants__.PartialBase,
            __gel_variant__="PartialBase",
        ):
            pass

        class Partial(  # type: ignore [misc, unused-ignore]
            PartialBase,
            CollectionType.__variants__.Partial,
            __gel_variant__="Partial",
        ):
            element_type: ___schema__.Type | ___schema__.Type.__variants__.Partial


        Any = TypeVar("Any", bound="Range | Base | Required | Partial")
    class __links__(CollectionType.__links__):
        pass
    class __links_partial__(CollectionType.__links_partial__):
        pass

if not TYPE_CHECKING:
    Range.__variants__.Base = Range



#
# type schema::Tuple
#
class __Tuple_typeof_base__(__CollectionType_typeof_base__):
    class __gel_reflection__(
        __CollectionType_typeof_base__.__gel_reflection__,
    ):
        id = UUID(int=287836478248157732887507443490326531560)
        name = SchemaPath('schema', 'Tuple')
        @LazyClassProperty["dict[str, GelPointerReflection]"]
        @classmethod
        def pointers(cls) -> dict[str, GelPointerReflection]:
            my_ptrs: dict[str, GelPointerReflection] = {
                'named': GelPointerReflection(
                    name='named',
                    type=SchemaPath('std', 'bool'),
                    typexpr='std::bool',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('One'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={},
                ),
                'element_types': GelPointerReflection(
                    name='element_types',
                    type=SchemaPath('schema', 'TupleElement'),
                    typexpr='schema::TupleElement',
                    kind=PointerKind('Link'),
                    cardinality=pydantic.Cardinality('Many'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties={
                    'index': GelPointerReflection(
                    name='index',
                    type=SchemaPath('std', 'int64'),
                    typexpr='std::int64',
                    kind=PointerKind('Property'),
                    cardinality=pydantic.Cardinality('AtMostOne'),
                    computed=False,
                    readonly=False,
                    has_default=False,
                    properties=None,
                ),
                },
                ),
            }
            return (
                my_ptrs
                | __CollectionType_typeof_base__.__gel_reflection__.pointers
            )

        @LazyClassProperty["schema.ObjectType"]
        @classmethod
        def object(cls) -> schema.ObjectType:
            from ... import schema as ___schema_1__
            return ___schema_1__.ObjectType(
                id=UUID(int=287836478248157732887507443490326531560),
                name='schema::Tuple',
                builtin=True,
                internal=False,
                abstract=False,
                final=False,
                compound_type=False,
            )

class __Tuple_typeof__(__CollectionType_typeof__, __Tuple_typeof_base__):
    class __typeof__(__CollectionType_typeof__.__typeof__):
        named = TypeAliasType('named', 'std.bool')
        element_types = TypeAliasType('element_types', 'MultiLinkWithProps[Tuple.__links__.element_types, TupleElement]')


class __Tuple_typeof_partial__(
    __CollectionType_typeof_partial__,
    __Tuple_typeof_base__,
):
    class __typeof__(__CollectionType_typeof_partial__.__typeof__):
        named = TypeAliasType('named', 'OptionalProperty[std.bool, bool]')
        element_types = TypeAliasType('element_types', 'MultiLinkWithProps[Tuple.__links__.element_types | Tuple.__links_partial__.element_types, TupleElement]')


class Tuple(
    __Tuple_typeof__,
    CollectionType,
    __gel_type_id__=UUID(int=287836478248157732887507443490326531560),
):
    if TYPE_CHECKING:
        def __init__(
            self,
            /,
            *,
            id: UUID | DefaultValue = DEFAULT_VALUE,
            name: builtins.str,
            internal: bool | DefaultValue = DEFAULT_VALUE,
            builtin: bool | DefaultValue = DEFAULT_VALUE,
            computed_fields: list[builtins.str] | None = None,
            annotations: Iterable[Annotation] = [],
            abstract: bool | None | DefaultValue = DEFAULT_VALUE,
            final: bool,
            expr: builtins.str | None = None,
            from_alias: bool | None = None,
            named: bool,
            element_types: Iterable[TupleElement] = [],
        ) -> None:
            """Create a new schema::Tuple instance from keyword arguments.

            Call db.save() on the returned object to persist it in the database.
            """
            ...

    if TYPE_CHECKING:
        @classmethod
        def update(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
            abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            from_alias: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            named: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            element_types: type[schema.TupleElement] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Update schema::Tuple instances in the database.
            """
            ...

        @classmethod
        def select(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: PathAlias | Literal["*"],
            id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Annotation] | UnspecifiedType = Unspecified,
            abstract: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            final: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            expr: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            from_alias: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            named: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            element_types: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.TupleElement] | UnspecifiedType = Unspecified,
            **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
        ) -> type[Self]:
            """Fetch schema::Tuple instances from the database.
            """
            ...

        @classmethod
        def filter(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], type[___std__.bool]],
            id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
            abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            final: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            from_alias: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            named: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            element_types: type[schema.TupleElement] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Fetch schema::Tuple instances from the database.
            """
            ...

        @classmethod
        def order_by(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
            id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            abstract: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            final: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            expr: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            from_alias: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            named: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Specify the sort order for the selection"""
            ...


    class __variants__(CollectionType.__variants__):
        class Base(
            __Tuple_typeof__,
            CollectionType.__variants__.Base,
            __gel_variant__="Base",
        ):
            if TYPE_CHECKING:
                def __init__(
                    self,
                    /,
                    *,
                    id: UUID | DefaultValue = DEFAULT_VALUE,
                    name: builtins.str,
                    internal: bool | DefaultValue = DEFAULT_VALUE,
                    builtin: bool | DefaultValue = DEFAULT_VALUE,
                    computed_fields: list[builtins.str] | None = None,
                    annotations: Iterable[Annotation] = [],
                    abstract: bool | None | DefaultValue = DEFAULT_VALUE,
                    final: bool,
                    expr: builtins.str | None = None,
                    from_alias: bool | None = None,
                    named: bool,
                    element_types: Iterable[TupleElement] = [],
                ) -> None:
                    """Create a new schema::Tuple instance from keyword arguments.

                    Call db.save() on the returned object to persist it in the database.
                    """
                    ...

            if TYPE_CHECKING:
                @classmethod
                def update(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
                    abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    from_alias: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    named: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    element_types: type[schema.TupleElement] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Update schema::Tuple instances in the database.
                    """
                    ...

                @classmethod
                def select(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: PathAlias | Literal["*"],
                    id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Annotation] | UnspecifiedType = Unspecified,
                    abstract: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    final: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    expr: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    from_alias: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    named: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    element_types: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.TupleElement] | UnspecifiedType = Unspecified,
                    **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
                ) -> type[Self]:
                    """Fetch schema::Tuple instances from the database.
                    """
                    ...

                @classmethod
                def filter(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], type[___std__.bool]],
                    id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
                    abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    final: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    from_alias: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    named: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    element_types: type[schema.TupleElement] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Fetch schema::Tuple instances from the database.
                    """
                    ...

                @classmethod
                def order_by(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
                    id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    abstract: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    final: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    expr: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    from_alias: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    named: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Specify the sort order for the selection"""
                    ...

        class Required(
            Base,
            CollectionType.__variants__.Required,
            __gel_variant__="Required",
        ):
            named: std.bool

        class PartialBase(  # type: ignore [misc, unused-ignore]
            __Tuple_typeof_partial__,
            Base,
            CollectionType.__variants__.PartialBase,
            __gel_variant__="PartialBase",
        ):
            pass

        class Partial(  # type: ignore [misc, unused-ignore]
            PartialBase,
            CollectionType.__variants__.Partial,
            __gel_variant__="Partial",
        ):
            named: OptionalProperty[std.bool, bool]
            element_types: MultiLinkWithProps[Tuple.__links__.element_types | Tuple.__links_partial__.element_types, ___schema__.TupleElement]


        Any = TypeVar("Any", bound="Tuple | Base | Required | Partial")
    class __links__(CollectionType.__links__):
        if TYPE_CHECKING:
            class element_types(
                schema.TupleElement,
                ProxyModel[schema.TupleElement],
            ):
                """link schema::Tuple.element_types: schema::TupleElement"""
                class __lprops__(GelLinkModel):
                    class __gel_reflection__(GelLinkModel.__gel_reflection__):
                        id = UUID(int=80382867830044552117875427747792047491)
                        name = SchemaPath('element_types')
                        @LazyClassProperty["dict[str, GelPointerReflection]"]
                        @classmethod
                        def pointers(cls) -> dict[str, GelPointerReflection]:
                            my_ptrs: dict[str, GelPointerReflection] = {
                                'index': GelPointerReflection(
                                    name='index',
                                    type=SchemaPath('std', 'int64'),
                                    typexpr='std::int64',
                                    kind=PointerKind('Property'),
                                    cardinality=pydantic.Cardinality('AtMostOne'),
                                    computed=False,
                                    readonly=False,
                                    has_default=False,
                                    properties=None,
                                ),
                            }
                            return my_ptrs


                    index: OptionalProperty[___std__.int64, ___builtins_3__.int]
                __linkprops__: __lprops__

                def __init__(
                    self,
                    obj: schema.TupleElement,
                    /,
                    *,
                    index: ___builtins_3__.int | None = None,
                ) -> None:
                    ...

                @classmethod
                def link(
                    cls,
                    obj: schema.TupleElement,
                    /,
                    *,
                    index: ___builtins_3__.int | None = None,
                ) -> Self:
                    ...

        if not TYPE_CHECKING:
            @LazyClassProperty[type]
            @classmethod
            def element_types(cls) -> type:
                class Tuple__element_types(
                    ___schema__.TupleElement,
                    ProxyModel[___schema__.TupleElement],
                ):
                    """link schema::Tuple.element_types: schema::TupleElement"""
                    class __lprops__(GelLinkModel):
                        class __gel_reflection__(
                            GelLinkModel.__gel_reflection__,
                        ):
                            id = UUID(int=80382867830044552117875427747792047491)
                            name = SchemaPath('element_types')
                            @LazyClassProperty["dict[str, GelPointerReflection]"]
                            @classmethod
                            def pointers(
                                cls,
                            ) -> dict[str, GelPointerReflection]:
                                my_ptrs: dict[str, GelPointerReflection] = {
                                    'index': GelPointerReflection(
                                        name='index',
                                        type=SchemaPath('std', 'int64'),
                                        typexpr='std::int64',
                                        kind=PointerKind('Property'),
                                        cardinality=pydantic.Cardinality('AtMostOne'),
                                        computed=False,
                                        readonly=False,
                                        has_default=False,
                                        properties=None,
                                    ),
                                }
                                return my_ptrs


                        index: OptionalProperty[std.int64, ___builtins_3__.int]
                    __linkprops__: __lprops__

                    def __init__(self, obj, /, **link_props) -> None:
                        ProxyModel.__init__(self, obj)
                        lprops = self.__class__.__lprops__(**link_props)
                        object.__setattr__(self, "__linkprops__", lprops)

                    @classmethod
                    def link(cls, obj, /, **link_props) -> Self:
                        return cls(obj, **link_props)

                Tuple__element_types.__name__ = 'element_types'
                Tuple__element_types.__qualname__ = 'Tuple.element_types'
                return Tuple__element_types
    class __links_partial__(CollectionType.__links_partial__):
        if TYPE_CHECKING:
            class element_types(  # type: ignore [misc]
                schema.TupleElement.__variants__.Partial,
                ProxyModel[schema.TupleElement.__variants__.Partial],
            ):
                """link schema::Tuple.element_types: schema::TupleElement"""
                class __lprops__(GelLinkModel):
                    class __gel_reflection__(GelLinkModel.__gel_reflection__):
                        id = UUID(int=80382867830044552117875427747792047491)
                        name = SchemaPath('element_types')
                        @LazyClassProperty["dict[str, GelPointerReflection]"]
                        @classmethod
                        def pointers(cls) -> dict[str, GelPointerReflection]:
                            my_ptrs: dict[str, GelPointerReflection] = {
                                'index': GelPointerReflection(
                                    name='index',
                                    type=SchemaPath('std', 'int64'),
                                    typexpr='std::int64',
                                    kind=PointerKind('Property'),
                                    cardinality=pydantic.Cardinality('AtMostOne'),
                                    computed=False,
                                    readonly=False,
                                    has_default=False,
                                    properties=None,
                                ),
                            }
                            return my_ptrs


                    index: OptionalProperty[___std__.int64, ___builtins_3__.int]
                __linkprops__: __lprops__

                def __init__(
                    self,
                    obj: schema.TupleElement.__variants__.Partial,
                    /,
                    *,
                    index: ___builtins_3__.int | None = None,
                ) -> None:
                    ...

                @classmethod
                def link(
                    cls,
                    obj: schema.TupleElement.__variants__.Partial,
                    /,
                    *,
                    index: ___builtins_3__.int | None = None,
                ) -> Self:
                    ...

        if not TYPE_CHECKING:
            @LazyClassProperty[type]
            @classmethod
            def element_types(cls) -> type:
                class Tuple__element_types(  # type: ignore [misc]
                    ___schema__.TupleElement.__variants__.Partial,
                    ProxyModel[___schema__.TupleElement.__variants__.Partial],
                ):
                    """link schema::Tuple.element_types: schema::TupleElement"""
                    class __lprops__(GelLinkModel):
                        class __gel_reflection__(
                            GelLinkModel.__gel_reflection__,
                        ):
                            id = UUID(int=80382867830044552117875427747792047491)
                            name = SchemaPath('element_types')
                            @LazyClassProperty["dict[str, GelPointerReflection]"]
                            @classmethod
                            def pointers(
                                cls,
                            ) -> dict[str, GelPointerReflection]:
                                my_ptrs: dict[str, GelPointerReflection] = {
                                    'index': GelPointerReflection(
                                        name='index',
                                        type=SchemaPath('std', 'int64'),
                                        typexpr='std::int64',
                                        kind=PointerKind('Property'),
                                        cardinality=pydantic.Cardinality('AtMostOne'),
                                        computed=False,
                                        readonly=False,
                                        has_default=False,
                                        properties=None,
                                    ),
                                }
                                return my_ptrs


                        index: OptionalProperty[std.int64, ___builtins_3__.int]
                    __linkprops__: __lprops__

                    def __init__(self, obj, /, **link_props) -> None:
                        ProxyModel.__init__(self, obj)
                        lprops = self.__class__.__lprops__(**link_props)
                        object.__setattr__(self, "__linkprops__", lprops)

                    @classmethod
                    def link(cls, obj, /, **link_props) -> Self:
                        return cls(obj, **link_props)

                Tuple__element_types.__name__ = 'element_types'
                Tuple__element_types.__qualname__ = 'Tuple.element_types'
                return Tuple__element_types

if not TYPE_CHECKING:
    Tuple.__variants__.Base = Tuple



#
# type schema::ArrayExprAlias
#
class __ArrayExprAlias_typeof_base__(__Array_typeof_base__):
    class __gel_reflection__(__Array_typeof_base__.__gel_reflection__):
        id = UUID(int=61590213175760747272592738068582400723)
        name = SchemaPath('schema', 'ArrayExprAlias')
        @LazyClassProperty["dict[str, ___pydantic_1__.GelPointerReflection]"]
        @classmethod
        def pointers(cls) -> dict[str, ___pydantic_1__.GelPointerReflection]:
            my_ptrs: dict[str, ___pydantic_1__.GelPointerReflection] = {}
            return (
                my_ptrs
                | __Array_typeof_base__.__gel_reflection__.pointers
            )

        @LazyClassProperty["schema.ObjectType"]
        @classmethod
        def object(cls) -> schema.ObjectType:
            from ... import schema as ___schema_1__
            return ___schema_1__.ObjectType(
                id=UUID(int=61590213175760747272592738068582400723),
                name='schema::ArrayExprAlias',
                builtin=True,
                internal=False,
                abstract=False,
                final=False,
                compound_type=False,
            )

class __ArrayExprAlias_typeof__(
    __Array_typeof__,
    __ArrayExprAlias_typeof_base__,
):
    class __typeof__(__Array_typeof__.__typeof__):
        pass


class __ArrayExprAlias_typeof_partial__(
    __Array_typeof_partial__,
    __ArrayExprAlias_typeof_base__,
):
    class __typeof__(__Array_typeof_partial__.__typeof__):
        pass


class ArrayExprAlias(
    __ArrayExprAlias_typeof__,
    Array,
    __gel_type_id__=UUID(int=61590213175760747272592738068582400723),
):
    if TYPE_CHECKING:
        def __init__(
            self,
            /,
            *,
            id: UUID | DefaultValue = DEFAULT_VALUE,
            name: builtins.str,
            internal: bool | DefaultValue = DEFAULT_VALUE,
            builtin: bool | DefaultValue = DEFAULT_VALUE,
            computed_fields: list[builtins.str] | None = None,
            annotations: Iterable[Annotation] = [],
            abstract: bool | None | DefaultValue = DEFAULT_VALUE,
            final: bool,
            expr: builtins.str | None = None,
            from_alias: bool | None = None,
            dimensions: list[int] | None = None,
            element_type: Type | None = None,
        ) -> None:
            """Create a new schema::ArrayExprAlias instance from keyword arguments.

            Call db.save() on the returned object to persist it in the database.
            """
            ...

    if TYPE_CHECKING:
        @classmethod
        def update(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
            abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            from_alias: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            dimensions: type[___pydantic__.Array[___std__.int16]] | UnspecifiedType = Unspecified,
            element_type: type[schema.Type] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Update schema::ArrayExprAlias instances in the database.
            """
            ...

        @classmethod
        def select(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: PathAlias | Literal["*"],
            id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Annotation] | UnspecifiedType = Unspecified,
            abstract: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            final: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            expr: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            from_alias: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            dimensions: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.int16]] | UnspecifiedType = Unspecified,
            element_type: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Type] | UnspecifiedType = Unspecified,
            **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
        ) -> type[Self]:
            """Fetch schema::ArrayExprAlias instances from the database.
            """
            ...

        @classmethod
        def filter(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], type[___std__.bool]],
            id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
            abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            final: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            from_alias: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            dimensions: type[___pydantic__.Array[___std__.int16]] | UnspecifiedType = Unspecified,
            element_type: type[schema.Type] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Fetch schema::ArrayExprAlias instances from the database.
            """
            ...

        @classmethod
        def order_by(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
            id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            abstract: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            final: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            expr: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            from_alias: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Specify the sort order for the selection"""
            ...


    class __variants__(Array.__variants__):
        class Base(
            __ArrayExprAlias_typeof__,
            Array.__variants__.Base,
            __gel_variant__="Base",
        ):
            if TYPE_CHECKING:
                def __init__(
                    self,
                    /,
                    *,
                    id: UUID | DefaultValue = DEFAULT_VALUE,
                    name: builtins.str,
                    internal: bool | DefaultValue = DEFAULT_VALUE,
                    builtin: bool | DefaultValue = DEFAULT_VALUE,
                    computed_fields: list[builtins.str] | None = None,
                    annotations: Iterable[Annotation] = [],
                    abstract: bool | None | DefaultValue = DEFAULT_VALUE,
                    final: bool,
                    expr: builtins.str | None = None,
                    from_alias: bool | None = None,
                    dimensions: list[int] | None = None,
                    element_type: Type | None = None,
                ) -> None:
                    """Create a new schema::ArrayExprAlias instance from keyword arguments.

                    Call db.save() on the returned object to persist it in the database.
                    """
                    ...

            if TYPE_CHECKING:
                @classmethod
                def update(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
                    abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    from_alias: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    dimensions: type[___pydantic__.Array[___std__.int16]] | UnspecifiedType = Unspecified,
                    element_type: type[schema.Type] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Update schema::ArrayExprAlias instances in the database.
                    """
                    ...

                @classmethod
                def select(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: PathAlias | Literal["*"],
                    id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Annotation] | UnspecifiedType = Unspecified,
                    abstract: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    final: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    expr: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    from_alias: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    dimensions: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.int16]] | UnspecifiedType = Unspecified,
                    element_type: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Type] | UnspecifiedType = Unspecified,
                    **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
                ) -> type[Self]:
                    """Fetch schema::ArrayExprAlias instances from the database.
                    """
                    ...

                @classmethod
                def filter(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], type[___std__.bool]],
                    id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
                    abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    final: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    from_alias: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    dimensions: type[___pydantic__.Array[___std__.int16]] | UnspecifiedType = Unspecified,
                    element_type: type[schema.Type] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Fetch schema::ArrayExprAlias instances from the database.
                    """
                    ...

                @classmethod
                def order_by(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
                    id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    abstract: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    final: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    expr: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    from_alias: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Specify the sort order for the selection"""
                    ...

        class Required(
            Base,
            Array.__variants__.Required,
            __gel_variant__="Required",
        ):
            pass

        class PartialBase(  # type: ignore [misc, unused-ignore]
            __ArrayExprAlias_typeof_partial__,
            Base,
            Array.__variants__.PartialBase,
            __gel_variant__="PartialBase",
        ):
            pass

        class Partial(  # type: ignore [misc, unused-ignore]
            PartialBase,
            Array.__variants__.Partial,
            __gel_variant__="Partial",
        ):
            pass


        Any = TypeVar("Any", bound="ArrayExprAlias | Base | Required | Partial")
    class __links__(Array.__links__):
        pass
    class __links_partial__(Array.__links_partial__):
        pass

if not TYPE_CHECKING:
    ArrayExprAlias.__variants__.Base = ArrayExprAlias



#
# type schema::MultiRangeExprAlias
#
class __MultiRangeExprAlias_typeof_base__(__MultiRange_typeof_base__):
    class __gel_reflection__(__MultiRange_typeof_base__.__gel_reflection__):
        id = UUID(int=224883386490687742483367914857266351077)
        name = SchemaPath('schema', 'MultiRangeExprAlias')
        @LazyClassProperty["dict[str, ___pydantic_1__.GelPointerReflection]"]
        @classmethod
        def pointers(cls) -> dict[str, ___pydantic_1__.GelPointerReflection]:
            my_ptrs: dict[str, ___pydantic_1__.GelPointerReflection] = {}
            return (
                my_ptrs
                | __MultiRange_typeof_base__.__gel_reflection__.pointers
            )

        @LazyClassProperty["schema.ObjectType"]
        @classmethod
        def object(cls) -> schema.ObjectType:
            from ... import schema as ___schema_1__
            return ___schema_1__.ObjectType(
                id=UUID(int=224883386490687742483367914857266351077),
                name='schema::MultiRangeExprAlias',
                builtin=True,
                internal=False,
                abstract=False,
                final=False,
                compound_type=False,
            )

class __MultiRangeExprAlias_typeof__(
    __MultiRange_typeof__,
    __MultiRangeExprAlias_typeof_base__,
):
    class __typeof__(__MultiRange_typeof__.__typeof__):
        pass


class __MultiRangeExprAlias_typeof_partial__(
    __MultiRange_typeof_partial__,
    __MultiRangeExprAlias_typeof_base__,
):
    class __typeof__(__MultiRange_typeof_partial__.__typeof__):
        pass


class MultiRangeExprAlias(
    __MultiRangeExprAlias_typeof__,
    MultiRange,
    __gel_type_id__=UUID(int=224883386490687742483367914857266351077),
):
    if TYPE_CHECKING:
        def __init__(
            self,
            /,
            *,
            id: UUID | DefaultValue = DEFAULT_VALUE,
            name: builtins.str,
            internal: bool | DefaultValue = DEFAULT_VALUE,
            builtin: bool | DefaultValue = DEFAULT_VALUE,
            computed_fields: list[builtins.str] | None = None,
            annotations: Iterable[Annotation] = [],
            abstract: bool | None | DefaultValue = DEFAULT_VALUE,
            final: bool,
            expr: builtins.str | None = None,
            from_alias: bool | None = None,
            element_type: Type | None = None,
        ) -> None:
            """Create a new schema::MultiRangeExprAlias instance from keyword arguments.

            Call db.save() on the returned object to persist it in the database.
            """
            ...

    if TYPE_CHECKING:
        @classmethod
        def update(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
            abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            from_alias: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            element_type: type[schema.Type] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Update schema::MultiRangeExprAlias instances in the database.
            """
            ...

        @classmethod
        def select(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: PathAlias | Literal["*"],
            id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Annotation] | UnspecifiedType = Unspecified,
            abstract: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            final: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            expr: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            from_alias: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            element_type: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Type] | UnspecifiedType = Unspecified,
            **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
        ) -> type[Self]:
            """Fetch schema::MultiRangeExprAlias instances from the database.
            """
            ...

        @classmethod
        def filter(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], type[___std__.bool]],
            id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
            abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            final: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            from_alias: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            element_type: type[schema.Type] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Fetch schema::MultiRangeExprAlias instances from the database.
            """
            ...

        @classmethod
        def order_by(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
            id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            abstract: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            final: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            expr: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            from_alias: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Specify the sort order for the selection"""
            ...


    class __variants__(MultiRange.__variants__):
        class Base(
            __MultiRangeExprAlias_typeof__,
            MultiRange.__variants__.Base,
            __gel_variant__="Base",
        ):
            if TYPE_CHECKING:
                def __init__(
                    self,
                    /,
                    *,
                    id: UUID | DefaultValue = DEFAULT_VALUE,
                    name: builtins.str,
                    internal: bool | DefaultValue = DEFAULT_VALUE,
                    builtin: bool | DefaultValue = DEFAULT_VALUE,
                    computed_fields: list[builtins.str] | None = None,
                    annotations: Iterable[Annotation] = [],
                    abstract: bool | None | DefaultValue = DEFAULT_VALUE,
                    final: bool,
                    expr: builtins.str | None = None,
                    from_alias: bool | None = None,
                    element_type: Type | None = None,
                ) -> None:
                    """Create a new schema::MultiRangeExprAlias instance from keyword arguments.

                    Call db.save() on the returned object to persist it in the database.
                    """
                    ...

            if TYPE_CHECKING:
                @classmethod
                def update(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
                    abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    from_alias: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    element_type: type[schema.Type] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Update schema::MultiRangeExprAlias instances in the database.
                    """
                    ...

                @classmethod
                def select(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: PathAlias | Literal["*"],
                    id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Annotation] | UnspecifiedType = Unspecified,
                    abstract: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    final: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    expr: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    from_alias: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    element_type: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Type] | UnspecifiedType = Unspecified,
                    **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
                ) -> type[Self]:
                    """Fetch schema::MultiRangeExprAlias instances from the database.
                    """
                    ...

                @classmethod
                def filter(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], type[___std__.bool]],
                    id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
                    abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    final: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    from_alias: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    element_type: type[schema.Type] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Fetch schema::MultiRangeExprAlias instances from the database.
                    """
                    ...

                @classmethod
                def order_by(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
                    id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    abstract: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    final: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    expr: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    from_alias: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Specify the sort order for the selection"""
                    ...

        class Required(
            Base,
            MultiRange.__variants__.Required,
            __gel_variant__="Required",
        ):
            pass

        class PartialBase(  # type: ignore [misc, unused-ignore]
            __MultiRangeExprAlias_typeof_partial__,
            Base,
            MultiRange.__variants__.PartialBase,
            __gel_variant__="PartialBase",
        ):
            pass

        class Partial(  # type: ignore [misc, unused-ignore]
            PartialBase,
            MultiRange.__variants__.Partial,
            __gel_variant__="Partial",
        ):
            pass


        Any = TypeVar("Any", bound="MultiRangeExprAlias | Base | Required | Partial")
    class __links__(MultiRange.__links__):
        pass
    class __links_partial__(MultiRange.__links_partial__):
        pass

if not TYPE_CHECKING:
    MultiRangeExprAlias.__variants__.Base = MultiRangeExprAlias



#
# type schema::RangeExprAlias
#
class __RangeExprAlias_typeof_base__(__Range_typeof_base__):
    class __gel_reflection__(__Range_typeof_base__.__gel_reflection__):
        id = UUID(int=250410383444011926837054666695611053661)
        name = SchemaPath('schema', 'RangeExprAlias')
        @LazyClassProperty["dict[str, ___pydantic_1__.GelPointerReflection]"]
        @classmethod
        def pointers(cls) -> dict[str, ___pydantic_1__.GelPointerReflection]:
            my_ptrs: dict[str, ___pydantic_1__.GelPointerReflection] = {}
            return (
                my_ptrs
                | __Range_typeof_base__.__gel_reflection__.pointers
            )

        @LazyClassProperty["schema.ObjectType"]
        @classmethod
        def object(cls) -> schema.ObjectType:
            from ... import schema as ___schema_1__
            return ___schema_1__.ObjectType(
                id=UUID(int=250410383444011926837054666695611053661),
                name='schema::RangeExprAlias',
                builtin=True,
                internal=False,
                abstract=False,
                final=False,
                compound_type=False,
            )

class __RangeExprAlias_typeof__(
    __Range_typeof__,
    __RangeExprAlias_typeof_base__,
):
    class __typeof__(__Range_typeof__.__typeof__):
        pass


class __RangeExprAlias_typeof_partial__(
    __Range_typeof_partial__,
    __RangeExprAlias_typeof_base__,
):
    class __typeof__(__Range_typeof_partial__.__typeof__):
        pass


class RangeExprAlias(
    __RangeExprAlias_typeof__,
    Range,
    __gel_type_id__=UUID(int=250410383444011926837054666695611053661),
):
    if TYPE_CHECKING:
        def __init__(
            self,
            /,
            *,
            id: UUID | DefaultValue = DEFAULT_VALUE,
            name: builtins.str,
            internal: bool | DefaultValue = DEFAULT_VALUE,
            builtin: bool | DefaultValue = DEFAULT_VALUE,
            computed_fields: list[builtins.str] | None = None,
            annotations: Iterable[Annotation] = [],
            abstract: bool | None | DefaultValue = DEFAULT_VALUE,
            final: bool,
            expr: builtins.str | None = None,
            from_alias: bool | None = None,
            element_type: Type | None = None,
        ) -> None:
            """Create a new schema::RangeExprAlias instance from keyword arguments.

            Call db.save() on the returned object to persist it in the database.
            """
            ...

    if TYPE_CHECKING:
        @classmethod
        def update(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
            abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            from_alias: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            element_type: type[schema.Type] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Update schema::RangeExprAlias instances in the database.
            """
            ...

        @classmethod
        def select(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: PathAlias | Literal["*"],
            id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Annotation] | UnspecifiedType = Unspecified,
            abstract: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            final: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            expr: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            from_alias: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            element_type: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Type] | UnspecifiedType = Unspecified,
            **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
        ) -> type[Self]:
            """Fetch schema::RangeExprAlias instances from the database.
            """
            ...

        @classmethod
        def filter(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], type[___std__.bool]],
            id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
            abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            final: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            from_alias: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            element_type: type[schema.Type] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Fetch schema::RangeExprAlias instances from the database.
            """
            ...

        @classmethod
        def order_by(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
            id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            abstract: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            final: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            expr: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            from_alias: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Specify the sort order for the selection"""
            ...


    class __variants__(Range.__variants__):
        class Base(
            __RangeExprAlias_typeof__,
            Range.__variants__.Base,
            __gel_variant__="Base",
        ):
            if TYPE_CHECKING:
                def __init__(
                    self,
                    /,
                    *,
                    id: UUID | DefaultValue = DEFAULT_VALUE,
                    name: builtins.str,
                    internal: bool | DefaultValue = DEFAULT_VALUE,
                    builtin: bool | DefaultValue = DEFAULT_VALUE,
                    computed_fields: list[builtins.str] | None = None,
                    annotations: Iterable[Annotation] = [],
                    abstract: bool | None | DefaultValue = DEFAULT_VALUE,
                    final: bool,
                    expr: builtins.str | None = None,
                    from_alias: bool | None = None,
                    element_type: Type | None = None,
                ) -> None:
                    """Create a new schema::RangeExprAlias instance from keyword arguments.

                    Call db.save() on the returned object to persist it in the database.
                    """
                    ...

            if TYPE_CHECKING:
                @classmethod
                def update(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
                    abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    from_alias: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    element_type: type[schema.Type] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Update schema::RangeExprAlias instances in the database.
                    """
                    ...

                @classmethod
                def select(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: PathAlias | Literal["*"],
                    id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Annotation] | UnspecifiedType = Unspecified,
                    abstract: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    final: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    expr: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    from_alias: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    element_type: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Type] | UnspecifiedType = Unspecified,
                    **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
                ) -> type[Self]:
                    """Fetch schema::RangeExprAlias instances from the database.
                    """
                    ...

                @classmethod
                def filter(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], type[___std__.bool]],
                    id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
                    abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    final: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    from_alias: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    element_type: type[schema.Type] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Fetch schema::RangeExprAlias instances from the database.
                    """
                    ...

                @classmethod
                def order_by(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
                    id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    abstract: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    final: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    expr: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    from_alias: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Specify the sort order for the selection"""
                    ...

        class Required(
            Base,
            Range.__variants__.Required,
            __gel_variant__="Required",
        ):
            pass

        class PartialBase(  # type: ignore [misc, unused-ignore]
            __RangeExprAlias_typeof_partial__,
            Base,
            Range.__variants__.PartialBase,
            __gel_variant__="PartialBase",
        ):
            pass

        class Partial(  # type: ignore [misc, unused-ignore]
            PartialBase,
            Range.__variants__.Partial,
            __gel_variant__="Partial",
        ):
            pass


        Any = TypeVar("Any", bound="RangeExprAlias | Base | Required | Partial")
    class __links__(Range.__links__):
        pass
    class __links_partial__(Range.__links_partial__):
        pass

if not TYPE_CHECKING:
    RangeExprAlias.__variants__.Base = RangeExprAlias



#
# type schema::TupleExprAlias
#
class __TupleExprAlias_typeof_base__(__Tuple_typeof_base__):
    class __gel_reflection__(__Tuple_typeof_base__.__gel_reflection__):
        id = UUID(int=243852543501794655710671212006669279835)
        name = SchemaPath('schema', 'TupleExprAlias')
        @LazyClassProperty["dict[str, ___pydantic_1__.GelPointerReflection]"]
        @classmethod
        def pointers(cls) -> dict[str, ___pydantic_1__.GelPointerReflection]:
            my_ptrs: dict[str, ___pydantic_1__.GelPointerReflection] = {}
            return (
                my_ptrs
                | __Tuple_typeof_base__.__gel_reflection__.pointers
            )

        @LazyClassProperty["schema.ObjectType"]
        @classmethod
        def object(cls) -> schema.ObjectType:
            from ... import schema as ___schema_1__
            return ___schema_1__.ObjectType(
                id=UUID(int=243852543501794655710671212006669279835),
                name='schema::TupleExprAlias',
                builtin=True,
                internal=False,
                abstract=False,
                final=False,
                compound_type=False,
            )

class __TupleExprAlias_typeof__(
    __Tuple_typeof__,
    __TupleExprAlias_typeof_base__,
):
    class __typeof__(__Tuple_typeof__.__typeof__):
        pass


class __TupleExprAlias_typeof_partial__(
    __Tuple_typeof_partial__,
    __TupleExprAlias_typeof_base__,
):
    class __typeof__(__Tuple_typeof_partial__.__typeof__):
        pass


class TupleExprAlias(
    __TupleExprAlias_typeof__,
    Tuple,
    __gel_type_id__=UUID(int=243852543501794655710671212006669279835),
):
    if TYPE_CHECKING:
        def __init__(
            self,
            /,
            *,
            id: UUID | DefaultValue = DEFAULT_VALUE,
            name: builtins.str,
            internal: bool | DefaultValue = DEFAULT_VALUE,
            builtin: bool | DefaultValue = DEFAULT_VALUE,
            computed_fields: list[builtins.str] | None = None,
            annotations: Iterable[Annotation] = [],
            abstract: bool | None | DefaultValue = DEFAULT_VALUE,
            final: bool,
            expr: builtins.str | None = None,
            from_alias: bool | None = None,
            named: bool,
            element_types: Iterable[TupleElement] = [],
        ) -> None:
            """Create a new schema::TupleExprAlias instance from keyword arguments.

            Call db.save() on the returned object to persist it in the database.
            """
            ...

    if TYPE_CHECKING:
        @classmethod
        def update(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
            abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            from_alias: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            named: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            element_types: type[schema.TupleElement] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Update schema::TupleExprAlias instances in the database.
            """
            ...

        @classmethod
        def select(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: PathAlias | Literal["*"],
            id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Annotation] | UnspecifiedType = Unspecified,
            abstract: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            final: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            expr: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
            from_alias: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            named: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
            element_types: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.TupleElement] | UnspecifiedType = Unspecified,
            **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
        ) -> type[Self]:
            """Fetch schema::TupleExprAlias instances from the database.
            """
            ...

        @classmethod
        def filter(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], type[___std__.bool]],
            id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
            name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
            annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
            abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            final: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
            from_alias: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            named: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
            element_types: type[schema.TupleElement] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Fetch schema::TupleExprAlias instances from the database.
            """
            ...

        @classmethod
        def order_by(  # type: ignore [misc, override, unused-ignore]
            cls,
            /,
            *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
            id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            abstract: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            final: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            expr: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            from_alias: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
            named: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
        ) -> type[Self]:
            """Specify the sort order for the selection"""
            ...


    class __variants__(Tuple.__variants__):
        class Base(
            __TupleExprAlias_typeof__,
            Tuple.__variants__.Base,
            __gel_variant__="Base",
        ):
            if TYPE_CHECKING:
                def __init__(
                    self,
                    /,
                    *,
                    id: UUID | DefaultValue = DEFAULT_VALUE,
                    name: builtins.str,
                    internal: bool | DefaultValue = DEFAULT_VALUE,
                    builtin: bool | DefaultValue = DEFAULT_VALUE,
                    computed_fields: list[builtins.str] | None = None,
                    annotations: Iterable[Annotation] = [],
                    abstract: bool | None | DefaultValue = DEFAULT_VALUE,
                    final: bool,
                    expr: builtins.str | None = None,
                    from_alias: bool | None = None,
                    named: bool,
                    element_types: Iterable[TupleElement] = [],
                ) -> None:
                    """Create a new schema::TupleExprAlias instance from keyword arguments.

                    Call db.save() on the returned object to persist it in the database.
                    """
                    ...

            if TYPE_CHECKING:
                @classmethod
                def update(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
                    abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    from_alias: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    named: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    element_types: type[schema.TupleElement] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Update schema::TupleExprAlias instances in the database.
                    """
                    ...

                @classmethod
                def select(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: PathAlias | Literal["*"],
                    id: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.Annotation] | UnspecifiedType = Unspecified,
                    abstract: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    final: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    expr: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.str] | UnspecifiedType = Unspecified,
                    from_alias: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    named: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[___std__.bool] | UnspecifiedType = Unspecified,
                    element_types: ___builtins__.bool | Callable[[type[Self]], ExprCompatible] | ExprCompatible | type[schema.TupleElement] | UnspecifiedType = Unspecified,
                    **computed: Callable[[type[Self]], ExprCompatible] | ExprCompatible | PyConstType,
                ) -> type[Self]:
                    """Fetch schema::TupleExprAlias instances from the database.
                    """
                    ...

                @classmethod
                def filter(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], type[___std__.bool]],
                    id: UUID | type[___std__.uuid] | UnspecifiedType = Unspecified,
                    name: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    internal: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    builtin: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    computed_fields: type[___pydantic__.Array[___std__.str]] | UnspecifiedType = Unspecified,
                    annotations: type[schema.Annotation] | UnspecifiedType = Unspecified,
                    abstract: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    final: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    expr: ___builtins_1__.str | type[___std__.str] | UnspecifiedType = Unspecified,
                    from_alias: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    named: ___builtins_2__.bool | type[___std__.bool] | UnspecifiedType = Unspecified,
                    element_types: type[schema.TupleElement] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Fetch schema::TupleExprAlias instances from the database.
                    """
                    ...

                @classmethod
                def order_by(  # type: ignore [misc, override, unused-ignore]
                    cls,
                    /,
                    *exprs: Callable[[type[Self]], ExprCompatible] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str] | tuple[Callable[[type[Self]], ExprCompatible], Direction | ___builtins__.str, EmptyDirection | ___builtins__.str],
                    id: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    name: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    internal: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    builtin: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    abstract: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    final: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    expr: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    from_alias: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                    named: Direction | ___builtins__.str | ___builtins__.str | ___builtins__.bool | tuple[Direction | ___builtins__.str, EmptyDirection | ___builtins__.str] | UnspecifiedType = Unspecified,
                ) -> type[Self]:
                    """Specify the sort order for the selection"""
                    ...

        class Required(
            Base,
            Tuple.__variants__.Required,
            __gel_variant__="Required",
        ):
            pass

        class PartialBase(  # type: ignore [misc, unused-ignore]
            __TupleExprAlias_typeof_partial__,
            Base,
            Tuple.__variants__.PartialBase,
            __gel_variant__="PartialBase",
        ):
            pass

        class Partial(  # type: ignore [misc, unused-ignore]
            PartialBase,
            Tuple.__variants__.Partial,
            __gel_variant__="Partial",
        ):
            pass


        Any = TypeVar("Any", bound="TupleExprAlias | Base | Required | Partial")
    class __links__(Tuple.__links__):
        pass
    class __links_partial__(Tuple.__links_partial__):
        pass

if not TYPE_CHECKING:
    TupleExprAlias.__variants__.Base = TupleExprAlias



from .. import sys  # noqa: E402 F403
from ... import schema as ___schema__, sys as ___sys_1__  # noqa: E402 F403
from ...std.__types__ import NameExpr_Tuple_9eMVFg  # noqa: E402 F403

import builtins as builtins  # noqa: E402 F403
from builtins import bool, int  # noqa: E402 F403
